#!/usr/bin/env python3
"""
Repository audit tool per A1-AUDIT-REPORT.
Scans Python modules, estimates line counts, checks presence of tests,
and flags potential dead code (no references) heuristically.

Usage:
  python tools/repo_audit.py --write-doc
"""
from __future__ import annotations

import argparse
from collections.abc import Iterable
from dataclasses import asdict, dataclass
import json
from pathlib import Path
import subprocess

ROOT = Path(__file__).resolve().parents[1]


@dataclass
class ModuleInfo:
    path: str
    lines: int
    has_tests: bool
    last_commit: str | None = None


@dataclass
class AuditReport:
    modules: list[ModuleInfo]
    dead_code: list[str]
    notebooks: list[str]
    runners: list[str]


def _iter_python_files(root: Path) -> Iterable[Path]:
    for p in root.rglob("*.py"):
        # Skip common virtual/env and caches
        if any(x in p.parts for x in {".venv", "venv", ".pytest_cache", "__pycache__", ".eggs"}):
            continue
        yield p


def _git_last_commit(rel_path: Path) -> str | None:
    try:
        out = subprocess.check_output([
            "git", "log", "-n", "1", "--pretty=%h", "--", str(rel_path)
        ], cwd=ROOT, text=True)
        return out.strip() or None
    except Exception:
        return None


def _has_tests_for(path: Path) -> bool:
    tests_dir = ROOT / "tests"
    if not tests_dir.exists():
        return False
    stem = path.stem
    # common conventions
    patterns = [
        f"test_{stem}.py",
        f"{stem}_test.py",
    ]
    for pat in patterns:
        if list(tests_dir.rglob(pat)):
            return True
    return False


def _detect_notebooks(root: Path) -> list[str]:
    return [str(p.relative_to(root)) for p in root.rglob("*.ipynb")]


def _detect_runners(root: Path) -> list[str]:
    candidates: list[Path] = []
    for p in root.rglob("*.py"):
        if any(k in p.as_posix() for k in ["runner", "run_", "service.py", "aurora_api_lite.py"]):
            candidates.append(p)
    return sorted({str(p.relative_to(root)) for p in candidates})


def scan_repo(root: Path) -> AuditReport:
    modules: list[ModuleInfo] = []
    refs_text = "\n".join(
        (ROOT / f).read_text(encoding="utf-8", errors="ignore")
        for f in [str(p.relative_to(ROOT)) for p in _iter_python_files(ROOT)]
    )

    for py in _iter_python_files(root):
        try:
            text = py.read_text(encoding="utf-8", errors="ignore")
        except Exception:
            text = ""
        lines = len(text.splitlines())
        rel = py.relative_to(root)
        last = _git_last_commit(rel)
        has_tests = _has_tests_for(py)
        modules.append(ModuleInfo(path=str(rel), lines=lines, has_tests=has_tests, last_commit=last))

    # Heuristic dead code: files under core/ or tools/ that are never imported or executed
    dead: list[str] = []
    for m in modules:
        if any(m.path.startswith(prefix) for prefix in ["core/", "tools/", "skalp_bot/"]):
            name = Path(m.path).stem
            if name and refs_text.count(name) <= 1:  # itself
                dead.append(m.path)

    notebooks = _detect_notebooks(root)
    runners = _detect_runners(root)

    return AuditReport(modules=modules, dead_code=sorted(dead), notebooks=sorted(notebooks), runners=runners)


def _write_markdown(report: AuditReport, out_path: Path) -> None:
    lines: list[str] = []
    lines.append("# AUDIT — Current State\n")
    lines.append("Generated by tools/repo_audit.py\n")

    lines.append("## Modules\n")
    lines.append("| Module | Lines | Has tests | Last commit |\n|---|---:|:---:|:---:|\n")
    for m in sorted(report.modules, key=lambda x: x.path):
        lines.append(f"| `{m.path}` | {m.lines} | {'✅' if m.has_tests else '❌'} | {m.last_commit or '-'} |\n")

    lines.append("\n## Potential dead code (heuristic)\n")
    if report.dead_code:
        for p in report.dead_code:
            lines.append(f"- `{p}`\n")
    else:
        lines.append("- None detected\n")

    lines.append("\n## Notebooks\n")
    if report.notebooks:
        for n in report.notebooks:
            lines.append(f"- `{n}`\n")
    else:
        lines.append("- None\n")

    lines.append("\n## Runners / Entrypoints (heuristic)\n")
    for r in report.runners:
        lines.append(f"- `{r}`\n")

    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text("".join(lines), encoding="utf-8")


def main() -> None:
    ap = argparse.ArgumentParser()
    ap.add_argument("--write-doc", action="store_true", help="write docs/AUDIT_CURRENT_STATE.md")
    ap.add_argument("--json", action="store_true", help="print JSON to stdout")
    args = ap.parse_args()

    rep = scan_repo(ROOT)
    if args.json:
        print(json.dumps(asdict(rep), indent=2))
    if args.write_doc:
        _write_markdown(rep, ROOT / "docs" / "AUDIT_CURRENT_STATE.md")


if __name__ == "__main__":
    main()
