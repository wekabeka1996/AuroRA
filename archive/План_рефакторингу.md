Я почну з плану задач і детального читання документа Паспорт_проекту.md, щоб витягнути перелік файлів і проблем, а далі перевірю ці твердження по коду і підготую план рефакторингу з оновленням README. Я зчитую і аналізую документ Паспорт_проекту.md, щоб виписати всі перелічені проблеми/файли для подальшої перевірки в коді. Соберу и сверю упомянутые в паспорте файлы с реальным кодом, чтобы подтвердить/опровергнуть перечисленные проблемы перед разработкой плана рефакторинга. Сделаю быстрый обзор ключевых модулей из паспорта (service, governance, health, config.py, config_loader.py, events.py, pretrade, calibrator, trap, icp, sprt) и сверю заявленные проблемы с реальным кодом, чтобы отметить подтверждено/оспоримо. Проверю реализацию `AuroraEventLogger`, чтобы понять совместимость с `EventEmitter` и оценить риски удаления/замены events.py. Резюмированный журнал беседСоберу недостающие детали по логгированию, чтобы завершить верификацию, и затем сформирую краткое резюме точности паспорта и полноценный план рефакторинга с обновлением README. Беру задачу: я добил верификацию по логгированию и готов выдать сжатое заключение по точности “Паспорта проекту” и полный, поэтапный план рефакторинга (структура → исправления → решения проблем).

## Короткий чек‑лист требований

- Проверить паспорт: насколько точно и полно описаны проблемы — Готово.
- Сформировать план рефакторинга:
  1) предложить чёткую структуру проекта и обновление README — Готово;
  2) список исправлений ошибок из паспорта — Готово;
  3) список решений проблем из паспорта — Готово.

Прогресс: перечитал aurora_event_logger.py и events.py — подтвердил дублирование/расхождения и возможность консолидации. Дальше — итоговая верификация и план.

## Верификация утверждений паспорта (точность/полнота)

Ниже — ключевые пункты из “Паспорту проекту” и их статус по коду в репозитории.

- api/models.py: слабая типизация Pretrade (Dict[str, Any] у account/order/market)
  - Статус: подтверждено. models.py действительно использует `Dict[str, Any]`.
- api/service.py: избыточная сложность, смешение обязанностей, неявный порядок гейтов
  - Статус: подтверждено. Длинный inline пайплайн в `/pretrade/check`, смешаны конфиги/логика/метрики/логирование.
- Дублированные “halt/arm” состояния в Governance и HealthGuard
  - Статус: подтверждено. Есть внутренние состояния и там, и там.
- Дублирование конфиг‑лоадеров и sys.exit в config_loader.py
  - Статус: подтверждено. Есть config.py и config_loader.py, последний использует `sys.exit(2)`.
- Логгирование: AuroraEventLogger vs EventEmitter (две реализации)
  - Статус: подтверждено. aurora_event_logger.py — продвинутое логгирование с валидируемым набором кодов, айдeмпотентностью и ротацией; events.py — простой emitter с валидацией через `observability.codes`, несовместим по форме полей и контракту. Консолидация нужна.
- TRAP cancel_pctl “не используется”
  - Статус: опровергнуто. В trap.py `cancel_pctl` участвует в решении.
- Калибратор “только Platt”
  - Статус: устарело. Сейчас calibrator.py — Isotonic Regression с fallback на Platt.
- ICP _detect_transition — заглушка
  - Статус: подтверждено. icp.py возвращает `False`.
- Клиент aurora_gate.py — `DEFAULT_TIMEOUT_S=0.010` (нереалистично)
  - Статус: подтверждено. 10 мс слишком мало.
- Контракт pre‑trade гейтов, expected return gate, slippage/latency/trap — соответствуют описанию
  - Статус: подтверждено. Функции гейтов в pretrade.py чистые и соответствуют контракту.
- Набор кодов событий/observability
  - Статус: в порядке; `AuroraEventLogger` имеет белый список ALLOWED и использует коды из `observability.codes`. Но формы записей разные у двух логгеров.

Вывод: паспорт в целом корректен и полезен; два существенных уточнения: (1) TRAP cancel_pctl используется; (2) калибратор — isotonic+fallback, не только Platt.

## План рефакторинга

Ниже — реалистичная поэтапная программа. Фазы компактные, каждая даёт самостоятельную ценность и сводит риск.

### Фаза 1 — Структура проекта + README

Цель — чёткие границы слоев, единая терминология, видимая карта проекта.

- Принять целевую структуру (по факту она почти такая; фиксируем и подчистим):
  - api/ — FastAPI сервис: эндпоинты, DI, схемы запросов/ответов.
  - core/
    - aurora/ — доменная логика Aurora: pretrade пайплайн, governance, health, event logging.
      - pretrade.py — атомарные гейты (оставить).
      - pretrade_pipeline.py — новый модуль с явным оркестром гейтов (вынести из service.py).
      - governance.py, health.py — оставить, но развести ответственность (см. Фаза 3).
      - aurora_event_logger.py — единая реализация логгирования событий (см. Фаза 2).
    - scalper/ — сигналы/модели: calibrator, trap, sprt, icp.
  - common/ — кросс‑утилиты и общий конфиг‑лоадер (единый).
  - observability/ — коды событий и схема.
  - risk/ — менеджер рисков.
  - configs/ — yaml-конфиги.
  - docs/ — документация (паспорт, AURORA.md, новая ARCHITECTURE.md если нужно).
  - tests/ — юнит/интеграционные тесты.
  - tools/ — служебные утилиты и CLI.
  - skalp_bot/ — интеграции и раннер (внешний клиент).
- README.md (раздел “Структура и контракты”) — добавить:
  - Карту каталогов с 1‑2 строками описания на каждый.
  - Краткий “Pre‑trade pipeline contract” и порядок гейтов (и как его конфигурировать).
  - “Observability”: где смотреть метрики и события, форматы логов.
  - “Config”: откуда грузится конфиг (единый loader), приоритеты env/yaml.
  - “Failure modes”: что будет при timeout/ошибках гейтов (fail‑open/closed).
  - “How to run tests” (с учётом имеющихся задач VS Code).

Примечание: пока на этом этапе — только документация и разметка структуры; переносы кода начнутся в Фазе 2–3.

### Фаза 2 — Исправления ошибок (быстрые выигрыши)

- API схемы: заменить `Dict[str, Any]` в models.py на строгие модели:
  - AccountInfo, OrderInfo, MarketInfo с нужными полями и валидацией (Pydantic v2).
  - Обновить использование в service.py; добавить negative‑tests на валидацию.
- Клиентский timeout: в aurora_gate.py
  - Поднять `DEFAULT_TIMEOUT_S` до 0.15–0.3 с (реалистично для локалки, с backoff).
  - Сделать конфигурируемым через env/параметр конструктора; задокументировать.
- Конфигурации: единый loader
  - Консолидировать на config.py. В config_loader.py:
    - убрать `sys.exit(2)` в пользу исключений;
    - либо депрекировать файл и перевести потребителей.
  - Чётко описать приоритеты: ENV > файл > дефолты.
- Логгирование событий: одна реализация
  - Принять aurora_event_logger.py как основной. Заменить `common/events.EventEmitter`:
    - либо удалить, либо превратить в тонкую обёртку, которая делегирует в AuroraEventLogger и сохраняет обратную совместимость по сигнатуре.
  - В service.py привести вызовы к единому контракту (`event_code`, `details`, опционально `position_id`, `src`).
- Набор кодов/валидация:
  - Проверить, что все коды событий, которые эмитит сервис/гейты, входят в `AuroraEventLogger.ALLOWED` или `observability.codes`. Добавить недостающие в один источник правды.
- Тесты: покрыть изменения:
  - API схемы (валидные/невалидные payload’ы).
  - Клиентский timeout (параметр/ENV).
  - Эмит событий — корректный формат и idempotency.

### Фаза 3 — Решения проблем (структурные улучшения)

- Извлечь Pre‑trade pipeline из service.py:
  - Создать `core/aurora/pretrade_pipeline.py` с явным списком шагов:
    - latency → health (escalation) → TRAP → expected_return → slippage → risk caps → optional SPRT → spread guard (если есть).
  - Сделать порядок конфигурируемым профилем: `PRETRADE_ORDER_PROFILE` в конфиге.
  - DI: конструировать зависимости (RiskManager, Governance, HealthGuard, Calibrator/TrapWindow) в lifespan и передавать в пайплайн.
- Развести ответственность HealthGuard и Governance:
  - HealthGuard — только измерение/эскалация (WARN/COOL_OFF/HALT), без хранения “внешнего” состояния рынка.
  - Governance — единый источник правды для “halt/resume/arm state” и kill-switch; HealthGuard подаёт сигналы (события), Governance принимает решение и фиксирует состояние. Исключить дублирование флагов.
- ICP:
  - Минимально реализовать `_detect_transition` или явно отключить ICP‑ветку (фича‑флаг) с TODO и тестом, чтобы не было скрытой заглушки.
- Конфиги гейтов и expected return:
  - Документировать и упростить параметры: `risk.pi_min_bps`, `slippage_bps_limit`, `latency_ms_limit`, `spread_bps_limit`.
  - Явный контракт расчёта E[Pi] в калибраторе и источников базовых параметров (fees, slip).
- Observability:
  - Привязать `AuroraEventLogger` к Prometheus Counter (через `set_counter`) в lifespan.
  - Свести форматы логов к единому: `{"ts_ns","run_id","event_code",...,"details"}` для aurora_events.jsonl и отдельные стримы ордеров — как сейчас.

### Фаза 4 — Уборка и документация

- Документация:
  - Обновить README и AURORA.md/Паспорт: актуализировать калибратор (isotonic+fallback), статус ICP, порядок гейтов, конфиги.
- Тесты:
  - Дополнить тесты пайплайна на порядок гейтов и поведение “halt/cool-off”.
- Депрекейшн:
  - Удалить или официально пометить устаревшим events.py и любой код, который больше не используется после консолидации.

## Мини‑контракт для ключевых компонентов

- PretradePipeline
  - Вход: PretradeCheckRequest (типизированные Account/Order/Market)
  - Выход: allow: bool, max_qty: Optional[float], reasons: list[str], cooloff_ms: Optional[int]
  - Ошибки: таймауты/исключения внутри шагов → нормализуются в причины и безопасное решение (fail‑closed для прод).
- AuroraEventLogger
  - Вход: event_code: str ∈ ALLOWED, details: dict
  - Побочные эффекты: запись JSONL, optional prometheus counter, idempotency на ключе (code,cid,oid,ts_ns)

## Приоритеты и риски

- Самые дешёвые и безопасные правки:
  - Типизация API моделей; увеличение таймаута клиента; удаление sys.exit; консолидация логгера.
- Средней стоимостью:
  - Извлечение пайплайна и DI; разведение Health/Governance.
- Более затратные:
  - ICP; полная документация; миграция всех мест логирования.

Оценка: Фаза 2 за 0.5–1 день, Фаза 3 — 1–2 дня, Фаза 4 — 0.5 дня (без неожиданных проблем).

## Рекомендованные next steps

- Утвердить целевую структуру и пункты README (Фаза 1).
- Начать с Фазы 2 (API модели, timeout, конфиг‑лоадер, логгер), параллельно написать короткие тесты.
- После — извлечь пайплайн и развести Health/Governance.
- Обновить Паспорт и README по итогам.

## Короткий статус “качество/сборка”

- Build/Lint/Tests: код не менялся в этой сессии — проверки не запускались.
- Requirements coverage:
  - Проверка паспорта — Done.
  - План рефакторинга: структура+README — Done (описание готово).
  - Исправления ошибок — Спланировано (перечень и способ фиксации).
  - Решения проблем — Спланировано (поэтапная программа).

Пройдуся по “Паспорту проекту” ще раз і звірю, чи наш план охоплює всі згадані файли; для тих, що вже враховані — пропущу, для решти дам статус і що робити (якщо треба).

## Покриття файлів із паспорту

- models.py — В plan (типізувати Account/Order/Market, оновити ендпоінт і тести).
- service.py — В plan (винести PretradePipeline, DI, порядок гейтів у конфіг).
- governance.py — В plan (єдиний SystemState; прибрати дубль станів).
- health.py — В plan (HealthGuard як постачальник сигналів до єдиного стану).
- config.py — В plan (централізувати лоадер, типізований AppConfig).
- events.py — В plan (депрекейт/делегування в AuroraEventLogger).
- config_loader.py — В plan (припинити sys.exit, консолідувати логіку в common/config.py).
- pretrade.py — Не виділений окремим пунктом, але змін не потребує: інтерфейс гейтів зберігаємо, лише переносимо оркестрацію до PretradePipeline; перевіримо сумісність із новими типізованими моделями.
- aurora_event_logger.py — В plan (єдина реалізація логування + метрики).
- calibrator.py — Уточнення внесено в паспорт/план (isotonic + Platt fallback); змін коду не потрібно, лише доки/контракти.
- trap.py — Уточнення внесено (cancel_pctl використовується); змін коду не потрібно. Опційно: задокументувати конфіги cancel_pctl.
- sprt.py — Покрито контекстно (опційний крок у пайплайні); змін коду не вимагається.
- icp.py — В plan (реалізувати _detect_transition або вимкнути фіче‑флагом + тести).
- codes.py — Не окремим пунктом, але враховано в завданні “Вирівняти observability schema”: дій коду не потрібно, лише синхронізація кодів подій під єдиний логгер.
- schema.json — Додано в plan (вирівнювання схеми з форматом AuroraEventLogger).
- aurora_gate.py — В plan (реалістичний таймаут + конфігурованість).
- exch/ccxt_binance.py — Не в plan (паспорт проблем не виявив) — No action.
- env.py — Додано в plan (README про зв’язок з конфігом, пріоритети ENV vs YAML).
- lifecycle_correlation.py — Не в plan (паспорт проблем не виявив) — No action. Опційно: короткий розділ у README “Аналіз життєвого циклу ордерів”.
- reward_manager.py — Не в plan (паспорт проблем не виявив) — No action.
- schemas.py — Додано в plan (узгодити з api/models: база/aliases/тести конверсій).
- aurora_api_lite.py — Додано в plan (позначити dev‑only, вирівняти контракт /pretrade/check, згадка в README).
- uncertainty.py — Не в plan (паспорт проблем не виявив) — No action.

Що ще було у паспорті:
- Паспорт_проекту.md — Додано в plan (оновити неточності: trap.cancel_pctl, calibrator).
- docs/AURORA.md/README — В plan (структура, контракти, observability, config, failure modes).
- tests — Імпліцитно в плані (додати таргетні тести для нових схем/логгера/timeout’ів).

## Висновок про повноту

- Всі файли з “Паспорту” або покриті планом, або позначені як “No action” (бо паспорт не виявив проблем).
- Нові додаткові пункти, яких спочатку не було (і вже додані в план):
  - Узгодити schemas.py з models.py.
  - Оформити aurora_api_lite.py (dev‑only) і вирівняти контракт.
  - Документувати інтеграцію env.py (runner) у README.
  - Вирівняти schema.json під формат `AuroraEventLogger`.
  - Оновити сам “Паспорт” неточностями (TRAP/Calibrator).

Якщо ОК, переходжу до Фази 2 (швидкі правки): типізація API моделей, timeout у aurora_gate, консолідація лоадера конфігів, уніфікація логгера, і одразу пущу таргетні тести.