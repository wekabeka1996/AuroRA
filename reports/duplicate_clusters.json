[
  {
    "source": "jscpd",
    "lines": 33,
    "tokens": 0,
    "code_snippet": ":\n    \"\"\"Targeted tests for dictionary access pattern mutants\"\"\"\n\n    def test_get_or_default_patterns_mutant(self):\n        \"\"\"Kill mutant: 'or' -> 'and' in dict.get() or default patterns\"\"\"\n\n        test_dicts = [\n            {},  # Empty dict\n            {\"key\": \"value\"},  # Has key\n            {\"other_key\": \"value\"},  # Missing key\n        ]\n\n        for d in test_dicts:\n            # Test pattern: d.get('key') or default\n            result = d.get('key') or \"default\"\n            assert result is not None\n\n            # Test pattern: d.get('key') or {}\n            result_dict = d.get('key') or {}\n            assert isinstance(result_dict, (str, dict))\n\n    def test_compound_get_or_patterns_mutant(self):\n        \"\"\"Kill mutant: boolean logic in compound get() or patterns\"\"\"\n\n        test_dicts = [\n            {},  # Missing both\n            {\"guards\": {}},  # Has guards\n            {\"gates\": {}},   # Has gates\n            {\"guards\": {}, \"gates\": {}},  # Has both\n        ]\n\n        for d in test_dicts:\n            # Test pattern: ((d.get('guards') or d.get('gates') or {}))",
    "locations": [
      {
        "file": "tests/unit/api/test_api_survived_mutants.py",
        "start": 240,
        "end": 272
      },
      {
        "file": "tests/unit/core_aurora/test_core_aurora_survived_mutants.py",
        "start": 297,
        "end": 329
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 14,
    "tokens": 0,
    "code_snippet": ")\n\n        # Submit order\n        xai.emit(\"ORDER.SUBMIT\", {\"order\": order.__dict__, \"action\": \"submit\"}, {}, \"Order submission\", 0.9)\n        result = await om.submit_order(order)\n        assert result[\"status\"] == \"accepted\"\n\n        # Configure status for cancelled order\n        om.get_order_status.return_value = {\n            \"status\": \"cancelled\",\n            \"order_id\": result[\"order_id\"]\n        }\n\n        # Wait for FOK evaluation",
    "locations": [
      {
        "file": "tests/integration/oms/test_order_lifecycle.py",
        "start": 306,
        "end": 319
      },
      {
        "file": "tests/integration/oms/test_order_lifecycle.py",
        "start": 252,
        "end": 265
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 12,
    "tokens": 0,
    "code_snippet": ")),\n                fee=float(Decimal(\"0.001\")),\n                fee_asset=\"USDT\",\n                ts_ns=int(time.time() * 1_000_000_000)\n            )\n        ]\n        om.get_order_fills.return_value = mock_fills\n        xai.emit(\"ORDER.SUBMIT\", {\"order\": order.__dict__, \"action\": \"submit\"}, {}, \"Order submission\", 0.9)\n        result = await om.submit_order(order)\n        assert result[\"status\"] == \"accepted\"\n\n        # Wait for fills",
    "locations": [
      {
        "file": "tests/integration/oms/test_order_lifecycle.py",
        "start": 508,
        "end": 519
      },
      {
        "file": "tests/integration/oms/test_order_lifecycle.py",
        "start": 182,
        "end": 193
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 6,
    "tokens": 0,
    "code_snippet": "def request(self, method: str, url: str, *, params: Optional[Mapping[str, object]] = None,\r\n                headers: Optional[Mapping[str, str]] = None, json: Optional[object] = None) -> Mapping[str, object]:\r\n        ...\r\n\r\n\r\n# --------------------------- Abstract Exchange ---------------------------",
    "locations": [
      {
        "file": "core/execution/exchange/common.py",
        "start": 234,
        "end": 239
      },
      {
        "file": "core/execution/exchange/unified.py",
        "start": 128,
        "end": 133
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 8,
    "tokens": 0,
    "code_snippet": "make_idempotency_key(\"oid\", {\r\n                    \"s\": clean.symbol,\r\n                    \"sd\": clean.side.value,\r\n                    \"t\": clean.type.value,\r\n                    \"q\": clean.quantity,\r\n                    \"p\": clean.price if clean.price is not None else \"\",\r\n                })\r\n            )",
    "locations": [
      {
        "file": "core/execution/exchange/common.py",
        "start": 283,
        "end": 290
      },
      {
        "file": "core/execution/exchange/gate.py",
        "start": 106,
        "end": 113
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 8,
    "tokens": 0,
    "code_snippet": "coid = clean.client_order_id or make_idempotency_key(\"oid\", {\r\n            \"s\": clean.symbol,\r\n            \"sd\": clean.side.value,\r\n            \"t\": clean.type.value,\r\n            \"q\": clean.quantity,\r\n            \"p\": clean.price if clean.price is not None else \"\",\r\n        })\r\n        ts",
    "locations": [
      {
        "file": "core/execution/exchange/binance.py",
        "start": 134,
        "end": 141
      },
      {
        "file": "core/execution/exchange/gate.py",
        "start": 106,
        "end": 113
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 9,
    "tokens": 0,
    "code_snippet": ",\r\n            cumm_quote_cost=cumm_quote_cost,\r\n            fills=fills,\r\n            ts_ns=int(self.server_time_ns_hint()),\r\n            raw=res,\r\n        )\r\n\r\n    def cancel_order(self, symbol: str, order_id: str | None = None, client_order_id: str | None = None) -> Mapping[str, object]:\r\n        ts",
    "locations": [
      {
        "file": "core/execution/exchange/binance.py",
        "start": 181,
        "end": 189
      },
      {
        "file": "core/execution/exchange/gate.py",
        "start": 145,
        "end": 153
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 12,
    "tokens": 0,
    "code_snippet": "(self, symbol: str, order_id: str | None = None, client_order_id: str | None = None) -> Mapping[str, object]:\r\n        ts = self.get_server_time_ms()\r\n        params = {\r\n            \"symbol\": self.normalize_symbol(symbol),\r\n            \"timestamp\": ts,\r\n            \"recvWindow\": 5000,\r\n        }\r\n        if order_id:\r\n            params[\"orderId\"] = order_id\r\n        if client_order_id:\r\n            params[\"origClientOrderId\"] = client_order_id\r\n        return cast(Dict[str, Any], self._signed_request(\"GET\"",
    "locations": [
      {
        "file": "core/execution/exchange/binance.py",
        "start": 201,
        "end": 212
      },
      {
        "file": "core/execution/exchange/binance.py",
        "start": 188,
        "end": 199
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 19,
    "tokens": 0,
    "code_snippet": ",\r\n        target_qty=1.0,\r\n        fills=fills,\r\n        arrival_ts_ns=1000000000,\r\n        decision_ts_ns=1000000000,\r\n        arrival_price=100.0,\r\n        arrival_spread_bps=2.0,\r\n        latency_ms=10.0\r\n    )\r\n    \r\n    market_data = {\r\n        'mid_price': 100.0,\r\n        'micro_price': 100.0,\r\n        'slip_bps': 5.0\r\n    }\r\n    \r\n    metrics = analyzer.analyze_order(execution, market_data)\r\n    \r\n    # Check identity using legacy-positive decomposition",
    "locations": [
      {
        "file": "tests/unit/test_tca_identity.py",
        "start": 68,
        "end": 86
      },
      {
        "file": "tests/unit/test_tca_identity.py",
        "start": 16,
        "end": 34
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 23,
    "tokens": 0,
    "code_snippet": "components_sum = (\r\n        metrics.raw_edge_bps +\r\n        metrics.fees_bps +\r\n        metrics.spread_cost_bps +\r\n        metrics.latency_slippage_bps +\r\n        metrics.adverse_selection_bps +\r\n        metrics.temporary_impact_bps +\r\n        metrics.rebate_bps\r\n    )\r\n\r\n    assert abs(metrics.implementation_shortfall_bps - components_sum) <= 1e-6\r\n    \r\n    # Check sign conventions\r\n    assert metrics.fees_bps <= 0\r\n    assert metrics.slippage_in_bps <= 0  # Maker profile -> 0\r\n    assert metrics.slippage_out_bps <= 0\r\n    assert metrics.adverse_bps <= 0\r\n    assert metrics.latency_bps <= 0\r\n    assert metrics.impact_bps <= 0\r\n    assert metrics.rebate_bps >= 0\r\n\r\n\r\ndef test_maker_profile_with_rebate",
    "locations": [
      {
        "file": "tests/unit/test_tca_identity.py",
        "start": 87,
        "end": 109
      },
      {
        "file": "tests/unit/test_tca_identity.py",
        "start": 35,
        "end": 57
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 16,
    "tokens": 0,
    "code_snippet": ",\r\n        symbol=\"BTCUSDT\",\r\n        side=\"BUY\",\r\n        target_qty=1.0,\r\n        fills=fills,\r\n        arrival_ts_ns=1000000000,\r\n        decision_ts_ns=1000000000,\r\n        arrival_price=100.0,\r\n        arrival_spread_bps=2.0,\r\n        latency_ms=10.0\r\n    )\r\n    \r\n    market_data = {\r\n        'mid_price': 100.0,\r\n        'micro_price': 100.0,\r\n        'slip_bps': 2.0",
    "locations": [
      {
        "file": "tests/unit/test_tca_identity.py",
        "start": 119,
        "end": 134
      },
      {
        "file": "tests/unit/test_tca_identity.py",
        "start": 14,
        "end": 29
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 21,
    "tokens": 0,
    "code_snippet": ",\r\n        symbol=\"BTCUSDT\",\r\n        side=\"BUY\",\r\n        target_qty=1.0,\r\n        fills=fills,\r\n        arrival_ts_ns=1000000000,\r\n        decision_ts_ns=1000000000,\r\n        arrival_price=100.0,\r\n        arrival_spread_bps=2.0,\r\n        latency_ms=10.0\r\n    )\r\n    \r\n    market_data = {\r\n        'mid_price': 100.0,\r\n        'micro_price': 100.0,\r\n        'slip_bps': 5.0\r\n    }\r\n    \r\n    metrics = analyzer.analyze_order(execution, market_data)\r\n    \r\n    # Taker profile",
    "locations": [
      {
        "file": "tests/unit/test_tca_identity.py",
        "start": 172,
        "end": 192
      },
      {
        "file": "tests/unit/test_tca_identity.py",
        "start": 14,
        "end": 34
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 19,
    "tokens": 0,
    "code_snippet": ",\r\n        symbol=\"BTCUSDT\",\r\n        side=\"BUY\",\r\n        target_qty=1.0,\r\n        fills=fills,\r\n        arrival_ts_ns=1000000000,\r\n        decision_ts_ns=1000000000,\r\n        arrival_price=100.0,\r\n        arrival_spread_bps=2.0,\r\n        latency_ms=10.0\r\n    )\r\n    \r\n    market_data = {\r\n        'mid_price': 100.0,\r\n        'micro_price': 100.0,\r\n        'slip_bps': 5.0\r\n    }\r\n    \r\n    # This should raise ValueError due to sign gate violation",
    "locations": [
      {
        "file": "tests/unit/test_tca_identity.py",
        "start": 224,
        "end": 242
      },
      {
        "file": "tests/unit/test_tca_identity.py",
        "start": 14,
        "end": 32
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 15,
    "tokens": 0,
    "code_snippet": ",\n            symbol='BTCUSDT',\n            side='BUY',\n            target_qty=100.0,\n            fills=fills,\n            arrival_ts_ns=int(time.time_ns()),\n            decision_ts_ns=int(time.time_ns()) - 1000000,\n            arrival_price=100.0,\n            arrival_spread_bps=10.0,\n            latency_ms=1.0\n        )\n\n        metrics = analyzer.analyze_order(execution, sample_market_data)\n\n        # Total fees should be sum of all fill fees",
    "locations": [
      {
        "file": "tests/unit/test_tca_analyzer.py",
        "start": 375,
        "end": 389
      },
      {
        "file": "tests/unit/test_tca_analyzer.py",
        "start": 173,
        "end": 187
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 13,
    "tokens": 0,
    "code_snippet": ",\n            symbol='BTCUSDT',\n            side='BUY',\n            target_qty=100.0,\n            fills=fills,\n            arrival_ts_ns=int(time.time_ns()),\n            decision_ts_ns=int(time.time_ns()) - 1000000,\n            arrival_price=100.0,\n            arrival_spread_bps=10.0,\n            latency_ms=1.0\n        )\n\n        # Mock market data with different mid vs micro",
    "locations": [
      {
        "file": "tests/unit/test_tca_analyzer.py",
        "start": 507,
        "end": 519
      },
      {
        "file": "tests/unit/test_tca_analyzer.py",
        "start": 173,
        "end": 185
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 15,
    "tokens": 0,
    "code_snippet": ",\n            symbol='BTCUSDT',\n            side='BUY',\n            target_qty=100.0,\n            fills=fills,\n            arrival_ts_ns=int(time.time_ns()),\n            decision_ts_ns=int(time.time_ns()) - 1000000,\n            arrival_price=100.0,\n            arrival_spread_bps=10.0,\n            latency_ms=1.0\n        )\n\n        metrics = analyzer.analyze_order(execution, sample_market_data)\n\n        # Should calculate average queue position",
    "locations": [
      {
        "file": "tests/unit/test_tca_analyzer.py",
        "start": 601,
        "end": 615
      },
      {
        "file": "tests/unit/test_tca_analyzer.py",
        "start": 173,
        "end": 187
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 9,
    "tokens": 0,
    "code_snippet": "from core.execution.sim_local_sink import SimLocalSink\n\n\ndef make_market(bid=99.0, ask=101.0, bid_qty=10.0, ask_qty=10.0):\n    return {\n        'best_bid': bid,\n        'best_ask': ask,\n        'liquidity': {'bid': bid_qty, 'ask': ask_qty},\n        'depth'",
    "locations": [
      {
        "file": "tests/unit/test_sim_local_sink_coverage.py",
        "start": 10,
        "end": 18
      },
      {
        "file": "tests/unit/test_sim_local_tca_and_determinism.py",
        "start": 3,
        "end": 11
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 14,
    "tokens": 0,
    "code_snippet": "from core.execution.sim_local_sink import SimLocalSink\r\n\r\n\r\ndef make_market(bid=99.0, ask=101.0, bid_qty=10.0, ask_qty=10.0):\r\n    return {\r\n        'best_bid': bid,\r\n        'best_ask': ask,\r\n        'liquidity': {'bid': bid_qty, 'ask': ask_qty},\r\n        'depth': {'at_price': {}, 'levels_sum': {}},\r\n        'traded_since_last': {},\r\n    }\r\n\r\n\r\ndef",
    "locations": [
      {
        "file": "tests/unit/test_sim_local_basic.py",
        "start": 5,
        "end": 18
      },
      {
        "file": "tests/unit/test_sim_local_tca_and_determinism.py",
        "start": 3,
        "end": 23
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 22,
    "tokens": 0,
    "code_snippet": "@patch('core.env_config.load_binance_cfg')\n        def test_inner(mock_load_cfg):\n            mock_cfg = Mock()\n            mock_cfg.base_url = \"https://api.binance.com\"\n            mock_load_cfg.return_value = mock_cfg\n\n            broker = ShadowBroker(symbols=[\"BTCUSDT\"])\n\n            # Mock filters\n            broker.filters = {\n                \"BTCUSDT\": BinanceFilters(\n                    lot_size_min_qty=Decimal(\"0.001\"),\n                    lot_size_max_qty=Decimal(\"1000\"),\n                    lot_size_step_size=Decimal(\"0.001\"),\n                    price_filter_min_price=Decimal(\"0.01\"),\n                    price_filter_max_price=Decimal(\"100000\"),\n                    price_filter_tick_size=Decimal(\"0.01\"),\n                    min_notional=Decimal(\"10.0\")\n                )\n            }\n\n            # Quantity below minimum",
    "locations": [
      {
        "file": "tests/unit/test_shadow_broker_old.py",
        "start": 83,
        "end": 104
      },
      {
        "file": "tests/unit/test_shadow_broker_old.py",
        "start": 39,
        "end": 60
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 22,
    "tokens": 0,
    "code_snippet": "@patch('core.env_config.load_binance_cfg')\n        def test_inner(mock_load_cfg):\n            mock_cfg = Mock()\n            mock_cfg.base_url = \"https://api.binance.com\"\n            mock_load_cfg.return_value = mock_cfg\n\n            broker = ShadowBroker(symbols=[\"BTCUSDT\"])\n\n            # Mock filters\n            broker.filters = {\n                \"BTCUSDT\": BinanceFilters(\n                    lot_size_min_qty=Decimal(\"0.001\"),\n                    lot_size_max_qty=Decimal(\"1000\"),\n                    lot_size_step_size=Decimal(\"0.001\"),\n                    price_filter_min_price=Decimal(\"0.01\"),\n                    price_filter_max_price=Decimal(\"100000\"),\n                    price_filter_tick_size=Decimal(\"0.01\"),\n                    min_notional=Decimal(\"10.0\")\n                )\n            }\n\n            # Quantity above maximum",
    "locations": [
      {
        "file": "tests/unit/test_shadow_broker_old.py",
        "start": 115,
        "end": 136
      },
      {
        "file": "tests/unit/test_shadow_broker_old.py",
        "start": 39,
        "end": 60
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 21,
    "tokens": 0,
    "code_snippet": "@patch('core.env_config.load_binance_cfg')\n        @patch.object(ShadowBroker, '_fetch_exchange_info')\n        def test_inner(mock_fetch, mock_load_cfg):\n            mock_cfg = Mock()\n            mock_cfg.base_url = \"https://api.binance.com\"\n            mock_load_cfg.return_value = mock_cfg\n            \n            broker = ShadowBroker(symbols=[\"BTCUSDT\"])\n            \n            # Mock filters\n            broker.filters = {\n                \"BTCUSDT\": BinanceFilters(\n                    lot_size_min_qty=Decimal(\"0.001\"),\n                    lot_size_max_qty=Decimal(\"1000\"),\n                    lot_size_step_size=Decimal(\"0.001\"),\n                    price_filter_min_price=Decimal(\"0.01\"),\n                    price_filter_max_price=Decimal(\"100000\"),\n                    price_filter_tick_size=Decimal(\"0.01\"),\n                    min_notional=Decimal(\"10.0\")\n                )\n            }            # Valid price",
    "locations": [
      {
        "file": "tests/unit/test_shadow_broker_old.py",
        "start": 178,
        "end": 198
      },
      {
        "file": "tests/unit/test_shadow_broker_old.py",
        "start": 147,
        "end": 60
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 22,
    "tokens": 0,
    "code_snippet": "@patch('core.env_config.load_binance_cfg')\n        def test_inner(mock_load_cfg):\n            mock_cfg = Mock()\n            mock_cfg.base_url = \"https://api.binance.com\"\n            mock_load_cfg.return_value = mock_cfg\n\n            broker = ShadowBroker(symbols=[\"BTCUSDT\"])\n\n            # Mock filters\n            broker.filters = {\n                \"BTCUSDT\": BinanceFilters(\n                    lot_size_min_qty=Decimal(\"0.001\"),\n                    lot_size_max_qty=Decimal(\"1000\"),\n                    lot_size_step_size=Decimal(\"0.001\"),\n                    price_filter_min_price=Decimal(\"0.01\"),\n                    price_filter_max_price=Decimal(\"100000\"),\n                    price_filter_tick_size=Decimal(\"0.01\"),\n                    min_notional=Decimal(\"10.0\")\n                )\n            }\n\n            # Price below minimum",
    "locations": [
      {
        "file": "tests/unit/test_shadow_broker_old.py",
        "start": 221,
        "end": 242
      },
      {
        "file": "tests/unit/test_shadow_broker_old.py",
        "start": 39,
        "end": 60
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 22,
    "tokens": 0,
    "code_snippet": "@patch('core.env_config.load_binance_cfg')\n        def test_inner(mock_load_cfg):\n            mock_cfg = Mock()\n            mock_cfg.base_url = \"https://api.binance.com\"\n            mock_load_cfg.return_value = mock_cfg\n\n            broker = ShadowBroker(symbols=[\"BTCUSDT\"])\n\n            # Mock filters\n            broker.filters = {\n                \"BTCUSDT\": BinanceFilters(\n                    lot_size_min_qty=Decimal(\"0.001\"),\n                    lot_size_max_qty=Decimal(\"1000\"),\n                    lot_size_step_size=Decimal(\"0.001\"),\n                    price_filter_min_price=Decimal(\"0.01\"),\n                    price_filter_max_price=Decimal(\"100000\"),\n                    price_filter_tick_size=Decimal(\"0.01\"),\n                    min_notional=Decimal(\"10.0\")\n                )\n            }\n\n            # Price above maximum",
    "locations": [
      {
        "file": "tests/unit/test_shadow_broker_old.py",
        "start": 253,
        "end": 274
      },
      {
        "file": "tests/unit/test_shadow_broker_old.py",
        "start": 39,
        "end": 60
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 17,
    "tokens": 0,
    "code_snippet": "@patch('core.env_config.load_binance_cfg')\n        @patch.object(ShadowBroker, '_fetch_exchange_info')\n        def test_inner(mock_fetch, mock_load_cfg):\n            mock_cfg = Mock()\n            mock_cfg.base_url = \"https://api.binance.com\"\n            mock_load_cfg.return_value = mock_cfg\n            \n            broker = ShadowBroker(symbols=[\"BTCUSDT\"])\n            \n            # Mock filters\n            broker.filters = {\n                \"BTCUSDT\": BinanceFilters(\n                    lot_size_min_qty=Decimal(\"0.001\"),\n                    lot_size_max_qty=Decimal(\"1000\"),\n                    lot_size_step_size=Decimal(\"0.001\"),\n                    price_filter_min_price=Decimal(\"0.01\"),\n                    price_filter_max_price=Decimal(\"49.99\"",
    "locations": [
      {
        "file": "tests/unit/test_shadow_broker_old.py",
        "start": 285,
        "end": 301
      },
      {
        "file": "tests/unit/test_shadow_broker_old.py",
        "start": 147,
        "end": 54
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 22,
    "tokens": 0,
    "code_snippet": "@patch('core.env_config.load_binance_cfg')\n        def test_inner(mock_load_cfg):\n            mock_cfg = Mock()\n            mock_cfg.base_url = \"https://api.binance.com\"\n            mock_load_cfg.return_value = mock_cfg\n\n            broker = ShadowBroker(symbols=[\"BTCUSDT\"])\n\n            # Mock filters\n            broker.filters = {\n                \"BTCUSDT\": BinanceFilters(\n                    lot_size_min_qty=Decimal(\"0.001\"),\n                    lot_size_max_qty=Decimal(\"1000\"),\n                    lot_size_step_size=Decimal(\"0.001\"),\n                    price_filter_min_price=Decimal(\"0.01\"),\n                    price_filter_max_price=Decimal(\"100000\"),\n                    price_filter_tick_size=Decimal(\"0.01\"),\n                    min_notional=Decimal(\"10.0\")\n                )\n            }\n\n            # Valid notional (1.0 * 15.0 = 15.0 > 10.0)",
    "locations": [
      {
        "file": "tests/unit/test_shadow_broker_old.py",
        "start": 316,
        "end": 337
      },
      {
        "file": "tests/unit/test_shadow_broker_old.py",
        "start": 39,
        "end": 60
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 22,
    "tokens": 0,
    "code_snippet": "@patch('core.env_config.load_binance_cfg')\n        def test_inner(mock_load_cfg):\n            mock_cfg = Mock()\n            mock_cfg.base_url = \"https://api.binance.com\"\n            mock_load_cfg.return_value = mock_cfg\n\n            broker = ShadowBroker(symbols=[\"BTCUSDT\"])\n\n            # Mock filters\n            broker.filters = {\n                \"BTCUSDT\": BinanceFilters(\n                    lot_size_min_qty=Decimal(\"0.001\"),\n                    lot_size_max_qty=Decimal(\"1000\"),\n                    lot_size_step_size=Decimal(\"0.001\"),\n                    price_filter_min_price=Decimal(\"0.01\"),\n                    price_filter_max_price=Decimal(\"100000\"),\n                    price_filter_tick_size=Decimal(\"0.01\"),\n                    min_notional=Decimal(\"10.0\")\n                )\n            }\n\n            # Notional too small (0.5 * 15.0 = 7.5 < 10.0)",
    "locations": [
      {
        "file": "tests/unit/test_shadow_broker_old.py",
        "start": 348,
        "end": 369
      },
      {
        "file": "tests/unit/test_shadow_broker_old.py",
        "start": 39,
        "end": 60
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 18,
    "tokens": 0,
    "code_snippet": "mock_load_cfg.return_value = mock_cfg\n\n        broker = ShadowBroker(symbols=[\"BTCUSDT\"])\n\n        # Mock filters\n        broker.filters = {\n            \"BTCUSDT\": BinanceFilters(\n                lot_size_min_qty=Decimal(\"0.001\"),\n                lot_size_max_qty=Decimal(\"1000\"),\n                lot_size_step_size=Decimal(\"0.001\"),\n                price_filter_min_price=Decimal(\"0.01\"),\n                price_filter_max_price=Decimal(\"100000\"),\n                price_filter_tick_size=Decimal(\"0.01\"),\n                min_notional=Decimal(\"10.0\")\n            )\n        }\n\n        # Use validate_and_round_order instead of non-existent validate_order",
    "locations": [
      {
        "file": "tests/unit/test_shadow_broker_old.py",
        "start": 517,
        "end": 534
      },
      {
        "file": "tests/unit/test_shadow_broker_old.py",
        "start": 43,
        "end": 60
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 11,
    "tokens": 0,
    "code_snippet": "),\n                price_filter_min_price=Decimal(\"0.01\"),\n                price_filter_max_price=Decimal(\"100000\"),\n                price_filter_tick_size=Decimal(\"0.01\"),\n                min_notional=Decimal(\"10.0\")\n            )\n        }\n\n        # Use validate_and_round_order instead of non-existent validate_order\n        is_valid, message, rounded_qty, rounded_price = broker.validate_and_round_order(\n            \"BTCUSDT\", \"BUY\", \"LIMIT\", 0.0005",
    "locations": [
      {
        "file": "tests/unit/test_shadow_broker_old.py",
        "start": 526,
        "end": 536
      },
      {
        "file": "tests/unit/test_shadow_broker_old.py",
        "start": 494,
        "end": 504
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 21,
    "tokens": 0,
    "code_snippet": "= \"https://api.binance.com\"\n        mock_cfg.api_key = \"test_key\"\n        mock_cfg.api_secret = \"test_secret\"\n        mock_load_cfg.return_value = mock_cfg\n        \n        broker = ShadowBroker(symbols=[\"BTCUSDT\"])\n        \n        # Mock filters\n        broker.filters = {\n            \"BTCUSDT\": BinanceFilters(\n                lot_size_min_qty=Decimal(\"0.001\"),\n                lot_size_max_qty=Decimal(\"1000\"),\n                lot_size_step_size=Decimal(\"0.001\"),\n                price_filter_min_price=Decimal(\"0.01\"),\n                price_filter_max_price=Decimal(\"100000\"),\n                price_filter_tick_size=Decimal(\"0.01\"),\n                min_notional=Decimal(\"10.0\")\n            )\n        }\n        \n        order",
    "locations": [
      {
        "file": "tests/unit/test_shadow_broker_old.py",
        "start": 547,
        "end": 567
      },
      {
        "file": "tests/unit/test_shadow_broker_old.py",
        "start": 514,
        "end": 60
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 13,
    "tokens": 0,
    "code_snippet": ",\n            \"type\": \"MARKET\",\n            \"quantity\": \"0.001\"\n        }\n        \n        # Use submit_order instead of non-existent simulate_fill\n        result = broker.submit_order(\n            order[\"symbol\"], order[\"side\"], order[\"type\"], \n            float(order[\"quantity\"])\n        )\n        \n        assert result[\"symbol\"] == \"BTCUSDT\"\n        assert result[\"side\"] == \"SELL\"",
    "locations": [
      {
        "file": "tests/unit/test_shadow_broker_old.py",
        "start": 627,
        "end": 639
      },
      {
        "file": "tests/unit/test_shadow_broker_old.py",
        "start": 597,
        "end": 609
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 14,
    "tokens": 0,
    "code_snippet": "mock_cfg = Mock()\n        mock_cfg.spot_url = \"https://api.binance.com\"\n        mock_cfg.api_key = \"test_key\"\n        mock_cfg.api_secret = \"test_secret\"\n        mock_load_cfg.return_value = mock_cfg\n        \n        broker = ShadowBroker(symbols=[\"BTCUSDT\"])\n        \n        order = {\n            \"symbol\": \"BTCUSDT\",\n            \"side\": \"BUY\",\n            \"type\": \"LIMIT\",\n            \"quantity\": \"0.001\",\n            \"price\": \"50000.00\"",
    "locations": [
      {
        "file": "tests/unit/test_shadow_broker_old.py",
        "start": 679,
        "end": 692
      },
      {
        "file": "tests/unit/test_shadow_broker_old.py",
        "start": 647,
        "end": 660
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 22,
    "tokens": 0,
    "code_snippet": "def test_binance_filters_creation(self):\n        \"\"\"Test valid BinanceFilters creation.\"\"\"\n        filters = BinanceFilters(\n            lot_size_min_qty=Decimal(\"0.00001\"),\n            lot_size_max_qty=Decimal(\"100000\"),\n            lot_size_step_size=Decimal(\"0.00001\"),\n            price_filter_min_price=Decimal(\"0.01\"),\n            price_filter_max_price=Decimal(\"1000000\"),\n            price_filter_tick_size=Decimal(\"0.01\"),\n            min_notional=Decimal(\"10.0\")\n        )\n        \n        assert filters.lot_size_min_qty == Decimal(\"0.00001\")\n        assert filters.lot_size_max_qty == Decimal(\"100000\")\n        assert filters.lot_size_step_size == Decimal(\"0.00001\")\n        assert filters.price_filter_min_price == Decimal(\"0.01\")\n        assert filters.price_filter_max_price == Decimal(\"1000000\")\n        assert filters.price_filter_tick_size == Decimal(\"0.01\")\n        assert filters.min_notional == Decimal(\"10.0\")\n\n\nclass",
    "locations": [
      {
        "file": "tests/unit/test_shadow_broker.py",
        "start": 15,
        "end": 36
      },
      {
        "file": "tests/unit/test_shadow_broker_old.py",
        "start": 17,
        "end": 37
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 13,
    "tokens": 0,
    "code_snippet": "mock_cfg = Mock()\n        mock_cfg.base_url = \"https://api.binance.com\"\n        mock_cfg.api_key = \"test_key\"\n        mock_cfg.api_secret = \"test_secret\"\n        mock_load_cfg.return_value = mock_cfg\n        \n        # Mock exchange info response\n        mock_response = Mock()\n        mock_response.ok = True\n        mock_response.json.return_value = {\"symbols\": []}\n        mock_get.return_value = mock_response\n        \n        broker = ShadowBroker(symbols=[\"ETHUSDT\"",
    "locations": [
      {
        "file": "tests/unit/test_shadow_broker.py",
        "start": 65,
        "end": 77
      },
      {
        "file": "tests/unit/test_shadow_broker.py",
        "start": 43,
        "end": 55
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 28,
    "tokens": 0,
    "code_snippet": "mock_response.json.return_value = {\n            \"symbols\": [{\n                \"symbol\": \"BTCUSDT\",\n                \"status\": \"TRADING\",\n                \"filters\": [\n                    {\n                        \"filterType\": \"LOT_SIZE\",\n                        \"minQty\": \"0.00001000\",\n                        \"maxQty\": \"9000.00000000\",\n                        \"stepSize\": \"0.00001000\"\n                    },\n                    {\n                        \"filterType\": \"PRICE_FILTER\",\n                        \"minPrice\": \"0.01000000\",\n                        \"maxPrice\": \"1000000.00000000\",\n                        \"tickSize\": \"0.01000000\"\n                    },\n                    {\n                        \"filterType\": \"MIN_NOTIONAL\",\n                        \"minNotional\": \"10.00000000\"\n                    }\n                ]\n            }]\n        }\n        mock_get.return_value = mock_response\n        \n        broker = ShadowBroker(symbols=[\"BTCUSDT\"])\n        filters",
    "locations": [
      {
        "file": "tests/unit/test_shadow_broker.py",
        "start": 94,
        "end": 121
      },
      {
        "file": "tests/unit/test_shadow_broker_old.py",
        "start": 412,
        "end": 440
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 15,
    "tokens": 0,
    "code_snippet": "mock_cfg = Mock()\n        mock_cfg.base_url = \"https://api.binance.com\"\n        mock_load_cfg.return_value = mock_cfg\n        \n        # Mock exchange info response\n        mock_response = Mock()\n        mock_response.ok = True\n        mock_response.json.return_value = {\"symbols\": []}\n        mock_get.return_value = mock_response\n        \n        broker = ShadowBroker(symbols=[\"BTCUSDT\"])\n        \n        # Set up test filters manually\n        broker.filters[\"BTCUSDT\"] = BinanceFilters(\n            lot_size_min_qty=Decimal(\"0.001\"",
    "locations": [
      {
        "file": "tests/unit/test_shadow_broker.py",
        "start": 169,
        "end": 183
      },
      {
        "file": "tests/unit/test_shadow_broker.py",
        "start": 133,
        "end": 147
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 11,
    "tokens": 0,
    "code_snippet": "BinanceFilters(\n            lot_size_min_qty=Decimal(\"0.001\"),\n            lot_size_max_qty=Decimal(\"1000\"),\n            lot_size_step_size=Decimal(\"0.001\"),\n            price_filter_min_price=Decimal(\"0.01\"),\n            price_filter_max_price=Decimal(\"100000\"),\n            price_filter_tick_size=Decimal(\"0.01\"),\n            min_notional=Decimal(\"10.0\")\n        )\n        \n        # Test quantity too small",
    "locations": [
      {
        "file": "tests/unit/test_shadow_broker.py",
        "start": 182,
        "end": 192
      },
      {
        "file": "tests/unit/test_shadow_broker_old.py",
        "start": 49,
        "end": 58
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 24,
    "tokens": 0,
    "code_snippet": "mock_cfg = Mock()\n        mock_cfg.base_url = \"https://api.binance.com\"\n        mock_load_cfg.return_value = mock_cfg\n        \n        # Mock exchange info response\n        mock_response = Mock()\n        mock_response.ok = True\n        mock_response.json.return_value = {\"symbols\": []}\n        mock_get.return_value = mock_response\n        \n        broker = ShadowBroker(symbols=[\"BTCUSDT\"])\n        \n        # Set up test filters manually\n        broker.filters[\"BTCUSDT\"] = BinanceFilters(\n            lot_size_min_qty=Decimal(\"0.001\"),\n            lot_size_max_qty=Decimal(\"1000\"),\n            lot_size_step_size=Decimal(\"0.001\"),\n            price_filter_min_price=Decimal(\"0.01\"),\n            price_filter_max_price=Decimal(\"100000\"),\n            price_filter_tick_size=Decimal(\"0.01\"),\n            min_notional=Decimal(\"10.0\")\n        )\n        \n        # Test insufficient notional (0.001 * 1.0 = 0.001 < 10.0)",
    "locations": [
      {
        "file": "tests/unit/test_shadow_broker.py",
        "start": 205,
        "end": 228
      },
      {
        "file": "tests/unit/test_shadow_broker.py",
        "start": 133,
        "end": 58
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 11,
    "tokens": 0,
    "code_snippet": "mock_cfg = Mock()\n        mock_cfg.base_url = \"https://api.binance.com\"\n        mock_load_cfg.return_value = mock_cfg\n        \n        # Mock exchange info response\n        mock_response = Mock()\n        mock_response.ok = True\n        mock_response.json.return_value = {\"symbols\": []}\n        mock_get.return_value = mock_response\n        \n        broker = ShadowBroker(symbols=[\"BTCUSDT\"],",
    "locations": [
      {
        "file": "tests/unit/test_shadow_broker.py",
        "start": 240,
        "end": 250
      },
      {
        "file": "tests/unit/test_shadow_broker.py",
        "start": 133,
        "end": 143
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 14,
    "tokens": 0,
    "code_snippet": ")\n        \n        # Set up test filters manually\n        broker.filters[\"BTCUSDT\"] = BinanceFilters(\n            lot_size_min_qty=Decimal(\"0.001\"),\n            lot_size_max_qty=Decimal(\"1000\"),\n            lot_size_step_size=Decimal(\"0.001\"),\n            price_filter_min_price=Decimal(\"0.01\"),\n            price_filter_max_price=Decimal(\"100000\"),\n            price_filter_tick_size=Decimal(\"0.01\"),\n            min_notional=Decimal(\"10.0\")\n        )\n        \n        result",
    "locations": [
      {
        "file": "tests/unit/test_shadow_broker.py",
        "start": 250,
        "end": 263
      },
      {
        "file": "tests/unit/test_shadow_broker.py",
        "start": 179,
        "end": 58
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 24,
    "tokens": 0,
    "code_snippet": "mock_cfg = Mock()\n        mock_cfg.base_url = \"https://api.binance.com\"\n        mock_load_cfg.return_value = mock_cfg\n        \n        # Mock exchange info response\n        mock_response = Mock()\n        mock_response.ok = True\n        mock_response.json.return_value = {\"symbols\": []}\n        mock_get.return_value = mock_response\n        \n        broker = ShadowBroker(symbols=[\"BTCUSDT\"])\n        \n        # Set up test filters manually\n        broker.filters[\"BTCUSDT\"] = BinanceFilters(\n            lot_size_min_qty=Decimal(\"0.001\"),\n            lot_size_max_qty=Decimal(\"1000\"),\n            lot_size_step_size=Decimal(\"0.001\"),\n            price_filter_min_price=Decimal(\"0.01\"),\n            price_filter_max_price=Decimal(\"100000\"),\n            price_filter_tick_size=Decimal(\"0.01\"),\n            min_notional=Decimal(\"10.0\")\n        )\n        \n        result = broker.submit_order(\"BTCUSDT\", \"BUY\", \"LIMIT\"",
    "locations": [
      {
        "file": "tests/unit/test_shadow_broker.py",
        "start": 277,
        "end": 300
      },
      {
        "file": "tests/unit/test_shadow_broker.py",
        "start": 133,
        "end": 263
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 24,
    "tokens": 0,
    "code_snippet": "mock_cfg = Mock()\n        mock_cfg.base_url = \"https://api.binance.com\"\n        mock_load_cfg.return_value = mock_cfg\n        \n        # Mock exchange info response\n        mock_response = Mock()\n        mock_response.ok = True\n        mock_response.json.return_value = {\"symbols\": []}\n        mock_get.return_value = mock_response\n        \n        broker = ShadowBroker(symbols=[\"BTCUSDT\"])\n        \n        # Set up test filters manually\n        broker.filters[\"BTCUSDT\"] = BinanceFilters(\n            lot_size_min_qty=Decimal(\"0.001\"),\n            lot_size_max_qty=Decimal(\"1000\"),\n            lot_size_step_size=Decimal(\"0.001\"),\n            price_filter_min_price=Decimal(\"0.01\"),\n            price_filter_max_price=Decimal(\"100000\"),\n            price_filter_tick_size=Decimal(\"0.01\"),\n            min_notional=Decimal(\"10.0\")\n        )\n        \n        # Submit order with invalid quantity",
    "locations": [
      {
        "file": "tests/unit/test_shadow_broker.py",
        "start": 313,
        "end": 336
      },
      {
        "file": "tests/unit/test_shadow_broker.py",
        "start": 133,
        "end": 58
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 23,
    "tokens": 0,
    "code_snippet": ")\n    def test_shadow_broker_initialization(self, mock_load_cfg, mock_get):\n        \"\"\"Test ShadowBroker initialization with proper config loading.\"\"\"\n        mock_cfg = Mock()\n        mock_cfg.base_url = \"https://api.binance.com\"\n        mock_cfg.api_key = \"test_key\"\n        mock_cfg.api_secret = \"test_secret\"\n        mock_load_cfg.return_value = mock_cfg\n        \n        # Mock exchange info response\n        mock_response = Mock()\n        mock_response.ok = True\n        mock_response.json.return_value = {\"symbols\": []}\n        mock_get.return_value = mock_response\n        \n        broker = ShadowBroker(symbols=[\"BTCUSDT\"])\n        \n        assert \"BTCUSDT\" in broker.symbols\n        assert broker.slippage_bps == 2.0\n        mock_load_cfg.assert_called_once()\n    \n    @patch(\"requests.get\")\n    @patch('core.execution.shadow_broker.load_binance_cfg'",
    "locations": [
      {
        "file": "tests/unit/test_shadow_broker.py",
        "start": 354,
        "end": 376
      },
      {
        "file": "tests/unit/test_shadow_broker.py",
        "start": 40,
        "end": 62
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 22,
    "tokens": 0,
    "code_snippet": ")\n    def test_shadow_broker_with_custom_slippage(self, mock_load_cfg, mock_get):\n        \"\"\"Test ShadowBroker initialization with custom slippage config.\"\"\"\n        mock_cfg = Mock()\n        mock_cfg.base_url = \"https://api.binance.com\"\n        mock_cfg.api_key = \"test_key\"\n        mock_cfg.api_secret = \"test_secret\"\n        mock_load_cfg.return_value = mock_cfg\n        \n        # Mock exchange info response\n        mock_response = Mock()\n        mock_response.ok = True\n        mock_response.json.return_value = {\"symbols\": []}\n        mock_get.return_value = mock_response\n        \n        broker = ShadowBroker(symbols=[\"ETHUSDT\"], slippage_bps=5.0)\n        \n        assert \"ETHUSDT\" in broker.symbols\n        assert broker.slippage_bps == 5.0\n        mock_load_cfg.assert_called_once()\n    \n    @patch(\"core.execution.shadow_broker.load_binance_cfg\"",
    "locations": [
      {
        "file": "tests/unit/test_shadow_broker.py",
        "start": 376,
        "end": 397
      },
      {
        "file": "tests/unit/test_shadow_broker.py",
        "start": 62,
        "end": 83
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 45,
    "tokens": 0,
    "code_snippet": "(self, mock_load_cfg, mock_get):\n        \"\"\"Test getting filters for symbol.\"\"\"\n        mock_cfg = Mock()\n        mock_cfg.base_url = \"https://api.binance.com\"\n        mock_load_cfg.return_value = mock_cfg\n        \n        # Mock exchange info response\n        mock_response = Mock()\n        mock_response.ok = True\n        mock_response.json.return_value = {\n            \"symbols\": [{\n                \"symbol\": \"BTCUSDT\",\n                \"status\": \"TRADING\",\n                \"filters\": [\n                    {\n                        \"filterType\": \"LOT_SIZE\",\n                        \"minQty\": \"0.00001000\",\n                        \"maxQty\": \"9000.00000000\",\n                        \"stepSize\": \"0.00001000\"\n                    },\n                    {\n                        \"filterType\": \"PRICE_FILTER\",\n                        \"minPrice\": \"0.01000000\",\n                        \"maxPrice\": \"1000000.00000000\",\n                        \"tickSize\": \"0.01000000\"\n                    },\n                    {\n                        \"filterType\": \"MIN_NOTIONAL\",\n                        \"minNotional\": \"10.00000000\"\n                    }\n                ]\n            }]\n        }\n        mock_get.return_value = mock_response\n        \n        broker = ShadowBroker(symbols=[\"BTCUSDT\"])\n        filters = broker.get_filters(\"BTCUSDT\")\n        \n        assert filters is not None\n        assert filters.lot_size_min_qty == Decimal(\"0.00001000\")\n        assert filters.lot_size_max_qty == Decimal(\"9000.00000000\")\n        assert filters.lot_size_step_size == Decimal(\"0.00001000\")\n        assert filters.min_notional == Decimal(\"10.00000000\")\n    \n    @patch(\"core.execution.shadow_broker.load_binance_cfg\"",
    "locations": [
      {
        "file": "tests/unit/test_shadow_broker.py",
        "start": 399,
        "end": 443
      },
      {
        "file": "tests/unit/test_shadow_broker.py",
        "start": 85,
        "end": 129
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 35,
    "tokens": 0,
    "code_snippet": "(self, mock_load_cfg, mock_get):\n        \"\"\"Test successful order validation and rounding.\"\"\"\n        mock_cfg = Mock()\n        mock_cfg.base_url = \"https://api.binance.com\"\n        mock_load_cfg.return_value = mock_cfg\n        \n        # Mock exchange info response\n        mock_response = Mock()\n        mock_response.ok = True\n        mock_response.json.return_value = {\"symbols\": []}\n        mock_get.return_value = mock_response\n        \n        broker = ShadowBroker(symbols=[\"BTCUSDT\"])\n        \n        # Set up test filters manually\n        broker.filters[\"BTCUSDT\"] = BinanceFilters(\n            lot_size_min_qty=Decimal(\"0.00001\"),\n            lot_size_max_qty=Decimal(\"9000\"),\n            lot_size_step_size=Decimal(\"0.00001\"),\n            price_filter_min_price=Decimal(\"0.01\"),\n            price_filter_max_price=Decimal(\"1000000\"),\n            price_filter_tick_size=Decimal(\"0.01\"),\n            min_notional=Decimal(\"10.0\")\n        )\n        \n        is_valid, message, qty, price = broker.validate_and_round_order(\n            \"BTCUSDT\", \"BUY\", \"LIMIT\", 1.0, 50000.0\n        )\n        \n        assert is_valid is True\n        assert message == \"OK\"\n        assert qty == 1.0\n        assert price == 50000.0\n    \n    @patch(\"core.execution.shadow_broker.load_binance_cfg\"",
    "locations": [
      {
        "file": "tests/unit/test_shadow_broker.py",
        "start": 445,
        "end": 479
      },
      {
        "file": "tests/unit/test_shadow_broker.py",
        "start": 131,
        "end": 165
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 35,
    "tokens": 0,
    "code_snippet": "(self, mock_load_cfg, mock_get):\n        \"\"\"Test order validation with invalid quantity.\"\"\"\n        mock_cfg = Mock()\n        mock_cfg.base_url = \"https://api.binance.com\"\n        mock_load_cfg.return_value = mock_cfg\n        \n        # Mock exchange info response\n        mock_response = Mock()\n        mock_response.ok = True\n        mock_response.json.return_value = {\"symbols\": []}\n        mock_get.return_value = mock_response\n        \n        broker = ShadowBroker(symbols=[\"BTCUSDT\"])\n        \n        # Set up test filters manually\n        broker.filters[\"BTCUSDT\"] = BinanceFilters(\n            lot_size_min_qty=Decimal(\"0.001\"),\n            lot_size_max_qty=Decimal(\"1000\"),\n            lot_size_step_size=Decimal(\"0.001\"),\n            price_filter_min_price=Decimal(\"0.01\"),\n            price_filter_max_price=Decimal(\"100000\"),\n            price_filter_tick_size=Decimal(\"0.01\"),\n            min_notional=Decimal(\"10.0\")\n        )\n        \n        # Test quantity too small\n        is_valid, message, qty, price = broker.validate_and_round_order(\n            \"BTCUSDT\", \"BUY\", \"LIMIT\", 0.0005, 50000.0\n        )\n        \n        assert is_valid is False\n        assert \"LOT_SIZE\" in message\n        assert \"Quantity\" in message\n    \n    @patch(\"core.execution.shadow_broker.load_binance_cfg\"",
    "locations": [
      {
        "file": "tests/unit/test_shadow_broker.py",
        "start": 481,
        "end": 515
      },
      {
        "file": "tests/unit/test_shadow_broker.py",
        "start": 167,
        "end": 201
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 68,
    "tokens": 0,
    "code_snippet": "(self, mock_load_cfg, mock_get):\n        \"\"\"Test order validation with insufficient notional value.\"\"\"\n        mock_cfg = Mock()\n        mock_cfg.base_url = \"https://api.binance.com\"\n        mock_load_cfg.return_value = mock_cfg\n        \n        # Mock exchange info response\n        mock_response = Mock()\n        mock_response.ok = True\n        mock_response.json.return_value = {\"symbols\": []}\n        mock_get.return_value = mock_response\n        \n        broker = ShadowBroker(symbols=[\"BTCUSDT\"])\n        \n        # Set up test filters manually\n        broker.filters[\"BTCUSDT\"] = BinanceFilters(\n            lot_size_min_qty=Decimal(\"0.001\"),\n            lot_size_max_qty=Decimal(\"1000\"),\n            lot_size_step_size=Decimal(\"0.001\"),\n            price_filter_min_price=Decimal(\"0.01\"),\n            price_filter_max_price=Decimal(\"100000\"),\n            price_filter_tick_size=Decimal(\"0.01\"),\n            min_notional=Decimal(\"10.0\")\n        )\n        \n        # Test insufficient notional (0.001 * 1.0 = 0.001 < 10.0)\n        is_valid, message, qty, price = broker.validate_and_round_order(\n            \"BTCUSDT\", \"BUY\", \"LIMIT\", 0.001, 1.0\n        )\n        \n        assert is_valid is False\n        assert \"MIN_NOTIONAL\" in message\n    \n    @patch(\"requests.get\")\n    @patch(\"core.execution.shadow_broker.load_binance_cfg\")\n    def test_submit_order_market_buy(self, mock_load_cfg, mock_get):\n        \"\"\"Test market buy order submission with slippage simulation.\"\"\"\n        mock_cfg = Mock()\n        mock_cfg.base_url = \"https://api.binance.com\"\n        mock_load_cfg.return_value = mock_cfg\n        \n        # Mock exchange info response\n        mock_response = Mock()\n        mock_response.ok = True\n        mock_response.json.return_value = {\"symbols\": []}\n        mock_get.return_value = mock_response\n        \n        broker = ShadowBroker(symbols=[\"BTCUSDT\"], slippage_bps=2.0)\n        \n        # Set up test filters manually\n        broker.filters[\"BTCUSDT\"] = BinanceFilters(\n            lot_size_min_qty=Decimal(\"0.001\"),\n            lot_size_max_qty=Decimal(\"1000\"),\n            lot_size_step_size=Decimal(\"0.001\"),\n            price_filter_min_price=Decimal(\"0.01\"),\n            price_filter_max_price=Decimal(\"100000\"),\n            price_filter_tick_size=Decimal(\"0.01\"),\n            min_notional=Decimal(\"10.0\")\n        )\n        \n        result = broker.submit_order(\"BTCUSDT\", \"BUY\", \"MARKET\", 1.0)\n        \n        assert result[\"status\"] == \"FILLED\"\n        assert result[\"symbol\"] == \"BTCUSDT\"\n        assert result[\"side\"] == \"BUY\"\n        assert result[\"type\"] == \"MARKET\"\n        assert result[\"executedQty\"] == \"1.000\"\n        assert",
    "locations": [
      {
        "file": "tests/unit/test_shadow_broker.py",
        "start": 517,
        "end": 584
      },
      {
        "file": "tests/unit/test_shadow_broker.py",
        "start": 203,
        "end": 269
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 38,
    "tokens": 0,
    "code_snippet": "assert \"orderId\" in result\n        assert \"fills\" in result\n    \n    @patch(\"requests.get\")\n    @patch(\"core.execution.shadow_broker.load_binance_cfg\")\n    def test_submit_order_limit_order(self, mock_load_cfg, mock_get):\n        \"\"\"Test limit order submission at specified price.\"\"\"\n        mock_cfg = Mock()\n        mock_cfg.base_url = \"https://api.binance.com\"\n        mock_load_cfg.return_value = mock_cfg\n        \n        # Mock exchange info response\n        mock_response = Mock()\n        mock_response.ok = True\n        mock_response.json.return_value = {\"symbols\": []}\n        mock_get.return_value = mock_response\n        \n        broker = ShadowBroker(symbols=[\"BTCUSDT\"])\n        \n        # Set up test filters manually\n        broker.filters[\"BTCUSDT\"] = BinanceFilters(\n            lot_size_min_qty=Decimal(\"0.001\"),\n            lot_size_max_qty=Decimal(\"1000\"),\n            lot_size_step_size=Decimal(\"0.001\"),\n            price_filter_min_price=Decimal(\"0.01\"),\n            price_filter_max_price=Decimal(\"100000\"),\n            price_filter_tick_size=Decimal(\"0.01\"),\n            min_notional=Decimal(\"10.0\")\n        )\n        \n        result = broker.submit_order(\"BTCUSDT\", \"BUY\", \"LIMIT\", 1.0, 50000.0)\n        \n        assert result[\"status\"] == \"FILLED\"\n        assert result[\"symbol\"] == \"BTCUSDT\"\n        assert result[\"side\"] == \"BUY\"\n        assert result[\"type\"] == \"LIMIT\"\n        assert result[\"executedQty\"] == \"1.000\"\n        assert",
    "locations": [
      {
        "file": "tests/unit/test_shadow_broker.py",
        "start": 584,
        "end": 621
      },
      {
        "file": "tests/unit/test_shadow_broker.py",
        "start": 270,
        "end": 306
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 41,
    "tokens": 0,
    "code_snippet": "assert float(result[\"fills\"][0][\"price\"]) == 50000.0\n    \n    @patch(\"requests.get\")\n    @patch(\"core.execution.shadow_broker.load_binance_cfg\")\n    def test_submit_order_validation_failure(self, mock_load_cfg, mock_get):\n        \"\"\"Test order rejection due to validation failure.\"\"\"\n        mock_cfg = Mock()\n        mock_cfg.base_url = \"https://api.binance.com\"\n        mock_load_cfg.return_value = mock_cfg\n        \n        # Mock exchange info response\n        mock_response = Mock()\n        mock_response.ok = True\n        mock_response.json.return_value = {\"symbols\": []}\n        mock_get.return_value = mock_response\n        \n        broker = ShadowBroker(symbols=[\"BTCUSDT\"])\n        \n        # Set up test filters manually\n        broker.filters[\"BTCUSDT\"] = BinanceFilters(\n            lot_size_min_qty=Decimal(\"0.001\"),\n            lot_size_max_qty=Decimal(\"1000\"),\n            lot_size_step_size=Decimal(\"0.001\"),\n            price_filter_min_price=Decimal(\"0.01\"),\n            price_filter_max_price=Decimal(\"100000\"),\n            price_filter_tick_size=Decimal(\"0.01\"),\n            min_notional=Decimal(\"10.0\")\n        )\n        \n        # Submit order with invalid quantity\n        result = broker.submit_order(\"BTCUSDT\", \"BUY\", \"LIMIT\", 0.0005, 50000.0)\n        \n        # Fixed expected format for validation failure\n        assert \"code\" in result\n        assert result[\"code\"] == -1013\n        assert \"Filter failure\" in result[\"msg\"]\n        assert \"LOT_SIZE\" in result[\"msg\"]\n\n\nif __name__ == \"__main__\":\n    unittest.main()",
    "locations": [
      {
        "file": "tests/unit/test_shadow_broker.py",
        "start": 621,
        "end": 661
      },
      {
        "file": "tests/unit/test_shadow_broker.py",
        "start": 307,
        "end": 347
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 7,
    "tokens": 0,
    "code_snippet": "mock_adapter = Mock()\n        mock_adapter.symbol = \"BTCUSDT\"\n        mock_adapter.fetch_top_of_book.return_value = (100.0, 0.01, [(99.99, 1.0)], [(100.01, 1.0)], [])\n        mock_create_adapter.return_value = mock_adapter\n        \n        with patch.dict(os.environ, {\n            'AURORA_MAX_TICKS': '1'",
    "locations": [
      {
        "file": "tests/unit/test_run_live_aurora_complete.py",
        "start": 245,
        "end": 251
      },
      {
        "file": "tests/unit/test_run_live_aurora_complete.py",
        "start": 222,
        "end": 227
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 6,
    "tokens": 0,
    "code_snippet": "mock_adapter = Mock()\n        mock_adapter.symbol = \"BTCUSDT\"\n        mock_adapter.fetch_top_of_book.return_value = (100.0, 0.01, [(99.99, 1.0)], [(100.01, 1.0)], [])\n        mock_create_adapter.return_value = mock_adapter\n        \n        with patch.dict(os.environ, {'AURORA_MAX_TICKS': '1'}",
    "locations": [
      {
        "file": "tests/unit/test_run_live_aurora_complete.py",
        "start": 280,
        "end": 285
      },
      {
        "file": "tests/unit/test_run_live_aurora_complete.py",
        "start": 222,
        "end": 251
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 9,
    "tokens": 0,
    "code_snippet": "mock_create_adapter.return_value = mock_adapter\n        \n        with patch.dict(os.environ, {'AURORA_MAX_TICKS': '1'}):\n            with patch('skalp_bot.runner.run_live_aurora.AuroraGate') as mock_gate:\n                mock_gate_instance = Mock()\n                mock_gate_instance.check.return_value = {\"allow\": True}\n                mock_gate.return_value = mock_gate_instance\n                \n                with patch('skalp_bot.runner.run_live_aurora.time.sleep'",
    "locations": [
      {
        "file": "tests/unit/test_run_live_aurora_complete.py",
        "start": 330,
        "end": 338
      },
      {
        "file": "tests/unit/test_run_live_aurora_complete.py",
        "start": 283,
        "end": 291
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 7,
    "tokens": 0,
    "code_snippet": "with patch.dict(os.environ, {'AURORA_MAX_TICKS': '1'}):\n                with patch('skalp_bot.runner.run_live_aurora.create_adapter') as mock_create_adapter:\n                    mock_adapter = Mock()\n                    mock_adapter.fetch_top_of_book.return_value = (100.0, 0.01, [], [], [])\n                    mock_create_adapter.return_value = mock_adapter\n                    \n                    with patch('skalp_bot.runner.run_live_aurora.time.sleep'",
    "locations": [
      {
        "file": "tests/unit/test_run_live_aurora_complete.py",
        "start": 352,
        "end": 358
      },
      {
        "file": "tests/unit/test_run_live_aurora_complete.py",
        "start": 205,
        "end": 211
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 21,
    "tokens": 0,
    "code_snippet": "def setup_method(self):\n        \"\"\"Setup test fixtures.\"\"\"\n        self.config = {\n            \"execution\": {\n                \"edge_floor_bps\": 1.0,\n                \"router\": {\n                    \"horizon_ms\": 1500,\n                    \"p_min_fill\": 0.25,\n                    \"spread_deny_bps\": 8.0,\n                    \"maker_spread_ok_bps\": 2.0,\n                    \"switch_margin_bps\": 0.0\n                },\n                \"sla\": {\n                    \"kappa_bps_per_ms\": 0.01,\n                    \"max_latency_ms\": 250\n                }\n            }\n        }\n        self.router = Router(self.config)\n\n    def test_decide_sla_latency_deny",
    "locations": [
      {
        "file": "tests/unit/test_router_new.py",
        "start": 180,
        "end": 200
      },
      {
        "file": "tests/unit/test_router_new.py",
        "start": 116,
        "end": 136
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 11,
    "tokens": 0,
    "code_snippet": "def setup_method(self):\n        \"\"\"Setup test fixtures.\"\"\"\n        self.fees = Fees(maker_fee_bps=0.1, taker_fee_bps=0.5)\n        self.sla = SLAGate(max_latency_ms=50.0, kappa_bps_per_ms=0.1, min_edge_after_bps=0.0)\n        self.router = Router(\n            slagate=self.sla,\n            min_p_fill=0.5,\n            fees=self.fees\n        )\n\n    def test_estimate_p_fill_no_hazard",
    "locations": [
      {
        "file": "tests/unit/test_router_backup.py",
        "start": 340,
        "end": 350
      },
      {
        "file": "tests/unit/test_router_backup.py",
        "start": 169,
        "end": 179
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 11,
    "tokens": 0,
    "code_snippet": "def setup_method(self):\n        \"\"\"Setup test fixtures.\"\"\"\n        self.fees = Fees(maker_fee_bps=0.1, taker_fee_bps=0.5)\n        self.sla = SLAGate(max_latency_ms=50.0, kappa_bps_per_ms=0.1, min_edge_after_bps=0.0)\n        self.router = Router(\n            slagate=self.sla,\n            min_p_fill=0.5,\n            fees=self.fees\n        )\n\n    def test_decide_creates_log_entry",
    "locations": [
      {
        "file": "tests/unit/test_router_backup.py",
        "start": 410,
        "end": 420
      },
      {
        "file": "tests/unit/test_router_backup.py",
        "start": 169,
        "end": 179
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 9,
    "tokens": 0,
    "code_snippet": "assert hasattr(decision, 'e_maker_bps')\n        assert hasattr(decision, 'e_taker_bps')\n        assert hasattr(decision, 'p_fill')\n        assert hasattr(decision, 'reason')\n        assert hasattr(decision, 'maker_fee_bps')\n        assert hasattr(decision, 'taker_fee_bps')\n        assert hasattr(decision, 'net_e_maker_bps')\n        assert hasattr(decision, 'net_e_taker_bps')\n        assert",
    "locations": [
      {
        "file": "tests/unit/test_router_backup.py",
        "start": 439,
        "end": 447
      },
      {
        "file": "tests/unit/test_xai_decision_trail.py",
        "start": 63,
        "end": 72
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 11,
    "tokens": 0,
    "code_snippet": "def setup_method(self):\n        \"\"\"Setup test fixtures.\"\"\"\n        self.fees = Fees(maker_fee_bps=0.1, taker_fee_bps=0.5)\n        self.sla = SLAGate(max_latency_ms=50.0, kappa_bps_per_ms=0.1, min_edge_after_bps=0.0)\n        self.router = Router(\n            slagate=self.sla,\n            min_p_fill=0.5,\n            fees=self.fees\n        )\n\n    def test_decide_with_empty_features",
    "locations": [
      {
        "file": "tests/unit/test_router_backup.py",
        "start": 453,
        "end": 463
      },
      {
        "file": "tests/unit/test_router_backup.py",
        "start": 169,
        "end": 179
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 17,
    "tokens": 0,
    "code_snippet": "position = PositionData(\n            position_id=\"test_1\",\n            symbol=\"BTCUSDT\", \n            side=\"BUY\",\n            state=PositionState.FLAT,\n            target_qty=0.001,\n            current_qty=0.0,\n            entry_price=None,\n            \n            exit_reason=None,\n            created_ts=int(time.time()),\n            last_update_ts=int(time.time()),\n        )\n        \n        result = fsm.process_event(position, PositionEvent.EDGE_CHANGE)\n        \n        assert result.success is False",
    "locations": [
      {
        "file": "tests/unit/test_position_fsm_complete.py",
        "start": 51,
        "end": 67
      },
      {
        "file": "tests/unit/test_position_fsm_complete.py",
        "start": 25,
        "end": 41
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 16,
    "tokens": 0,
    "code_snippet": "fsm = PositionFSM()\n        position = PositionData(\n            position_id=\"test_1\",\n            symbol=\"BTCUSDT\",\n            side=\"BUY\", \n            state=PositionState.FLAT,\n            target_qty=0.001,\n            current_qty=0.0,\n            entry_price=None,\n            \n            exit_reason=None,\n            created_ts=int(time.time()),\n            last_update_ts=int(time.time()),\n        )\n        \n        # \u041f\u0440\u043e\u0431\u0443\u0454\u043c\u043e \u043d\u0435\u043c\u043e\u0436\u043b\u0438\u0432\u0438\u0439 \u043f\u0435\u0440\u0435\u0445\u0456\u0434",
    "locations": [
      {
        "file": "tests/unit/test_position_fsm_complete.py",
        "start": 72,
        "end": 87
      },
      {
        "file": "tests/unit/test_position_fsm_complete.py",
        "start": 24,
        "end": 39
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 16,
    "tokens": 0,
    "code_snippet": "fsm = PositionFSM()\n        position = PositionData(\n            position_id=\"test_1\",\n            symbol=\"BTCUSDT\",\n            side=\"BUY\",\n            state=PositionState.ENTRY_PENDING,\n            target_qty=0.001,\n            current_qty=0.0,\n            entry_price=None,\n            \n            exit_reason=None,\n            created_ts=int(time.time()),\n            last_update_ts=int(time.time()),\n        )\n        \n        result",
    "locations": [
      {
        "file": "tests/unit/test_position_fsm_complete.py",
        "start": 119,
        "end": 134
      },
      {
        "file": "tests/unit/test_position_fsm_complete.py",
        "start": 95,
        "end": 110
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 11,
    "tokens": 0,
    "code_snippet": ",\n            target_qty=0.001,\n            current_qty=0.0,\n            entry_price=None,\n            \n            exit_reason=None,\n            created_ts=int(time.time()),\n            last_update_ts=int(time.time()),\n        )\n        \n        result = fsm.process_event(position, PositionEvent.RISK_DENY",
    "locations": [
      {
        "file": "tests/unit/test_position_fsm_complete.py",
        "start": 124,
        "end": 134
      },
      {
        "file": "tests/unit/test_position_fsm_complete.py",
        "start": 29,
        "end": 39
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 16,
    "tokens": 0,
    "code_snippet": "fsm = PositionFSM()\n        position = PositionData(\n            position_id=\"test_1\",\n            symbol=\"BTCUSDT\",\n            side=\"BUY\",\n            state=PositionState.OPEN,\n            target_qty=0.001,\n            current_qty=0.001,\n            entry_price=50000.0,\n            \n            exit_reason=None,\n            created_ts=int(time.time()),\n            last_update_ts=int(time.time()),\n        )\n        \n        result = fsm.process_event(position, PositionEvent.SCALE_SIGNAL",
    "locations": [
      {
        "file": "tests/unit/test_position_fsm_complete.py",
        "start": 168,
        "end": 183
      },
      {
        "file": "tests/unit/test_position_fsm_complete.py",
        "start": 144,
        "end": 159
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 16,
    "tokens": 0,
    "code_snippet": "fsm = PositionFSM()\n        position = PositionData(\n            position_id=\"test_1\",\n            symbol=\"BTCUSDT\",\n            side=\"BUY\",\n            state=PositionState.OPEN,\n            target_qty=0.001,\n            current_qty=0.001,\n            entry_price=50000.0,\n            \n            exit_reason=None,\n            created_ts=int(time.time()),\n            last_update_ts=int(time.time()),\n        )\n        \n        result = fsm.process_event(position, PositionEvent.TRAIL_HIT",
    "locations": [
      {
        "file": "tests/unit/test_position_fsm_complete.py",
        "start": 264,
        "end": 279
      },
      {
        "file": "tests/unit/test_position_fsm_complete.py",
        "start": 144,
        "end": 159
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 16,
    "tokens": 0,
    "code_snippet": "fsm = PositionFSM()\n        position = PositionData(\n            position_id=\"test_1\",\n            symbol=\"BTCUSDT\",\n            side=\"BUY\",\n            state=PositionState.OPEN,\n            target_qty=0.001,\n            current_qty=0.001,\n            entry_price=50000.0,\n            \n            exit_reason=None,\n            created_ts=int(time.time()),\n            last_update_ts=int(time.time()),\n        )\n        \n        result = fsm.process_event(position, PositionEvent.TP_HIT",
    "locations": [
      {
        "file": "tests/unit/test_position_fsm_complete.py",
        "start": 286,
        "end": 301
      },
      {
        "file": "tests/unit/test_position_fsm_complete.py",
        "start": 144,
        "end": 159
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 16,
    "tokens": 0,
    "code_snippet": "fsm = PositionFSM()\n        position = PositionData(\n            position_id=\"test_1\",\n            symbol=\"BTCUSDT\",\n            side=\"BUY\",\n            state=PositionState.ENTRY_PENDING,\n            target_qty=0.001,\n            current_qty=0.0,\n            entry_price=None,\n            \n            exit_reason=None,\n            created_ts=int(time.time()),\n            last_update_ts=int(time.time()),\n        )\n        \n        result = fsm.process_event(position, PositionEvent.TTL_EXPIRED",
    "locations": [
      {
        "file": "tests/unit/test_position_fsm_complete.py",
        "start": 308,
        "end": 323
      },
      {
        "file": "tests/unit/test_position_fsm_complete.py",
        "start": 95,
        "end": 39
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 16,
    "tokens": 0,
    "code_snippet": "fsm = PositionFSM()\n        position = PositionData(\n            position_id=\"test_1\",\n            symbol=\"BTCUSDT\",\n            side=\"BUY\",\n            state=PositionState.ENTRY_PENDING,\n            target_qty=0.001,\n            current_qty=0.0,\n            entry_price=None,\n            \n            exit_reason=None,\n            created_ts=int(time.time()),\n            last_update_ts=int(time.time()),\n        )\n        \n        result = fsm.process_event(position, PositionEvent.EXCHANGE_REJECT",
    "locations": [
      {
        "file": "tests/unit/test_position_fsm_complete.py",
        "start": 330,
        "end": 345
      },
      {
        "file": "tests/unit/test_position_fsm_complete.py",
        "start": 95,
        "end": 39
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 15,
    "tokens": 0,
    "code_snippet": "fsm = PositionFSM()\n        position = PositionData(\n            position_id=\"test_1\",\n            symbol=\"BTCUSDT\",\n            side=\"BUY\",\n            state=PositionState.FLAT,\n            target_qty=0.001,\n            current_qty=0.0,\n            entry_price=None,\n            exit_reason=None,\n            created_ts=int(time.time()),\n            last_update_ts=int(time.time()),\n        )\n\n        initial_ts",
    "locations": [
      {
        "file": "tests/unit/test_position_fsm_complete.py",
        "start": 352,
        "end": 366
      },
      {
        "file": "tests/unit/test_position_fsm_complete.py",
        "start": 24,
        "end": 39
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 16,
    "tokens": 0,
    "code_snippet": "fsm = PositionFSM()\n        position = PositionData(\n            position_id=\"test_1\",\n            symbol=\"BTCUSDT\",\n            side=\"BUY\",\n            state=PositionState.ENTRY_PENDING,\n            target_qty=0.001,\n            current_qty=0.0,\n            entry_price=None,\n            \n            exit_reason=None,\n            created_ts=int(time.time()),\n            last_update_ts=int(time.time()),\n        )\n        \n        # \u0422\u0435\u0441\u0442 \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u043d\u043e\u0433\u043e \u0432\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u043d\u044f exit_reason",
    "locations": [
      {
        "file": "tests/unit/test_position_fsm_complete.py",
        "start": 403,
        "end": 418
      },
      {
        "file": "tests/unit/test_position_fsm_complete.py",
        "start": 95,
        "end": 110
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 16,
    "tokens": 0,
    "code_snippet": "fsm = PositionFSM()\n        position = PositionData(\n            position_id=\"test_1\",\n            symbol=\"BTCUSDT\",\n            side=\"BUY\",\n            state=PositionState.SCALE_IN_PENDING,\n            target_qty=0.002,\n            current_qty=0.001,\n            entry_price=50000.0,\n            \n            exit_reason=None,\n            created_ts=int(time.time()),\n            last_update_ts=int(time.time()),\n        )\n        \n        result",
    "locations": [
      {
        "file": "tests/unit/test_position_fsm_complete.py",
        "start": 426,
        "end": 441
      },
      {
        "file": "tests/unit/test_position_fsm_complete.py",
        "start": 190,
        "end": 205
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 11,
    "tokens": 0,
    "code_snippet": ",\n            \n            exit_reason=None,\n            created_ts=int(time.time()),\n            last_update_ts=int(time.time()),\n        )\n        \n        result = fsm.process_event(position, PositionEvent.RISK_DENY)\n        \n        assert result.success is True\n        assert result.new_state == PositionState.OPEN",
    "locations": [
      {
        "file": "tests/unit/test_position_fsm_complete.py",
        "start": 434,
        "end": 444
      },
      {
        "file": "tests/unit/test_position_fsm_complete.py",
        "start": 127,
        "end": 137
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 13,
    "tokens": 0,
    "code_snippet": "'score': 2.0,\n            'a_bps': 1.0,\n            'b_bps': 2.0,\n            'slip_bps_est': 0.1,\n            'spread_bps': 50.0\n        }\n        fees_bps = 0.1\n\n        allow, reason, obs, risk_scale = pipeline.decide(\n            account=account, order=order, market=market, fees_bps=fees_bps\n        )\n\n        assert allow is True",
    "locations": [
      {
        "file": "tests/unit/test_pipeline.py",
        "start": 89,
        "end": 101
      },
      {
        "file": "tests/unit/test_pipeline.py",
        "start": 65,
        "end": 77
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 16,
    "tokens": 0,
    "code_snippet": "'score': 2.0,\n            'a_bps': 1.0,\n            'b_bps': 2.0,\n            'slip_bps_est': 0.1,\n            'spread_bps': 50.0\n        }\n        fees_bps = 0.1\n\n        allow, reason, obs, risk_scale = pipeline.decide(\n            account=account, order=order, market=market, fees_bps=fees_bps\n        )\n\n        assert allow is True\n        assert reason == 'ok'\n\n    def",
    "locations": [
      {
        "file": "tests/unit/test_pipeline.py",
        "start": 113,
        "end": 128
      },
      {
        "file": "tests/unit/test_pipeline.py",
        "start": 65,
        "end": 103
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 16,
    "tokens": 0,
    "code_snippet": "'score': 2.0,\n            'a_bps': 1.0,\n            'b_bps': 2.0,\n            'slip_bps_est': 0.1,\n            'spread_bps': 50.0\n        }\n        fees_bps = 0.1\n\n        allow, reason, obs, risk_scale = pipeline.decide(\n            account=account, order=order, market=market, fees_bps=fees_bps\n        )\n\n        assert allow is True\n        assert reason == 'ok'\n        assert obs['gate_state'] == 'PASS'\n        assert",
    "locations": [
      {
        "file": "tests/unit/test_pipeline.py",
        "start": 332,
        "end": 347
      },
      {
        "file": "tests/unit/test_pipeline.py",
        "start": 65,
        "end": 105
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 28,
    "tokens": 0,
    "code_snippet": "from core.infra.idempotency_store import IdempotencyStore\r\n\r\n\r\ndef test_put_get_seen_and_sweep():\r\n    # deterministic now_ns for testing\r\n    now_ns = lambda: 1_000_000_000\r\n    store = IdempotencyStore(ttl_sec=3600, now_ns_fn=now_ns)\r\n    key = \"op-123\"\r\n    assert not store.seen(key)\r\n    store.put(key, {\"ok\": True})\r\n    assert store.seen(key)\r\n    assert store.get(key) == {\"ok\": True}\r\n    # sweep should remove nothing for large ttl\r\n    removed = store.sweep()\r\n    assert removed == 0\r\n\r\n\r\ndef test_sweep_removes_expired():\r\n    t = [1_000_000_000]\r\n    now_ns = lambda: t[0]\r\n    store = IdempotencyStore(ttl_sec=0.000001, now_ns_fn=now_ns)  # tiny ttl\r\n    store.put(\"k\", 1)\r\n    assert store.seen(\"k\")\r\n    # advance time beyond ttl\r\n    t[0] += int(1e9)\r\n    removed = store.sweep()\r\n    assert removed == 1\r\n    assert not store.seen(\"k\")",
    "locations": [
      {
        "file": "tests/unit/test_idempotency_store_basic.py",
        "start": 29,
        "end": 56
      },
      {
        "file": "tests/unit/test_idempotency_store_basic.py",
        "start": 1,
        "end": 28
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 19,
    "tokens": 0,
    "code_snippet": "# Prevent dotenv from loading any external .env file\n        mock_load_dotenv.return_value = None\n        \n        # Ensure no testnet variables are present\n        testnet_vars = [\n            'BINANCE_API_KEY_TESTNET', 'BINANCE_API_SECRET_TESTNET',\n            'BINANCE_USDM_BASE_URL_TESTNET', 'BINANCE_USDM_WS_URL_TESTNET'\n        ]\n        for var in testnet_vars:\n            if var in os.environ:\n                del os.environ[var]\n        \n        with pytest.raises(RuntimeError, match=\"Missing live credentials\"):\n            load_binance_cfg()\n    \n    @patch('core.env_config.load_dotenv')  # Mock dotenv loading\n    @patch.dict(os.environ, {\n        'BINANCE_ENV': 'live',\n        'BINANCE_API_KEY_LIVE': 'live_key'",
    "locations": [
      {
        "file": "tests/unit/test_env_config_guards.py",
        "start": 183,
        "end": 201
      },
      {
        "file": "tests/unit/test_env_config_guards.py",
        "start": 160,
        "end": 178
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 16,
    "tokens": 0,
    "code_snippet": ")\r\n        breaker = ExchangeCircuitBreaker(config)\r\n        \r\n        # Set initial time\r\n        mock_time.return_value = 1000.0\r\n        \r\n        # Trigger failures to open circuit\r\n        for i in range(2):\r\n            with pytest.raises(Exception):\r\n                breaker.call(lambda: exec('raise Exception(\"test error\")'))\r\n        \r\n        # Time passes beyond recovery timeout\r\n        mock_time.return_value = 1002.0\r\n        \r\n        # Transition to HALF_OPEN\r\n        breaker.call(lambda: \"success\"",
    "locations": [
      {
        "file": "tests/unit/test_circuit_breaker.py",
        "start": 137,
        "end": 152
      },
      {
        "file": "tests/unit/test_circuit_breaker.py",
        "start": 103,
        "end": 118
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 13,
    "tokens": 0,
    "code_snippet": "cfg = {\"symbol\": \"BTCUSDT\"}\n        adapter = CCXTBinanceAdapter(cfg)\n        \n        mid, spread, bids, asks, trades = adapter.fetch_top_of_book()\n        \n        assert mid == 0.0\n        assert spread == 0.0\n        assert bids == []\n        assert asks == []\n        assert trades == []\n\n    @patch('ccxt.binanceusdm')\n    def test_place_order_dry_run",
    "locations": [
      {
        "file": "tests/unit/test_ccxt_binance_complete.py",
        "start": 172,
        "end": 184
      },
      {
        "file": "tests/unit/test_ccxt_binance_complete.py",
        "start": 153,
        "end": 165
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 11,
    "tokens": 0,
    "code_snippet": "}\n        \n        with tempfile.TemporaryDirectory() as tmpdir:\n            out_json = os.path.join(tmpdir, \"metrics.json\")\n            with open(out_json, 'w') as f:\n                json.dump(mock_metrics, f)\n                \n            with patch('subprocess.run') as mock_subprocess:\n                mock_subprocess.return_value = MagicMock()\n                \n                run_replay",
    "locations": [
      {
        "file": "tests/research/test_replay_adapter.py",
        "start": 134,
        "end": 144
      },
      {
        "file": "tests/research/test_replay_adapter.py",
        "start": 82,
        "end": 92
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 12,
    "tokens": 0,
    "code_snippet": "}\n        \n        with tempfile.TemporaryDirectory() as tmpdir:\n            out_json = os.path.join(tmpdir, \"metrics.json\")\n            with open(out_json, 'w') as f:\n                json.dump(mock_metrics, f)\n                \n            with patch('subprocess.run') as mock_subprocess:\n                mock_subprocess.return_value = MagicMock()\n                \n                run_replay(\n                    {",
    "locations": [
      {
        "file": "tests/research/test_replay_adapter.py",
        "start": 161,
        "end": 172
      },
      {
        "file": "tests/research/test_replay_adapter.py",
        "start": 82,
        "end": 144
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 9,
    "tokens": 0,
    "code_snippet": "import importlib.util\n        \n        # Import live_feed module\n        live_feed_path = Path(__file__).parent.parent.parent / \"tools\" / \"live_feed.py\"\n        spec = importlib.util.spec_from_file_location(\"live_feed\", live_feed_path)\n        live_feed = importlib.util.module_from_spec(spec)\n        spec.loader.exec_module(live_feed)\n        \n        # Test Starlette availability check",
    "locations": [
      {
        "file": "tests/integration/test_p3d_live_dashboard.py",
        "start": 129,
        "end": 137
      },
      {
        "file": "tests/integration/test_p3d_live_dashboard.py",
        "start": 69,
        "end": 77
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 9,
    "tokens": 0,
    "code_snippet": "import importlib.util\n    \n    # Import live_feed module\n    live_feed_path = Path(__file__).parent.parent.parent / \"tools\" / \"live_feed.py\"\n    spec = importlib.util.spec_from_file_location(\"live_feed\", live_feed_path)\n    live_feed = importlib.util.module_from_spec(spec)\n    spec.loader.exec_module(live_feed)\n    \n    # Check main function exists",
    "locations": [
      {
        "file": "tests/integration/test_p3d_live_dashboard.py",
        "start": 159,
        "end": 167
      },
      {
        "file": "tests/integration/test_p3d_live_dashboard.py",
        "start": 69,
        "end": 77
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 9,
    "tokens": 0,
    "code_snippet": "import importlib.util\n        \n        # Import live_feed module\n        live_feed_path = Path(__file__).parent.parent.parent / \"tools\" / \"live_feed.py\"\n        spec = importlib.util.spec_from_file_location(\"live_feed\", live_feed_path)\n        live_feed = importlib.util.module_from_spec(spec)\n        spec.loader.exec_module(live_feed)\n        \n        # Create aggregator and tailer",
    "locations": [
      {
        "file": "tests/integration/test_p3d_hardening.py",
        "start": 63,
        "end": 71
      },
      {
        "file": "tests/integration/test_p3d_live_dashboard.py",
        "start": 69,
        "end": 77
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 13,
    "tokens": 0,
    "code_snippet": "import importlib.util\n        \n        # Import live_feed module\n        live_feed_path = Path(__file__).parent.parent.parent / \"tools\" / \"live_feed.py\"\n        spec = importlib.util.spec_from_file_location(\"live_feed\", live_feed_path)\n        live_feed = importlib.util.module_from_spec(spec)\n        spec.loader.exec_module(live_feed)\n        \n        # Create aggregator and tailer\n        aggregator = live_feed.LiveAggregator(300)\n        tailer = live_feed.JSONLTailer(temp_session_with_logs, aggregator)\n        \n        # Add oversized line",
    "locations": [
      {
        "file": "tests/integration/test_p3d_hardening.py",
        "start": 98,
        "end": 110
      },
      {
        "file": "tests/integration/test_p3d_live_dashboard.py",
        "start": 69,
        "end": 75
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 10,
    "tokens": 0,
    "code_snippet": "import importlib.util\n\n        # Import live_feed module\n        live_feed_path = Path(__file__).parent.parent.parent / \"tools\" / \"live_feed.py\"\n        spec = importlib.util.spec_from_file_location(\"live_feed\", live_feed_path)\n        live_feed = importlib.util.module_from_spec(spec)\n        spec.loader.exec_module(live_feed)\n\n        # Create aggregator and tailer\n        aggregator = live_feed.LiveAggregator(window_minutes",
    "locations": [
      {
        "file": "tests/integration/test_p3d_hardening.py",
        "start": 134,
        "end": 143
      },
      {
        "file": "tests/integration/test_p3d_live_dashboard.py",
        "start": 69,
        "end": 72
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 9,
    "tokens": 0,
    "code_snippet": "import importlib.util\n\n        # Import live_feed module\n        live_feed_path = Path(__file__).parent.parent.parent / \"tools\" / \"live_feed.py\"\n        spec = importlib.util.spec_from_file_location(\"live_feed\", live_feed_path)\n        live_feed = importlib.util.module_from_spec(spec)\n        spec.loader.exec_module(live_feed)\n\n        # Create server components",
    "locations": [
      {
        "file": "tests/integration/test_p3d_hardening.py",
        "start": 176,
        "end": 184
      },
      {
        "file": "tests/integration/test_p3d_live_dashboard.py",
        "start": 69,
        "end": 77
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 9,
    "tokens": 0,
    "code_snippet": "}):\n                    with patch(\"skalp_bot.runner.run_live_aurora.create_adapter\") as mock_adapter_factory:\n                        mock_adapter = MockAdapter(MockMarketData())\n                        mock_adapter_factory.return_value = mock_adapter\n                        \n                        with patch(\"yaml.safe_load\", return_value=self.test_config):\n                            with patch(\"pathlib.Path.exists\", return_value=True):\n                                with patch(\"pathlib.Path.read_text\", return_value=\"\"):\n                                    try",
    "locations": [
      {
        "file": "tests/integration/test_governance_gate.py",
        "start": 149,
        "end": 157
      },
      {
        "file": "tests/integration/test_governance_gate.py",
        "start": 109,
        "end": 117
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 20,
    "tokens": 0,
    "code_snippet": "\"policy\": \"pocock\",\n                \"max_history_len\": 100\n            },\n            \"execution\": {\n                \"sla\": {\"max_latency_ms\": 250}\n            },\n            \"order_sink\": {\n                \"mode\": \"sim_local\",\n                \"sim_local\": {\n                    \"latency_ms\": 10,\n                    \"ttl_ms\": 5000\n                }\n            },\n            \"sizing\": {\n                \"kelly\": {\"risk_aversion\": 1.0},\n                \"limits\": {\"max_notional\": 1000.0}\n            }\n        }\n\n        # Mock SPRT that always rejects H0",
    "locations": [
      {
        "file": "tests/integration/test_governance_gate.py",
        "start": 176,
        "end": 195
      },
      {
        "file": "tests/integration/test_governance_gate.py",
        "start": 72,
        "end": 91
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 9,
    "tokens": 0,
    "code_snippet": "events_logged = []\n\n            def mock_log_events(code: str, details: dict):\n                events_logged.append({\"code\": code, \"details\": details})\n\n            with patch(\"skalp_bot.runner.run_live_aurora._log_events\", side_effect=mock_log_events):\n                with patch.dict(os.environ, {\n                    \"DRY_RUN\": \"true\",\n                                                        \"AURORA_MAX_TICKS\": \"1\"",
    "locations": [
      {
        "file": "tests/integration/test_governance_gate.py",
        "start": 207,
        "end": 215
      },
      {
        "file": "tests/integration/test_governance_gate.py",
        "start": 140,
        "end": 148
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 10,
    "tokens": 0,
    "code_snippet": "):\n            events_logged = []\n            \n            def mock_log_events(code: str, details: dict):\n                events_logged.append({\"code\": code, \"details\": details})\n            \n            with patch(\"skalp_bot.runner.run_live_aurora._log_events\", side_effect=mock_log_events):\n                with patch.dict(os.environ, {\n                    \"DRY_RUN\": \"true\",\n                    \"AURORA_MAX_TICKS\": \"2\"",
    "locations": [
      {
        "file": "tests/integration/test_governance_gate.py",
        "start": 254,
        "end": 263
      },
      {
        "file": "tests/integration/test_governance_gate.py",
        "start": 206,
        "end": 148
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 15,
    "tokens": 0,
    "code_snippet": "}):\n                    with patch(\"skalp_bot.runner.run_live_aurora.create_adapter\") as mock_adapter_factory:\n                        mock_adapter = MockAdapter(MockMarketData())\n                        mock_adapter_factory.return_value = mock_adapter\n                        \n                        with patch(\"yaml.safe_load\", return_value=self.test_config):\n                            with patch(\"pathlib.Path.exists\", return_value=True):\n                                with patch(\"pathlib.Path.read_text\", return_value=\"\"):\n                                    try:\n                                        from skalp_bot.runner.run_live_aurora import main\n                                        main(config_path=\"test_config.yaml\")\n                                    except SystemExit:\n                                        pass\n        \n        # Verify governance error events were logged",
    "locations": [
      {
        "file": "tests/integration/test_governance_gate.py",
        "start": 264,
        "end": 278
      },
      {
        "file": "tests/integration/test_governance_gate.py",
        "start": 109,
        "end": 163
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 24,
    "tokens": 0,
    "code_snippet": "events_logged = []\n        \n        def mock_log_events(code: str, details: dict):\n            events_logged.append({\"code\": code, \"details\": details})\n        \n        with patch(\"skalp_bot.runner.run_live_aurora._log_events\", side_effect=mock_log_events):\n            with patch.dict(os.environ, {\n                \"DRY_RUN\": \"true\",\n                \"AURORA_MAX_TICKS\": \"2\"\n            }):\n                with patch(\"skalp_bot.runner.run_live_aurora.create_adapter\") as mock_adapter_factory:\n                    mock_adapter = MockAdapter(MockMarketData())\n                    mock_adapter_factory.return_value = mock_adapter\n                    \n                    with patch(\"yaml.safe_load\", return_value=self.test_config):\n                        with patch(\"pathlib.Path.exists\", return_value=True):\n                            with patch(\"pathlib.Path.read_text\", return_value=\"\"):\n                                try:\n                                    from skalp_bot.runner.run_live_aurora import main\n                                    main(config_path=\"test_config.yaml\")\n                                except SystemExit:\n                                    pass\n        \n        # Find governance events",
    "locations": [
      {
        "file": "tests/integration/test_governance_gate.py",
        "start": 318,
        "end": 341
      },
      {
        "file": "tests/integration/test_governance_gate.py",
        "start": 140,
        "end": 163
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 10,
    "tokens": 0,
    "code_snippet": "):\n                    with patch(\"pathlib.Path.exists\", return_value=True):\n                        with patch(\"pathlib.Path.read_text\", return_value=\"\"):\n                            try:\n                                from skalp_bot.runner.run_live_aurora import main\n                                main(config_path=\"test_config.yaml\")\n                            except SystemExit:\n                                pass  # Expected for test exit\n                            except Exception as e:\n                                pytest.fail(f\"Default config should work: {e}\"",
    "locations": [
      {
        "file": "tests/integration/test_governance_gate.py",
        "start": 376,
        "end": 385
      },
      {
        "file": "tests/integration/test_governance_gate.py",
        "start": 304,
        "end": 313
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 19,
    "tokens": 0,
    "code_snippet": "# CoxPH\r\n        cox = CoxPH()\r\n        cox._beta = {'obi': 0.1, 'spread_bps': -0.05}\r\n        cox._feat = ['obi', 'spread_bps']\r\n        \r\n        # SLA\r\n        sla = SLAGate(max_latency_ms=250, kappa_bps_per_ms=0.01, min_edge_after_bps=1.0)\r\n        \r\n        # Router\r\n        router = Router(\r\n            hazard_model=cox,\r\n            slagate=sla,\r\n            min_p_fill=0.25,\r\n            exchange_name='test'\r\n        )\r\n        \r\n        return router\r\n    \r\n    @pytest",
    "locations": [
      {
        "file": "tests/integration/test_full_b2b7_pipeline.py",
        "start": 46,
        "end": 64
      },
      {
        "file": "tests/unit/test_xai_decision_trail.py",
        "start": 29,
        "end": 47
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 13,
    "tokens": 0,
    "code_snippet": "mock_requests = MagicMock()\r\n        mock_response = MagicMock()\r\n        mock_response.ok = True\r\n        mock_response.json.return_value = {\r\n            \"allow\": True,\r\n            \"max_qty\": 0.001,\r\n            \"reason\": \"Test allow\",\r\n            \"observability\": {\"gate_state\": \"ALLOW\"}\r\n        }\r\n        mock_requests.post.return_value = mock_response\r\n        aurora_gate._requests = mock_requests\r\n        \r\n        # Simulate complete trading cycle",
    "locations": [
      {
        "file": "tests/integration/test_full_b2b7_pipeline.py",
        "start": 291,
        "end": 303
      },
      {
        "file": "tests/integration/test_full_b2b7_pipeline.py",
        "start": 262,
        "end": 274
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 47,
    "tokens": 0,
    "code_snippet": "class MockExchange:\n    \"\"\"Mock exchange implementation with configurable behavior.\"\"\"\n\n    def __init__(self, config: Dict[str, Any]):\n        self.config = config\n        self.orders = {}  # order_id -> order\n        self.fills = {}   # order_id -> list of fills\n        self.reject_next = None\n        self.price_sequence = config.get(\"price_sequence\", [])\n        self.price_index = 0\n\n    def set_fill_profile(self, profile: Dict[str, Any]):\n        \"\"\"Update fill profile dynamically.\"\"\"\n        self.config.update(profile)\n\n    def set_reject_next_order(self, reason: str):\n        \"\"\"Set next order to be rejected.\"\"\"\n        self.reject_next = reason\n\n    def reset_reject_pattern(self):\n        \"\"\"Reset rejection pattern.\"\"\"\n        self.reject_next = None\n\n    def trigger_partial_fill(self, order_id: str, quantity: Decimal, price: Decimal):\n        \"\"\"Manually trigger a partial fill for testing.\"\"\"\n        if order_id not in self.fills:\n            self.fills[order_id] = []\n\n        fill = Fill(\n            price=float(price),\n            qty=float(quantity),\n            fee=float(quantity * price * Decimal(\"0.001\")),  # 0.1% fee\n            fee_asset=\"USDT\",\n            ts_ns=int(time.time() * 1_000_000_000)\n        )\n\n        self.fills[order_id].append(fill)\n\n    async def submit_order(self, order: OrderRequest) -> Dict[str, Any]:\n        \"\"\"Submit order with configurable behavior.\"\"\"\n        # Check for rejection\n        if self.reject_next:\n            reason = self.reject_next\n            self.reject_next = None\n            return {\n                \"status\": \"rejected\",\n                \"order_id\": f\"mock_{order.client_order_id}\"",
    "locations": [
      {
        "file": "tests/fixtures/mock_exchange_factory.py",
        "start": 329,
        "end": 375
      },
      {
        "file": "tests/fixtures/mock_exchange_factory.py",
        "start": 34,
        "end": 80
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 45,
    "tokens": 0,
    "code_snippet": "self.orders[order_id] = order\n\n        # Simulate exchange processing delay\n        latency = self.config.get(\"latency_ms\", 10) / 1000\n        await asyncio.sleep(latency)\n\n        # Determine fill behavior\n        if self.config.get(\"immediate\", True):\n            await self._process_fills(order_id, order)\n        else:\n            # Schedule fills asynchronously\n            asyncio.create_task(self._delayed_fill(order_id, order))\n\n        return {\n            \"status\": \"accepted\",\n            \"order_id\": order_id,\n            \"timestamp\": time.time()\n        }\n\n    async def cancel_order(self, order_id: str) -> Dict[str, Any]:\n        \"\"\"Cancel order.\"\"\"\n        if order_id not in self.orders:\n            return {\"status\": \"not_found\", \"order_id\": order_id}\n\n        # Simulate cancellation delay\n        latency = self.config.get(\"latency_ms\", 10) / 1000\n        await asyncio.sleep(latency)\n\n        # Remove from active orders\n        del self.orders[order_id]\n\n        return {\n            \"status\": \"cancelled\",\n            \"order_id\": order_id,\n            \"timestamp\": time.time()\n        }\n\n    async def get_order_status(self, order_id: str) -> Dict[str, Any]:\n        \"\"\"Get order status.\"\"\"\n        if order_id not in self.orders:\n            return {\"status\": \"not_found\", \"order_id\": order_id}\n\n        order = self.orders[order_id]\n        fills = self.fills.get(order_id, [])\n        filled_qty = sum(f.quantity",
    "locations": [
      {
        "file": "tests/fixtures/mock_exchange_factory.py",
        "start": 382,
        "end": 426
      },
      {
        "file": "tests/fixtures/mock_exchange_factory.py",
        "start": 87,
        "end": 131
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 15,
    "tokens": 0,
    "code_snippet": "for f in fills)\n\n        if filled_qty == 0:\n            status = \"open\"\n        elif filled_qty < order.quantity:\n            status = \"partial_fill\"\n        else:\n            status = \"filled\"\n\n        return {\n            \"order_id\": order_id,\n            \"status\": status,\n            \"filled_quantity\": filled_qty,\n            \"remaining_quantity\": order.quantity - filled_qty,\n            \"fills\": [f.dict",
    "locations": [
      {
        "file": "tests/fixtures/mock_exchange_factory.py",
        "start": 426,
        "end": 440
      },
      {
        "file": "tests/fixtures/mock_exchange_factory.py",
        "start": 131,
        "end": 145
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 21,
    "tokens": 0,
    "code_snippet": "for f in fills]\n        }\n\n    async def get_order_fills(self, order_id: str) -> List[Fill]:\n        \"\"\"Get fills for order.\"\"\"\n        return self.fills.get(order_id, [])\n\n    async def _process_fills(self, order_id: str, order: OrderRequest):\n        \"\"\"Process fills based on configuration.\"\"\"\n        partial_ratios = self.config.get(\"partial\", [1.0])  # Default full fill\n\n        if order_id not in self.fills:\n            self.fills[order_id] = []\n\n        remaining_qty = order.quantity\n\n        for ratio in partial_ratios:\n            if remaining_qty <= 0:\n                break\n\n            fill_qty = remaining_qty * Decimal",
    "locations": [
      {
        "file": "tests/fixtures/mock_exchange_factory.py",
        "start": 440,
        "end": 460
      },
      {
        "file": "tests/fixtures/mock_exchange_factory.py",
        "start": 145,
        "end": 165
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 92,
    "tokens": 0,
    "code_snippet": ",  # 0.1% fee\n                fee_asset=\"USDT\",\n                ts_ns=int(time.time() * 1_000_000_000)\n            )\n\n            self.fills[order_id].append(fill)\n            remaining_qty -= fill_qty\n\n            # Simulate fill delay between partials\n            if len(partial_ratios) > 1:\n                await asyncio.sleep(0.05)\n\n    async def _delayed_fill(self, order_id: str, order: OrderRequest):\n        \"\"\"Process delayed fills.\"\"\"\n        # Wait for configured delay\n        delay = self.config.get(\"delay_ms\", 100) / 1000\n        await asyncio.sleep(delay)\n\n        # Process fills if order still active\n        if order_id in self.orders:\n            await self._process_fills(order_id, order)\n\n\nclass MockExchangeFactory:\n    \"\"\"Factory for creating mock exchanges with different configurations.\"\"\"\n\n    @staticmethod\n    def create_deterministic_exchange(fill_profile: Optional[Dict[str, Any]] = None) -> MockExchange:\n        \"\"\"Create deterministic exchange for predictable testing.\"\"\"\n        config = {\n            \"immediate\": True,\n            \"latency_ms\": 10,\n            \"partial\": [1.0],  # Full fill by default\n            \"price_sequence\": [],\n            **(fill_profile or {})\n        }\n        return MockExchange(config)\n\n    @staticmethod\n    def create_stochastic_exchange(fill_profile: Optional[Dict[str, Any]] = None) -> MockExchange:\n        \"\"\"Create stochastic exchange with random behavior.\"\"\"\n        config = {\n            \"immediate\": True,\n            \"latency_ms\": random.randint(5, 50),\n            \"partial\": MockExchangeFactory._generate_random_partial_ratios(),\n            \"price_variation\": 0.02,  # 2% price variation\n            **(fill_profile or {})\n        }\n        return MockExchange(config)\n\n    @staticmethod\n    def create_slow_exchange(fill_profile: Optional[Dict[str, Any]] = None) -> MockExchange:\n        \"\"\"Create slow exchange for testing timeouts.\"\"\"\n        config = {\n            \"immediate\": False,\n            \"latency_ms\": 200,\n            \"delay_ms\": 500,\n            \"partial\": [1.0],\n            **(fill_profile or {})\n        }\n        return MockExchange(config)\n\n    @staticmethod\n    def create_partial_fill_exchange(fill_profile: Optional[Dict[str, Any]] = None) -> MockExchange:\n        \"\"\"Create exchange that does partial fills.\"\"\"\n        config = {\n            \"immediate\": True,\n            \"latency_ms\": 20,\n            \"partial\": [0.3, 0.4, 0.3],  # Multiple partial fills\n            **(fill_profile or {})\n        }\n        return MockExchange(config)\n\n    @staticmethod\n    def create_rejecting_exchange(reject_rate: float = 0.1, fill_profile: Optional[Dict[str, Any]] = None) -> MockExchange:\n        \"\"\"Create exchange that randomly rejects orders.\"\"\"\n        config = {\n            \"immediate\": True,\n            \"latency_ms\": 15,\n            \"reject_rate\": reject_rate,\n            \"partial\": [1.0],\n            **(fill_profile or {})\n        }\n        exchange = MockExchange(config)\n\n        # Override submit_order to add rejection logic\n        original_submit = exchange.submit_order\n        async def rejecting_submit(order: OrderRequest) -> Dict[str, Any]:\n            if random.random() < reject_rate:\n                return {\n                    \"status\": \"rejected\",\n                    \"order_id\": f\"mock_{order.client_order_id}\"",
    "locations": [
      {
        "file": "tests/fixtures/mock_exchange_factory.py",
        "start": 477,
        "end": 568
      },
      {
        "file": "tests/fixtures/mock_exchange_factory.py",
        "start": 183,
        "end": 274
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 49,
    "tokens": 0,
    "code_snippet": ",\n                    \"reason\": \"RANDOM_REJECT\",\n                    \"timestamp\": time.time()\n                }\n            return await original_submit(order)\n\n        exchange.submit_order = rejecting_submit\n        return exchange\n\n    @staticmethod\n    def create_high_latency_exchange(fill_profile: Optional[Dict[str, Any]] = None) -> MockExchange:\n        \"\"\"Create exchange with high latency for performance testing.\"\"\"\n        config = {\n            \"immediate\": True,\n            \"latency_ms\": 500,  # 500ms latency\n            \"jitter_ms\": 100,   # \u00b1100ms jitter\n            \"partial\": [1.0],\n            **(fill_profile or {})\n        }\n        exchange = MockExchange(config)\n\n        # Override to add jitter\n        original_submit = exchange.submit_order\n        async def jittery_submit(order: OrderRequest) -> Dict[str, Any]:\n            result = await original_submit(order)\n            # Add random jitter\n            jitter = random.uniform(-config[\"jitter_ms\"], config[\"jitter_ms\"]) / 1000\n            await asyncio.sleep(max(0, jitter))\n            return result\n\n        exchange.submit_order = jittery_submit\n        return exchange\n\n    @staticmethod\n    def _generate_random_partial_ratios() -> List[float]:\n        \"\"\"Generate random partial fill ratios that sum to 1.0.\"\"\"\n        num_fills = random.randint(1, 4)\n        ratios = [random.random() for _ in range(num_fills)]\n        total = sum(ratios)\n        return [r / total for r in ratios]\n\n    @staticmethod\n    def create_exchange_with_price_sequence(price_sequence: List[float],\n                                          fill_profile: Optional[Dict[str, Any]] = None) -> MockExchange:\n        \"\"\"Create exchange with specific price sequence for testing.\"\"\"\n        config = {\n            \"immediate\": True,\n            \"latency_ms\": 10,\n            \"partial\": [1.0",
    "locations": [
      {
        "file": "tests/fixtures/mock_exchange_factory.py",
        "start": 568,
        "end": 616
      },
      {
        "file": "tests/fixtures/mock_exchange_factory.py",
        "start": 274,
        "end": 322
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 7,
    "tokens": 0,
    "code_snippet": ",'ece_bad':0.08},\n                'reg':{'trend':1.0,'grind':0.8,'chaos':0.6},\n                'liq':{'spread_bps_breaks':[5,10],'lambdas':[1.0,0.8,0.6]},\n                'dd': {'dd_warn':0.05,'dd_bad':0.10,'lambdas':[1.0,0.7,0.4]},\n                'lat':{'p95_ms_breaks':[200,500],'lambdas':[1.0,0.8,0.6]},\n            }\n        },",
    "locations": [
      {
        "file": "tests/execution/test_sizing_orchestrator_effect.py",
        "start": 26,
        "end": 32
      },
      {
        "file": "tests/risk/test_lambda_orchestrator.py",
        "start": 5,
        "end": 10
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 11,
    "tokens": 0,
    "code_snippet": "def mk_market():\n    return MarketSpec(\n        tick_size=Decimal('0.01'), lot_size=Decimal('0.1'), min_notional=Decimal('10'),\n        maker_fee_bps=1, taker_fee_bps=5, best_bid=Decimal('100'), best_ask=Decimal('100.1'),\n        spread_bps=1.0, mid=Decimal('100.05')\n    )\n\n\ndef mk_intent(stop_bps=100, qty_hint=None, equity=Decimal('10000')):\n    return OrderIntent(\n        intent_id='t1'",
    "locations": [
      {
        "file": "tests/execution/test_sizing_orchestrator_effect.py",
        "start": 37,
        "end": 47
      },
      {
        "file": "tests/obs/test_metrics_exposition.py",
        "start": 9,
        "end": 19
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 6,
    "tokens": 0,
    "code_snippet": ", expected_return_bps=40, post_only=True)\n    mspec = market_spec_factory(tick_size='0.10', best_bid='30000', best_ask='30000.6')\n    monkeypatch.setattr(RouterV2, '_p_fill', lambda self, f, s: Decimal('0.8'))\n    res = svc.place(intent=intent, market=mspec, features={}, measured_latency_ms=20)\n    if not isinstance(res, DenyDecision) and res.mode == 'maker' and res.price:\n        assert Decimal(str(res.price)) >=",
    "locations": [
      {
        "file": "tests/execution/test_post_only_sim.py",
        "start": 16,
        "end": 21
      },
      {
        "file": "tests/execution/test_post_only_sim.py",
        "start": 7,
        "end": 12
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 16,
    "tokens": 0,
    "code_snippet": "]},\n            }\n        },\n        'execution':{'sla':{'p95_ms':200}}\n    }\n\n\ndef mk_market():\n    return MarketSpec(\n        tick_size=Decimal('0.01'), lot_size=Decimal('0.1'), min_notional=Decimal('10'),\n        maker_fee_bps=1, taker_fee_bps=5, best_bid=Decimal('100'), best_ask=Decimal('100.1'),\n        spread_bps=1.0, mid=Decimal('100.05')\n    )\n\n\ndef mk_intent(equity",
    "locations": [
      {
        "file": "tests/execution/test_portfolio_correlation_effect.py",
        "start": 33,
        "end": 48
      },
      {
        "file": "tests/execution/test_sizing_orchestrator_effect.py",
        "start": 30,
        "end": 17
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 6,
    "tokens": 0,
    "code_snippet": ")\n    spread_bps=float((best_ask-best_bid)/((best_ask+best_bid)/2)*10000)\n    return MarketSpec(tick_size=Decimal('0.01'), lot_size=Decimal('0.001'), min_notional=Decimal('5'),\n                      maker_fee_bps=0, taker_fee_bps=5, best_bid=best_bid, best_ask=best_ask, spread_bps=spread_bps, mid=mid)\n\ndef _router",
    "locations": [
      {
        "file": "tests/execution/test_low_pfill_deny.py",
        "start": 14,
        "end": 19
      },
      {
        "file": "tests/execution/test_post_only_unavailable.py",
        "start": 18,
        "end": 24
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 9,
    "tokens": 0,
    "code_snippet": "def mk_market():\n    return MarketSpec(\n        tick_size=Decimal('0.01'), lot_size=Decimal('0.1'), min_notional=Decimal('10'),\n        maker_fee_bps=1, taker_fee_bps=5, best_bid=Decimal('100'), best_ask=Decimal('100.1'),\n        spread_bps=1.0, mid=Decimal('100.05')\n    )\n\n\ndef test_cvar_gate_zeroes_qty_and_emits_shift",
    "locations": [
      {
        "file": "tests/execution/test_cvar_gate_evt.py",
        "start": 6,
        "end": 14
      },
      {
        "file": "tests/obs/test_metrics_exposition.py",
        "start": 9,
        "end": 17
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 12,
    "tokens": 0,
    "code_snippet": "from decimal import Decimal\nfrom core.risk.sizing_orchestrator import SizingOrchestrator\nfrom core.execution.router_v2 import MarketSpec, OrderIntent\nfrom core.aurora_event_logger import AuroraEventLogger\n\n\ndef _market():\n    return MarketSpec(tick_size=Decimal('0.01'), lot_size=Decimal('0.001'), min_notional=Decimal('5'),\n                      maker_fee_bps=0, taker_fee_bps=5, best_bid=Decimal('99.99'), best_ask=Decimal('100.01'), spread_bps=2.0, mid=Decimal('100'))\n\n\ndef _intent(equity_usd:str,",
    "locations": [
      {
        "file": "tests/execution/test_cvar_feedback_stub.py",
        "start": 1,
        "end": 12
      },
      {
        "file": "tests/execution/test_sizing_kelly_min_notional.py",
        "start": 1,
        "end": 12
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 10,
    "tokens": 0,
    "code_snippet": "import pytest\nimport asyncio\nimport time\nfrom decimal import Decimal\nfrom unittest.mock import Mock, AsyncMock, patch\nfrom typing import Dict, Any, List\n\nfrom tests.fixtures.mock_exchange_factory import MockExchangeFactory\nfrom core.execution.exchange.common import OrderRequest, Fill, Side, OrderType\nfrom",
    "locations": [
      {
        "file": "tests/e2e/test_trade_flow_simulator.py",
        "start": 13,
        "end": 22
      },
      {
        "file": "tests/integration/oms/test_order_lifecycle.py",
        "start": 9,
        "end": 17
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 38,
    "tokens": 0,
    "code_snippet": "def make_client(tmp_path) -> TestClient:\n    \"\"\"Create test client with isolated environment\"\"\"\n    os.environ['AURORA_API_TOKEN'] = 'test_token_12345678901234567890'\n    os.environ['AURORA_IP_ALLOWLIST'] = '127.0.0.1'\n    os.chdir(tmp_path)\n\n    import api.service as svc\n    importlib.reload(svc)\n    return TestClient(svc.app)\n\n\ndef setup_app_state(client):\n    \"\"\"Setup minimal app state for testing\"\"\"\n    app = client.app\n\n    # Initialize basic state attributes\n    if not hasattr(app.state, 'cfg'):\n        app.state.cfg = {'test': 'config'}\n    if not hasattr(app.state, 'trading_system'):\n        app.state.trading_system = None\n    if not hasattr(app.state, 'governance'):\n        from aurora.governance import Governance\n        app.state.governance = Governance()\n    if not hasattr(app.state, 'events_emitter'):\n        app.state.events_emitter = MagicMock()\n    if not hasattr(app.state, 'last_event_ts'):\n        app.state.last_event_ts = None\n    if not hasattr(app.state, 'session_dir'):\n        from pathlib import Path\n        app.state.session_dir = Path('logs')\n\n    return app\n\n\nclass TestBasicEndpoints:\n    \"\"\"Test basic API endpoints that don't require complex setup\"\"\"\n\n    def test_root_endpoint_redirects_to_docs",
    "locations": [
      {
        "file": "tests/api/test_basic_endpoints.py",
        "start": 8,
        "end": 45
      },
      {
        "file": "tests/api/test_basic_endpoints_new.py",
        "start": 9,
        "end": 46
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 24,
    "tokens": 0,
    "code_snippet": ")\n        response = client.get('/version')\n        assert response.status_code == 200\n        data = response.json()\n        assert 'version' in data\n        assert isinstance(data['version'], str)\n\n    def test_health_endpoint_with_models_loaded(self, tmp_path):\n        \"\"\"Test health endpoint when models are loaded\"\"\"\n        client = make_client(tmp_path)\n        setup_app_state(client)\n\n        # Mock trading system as loaded\n        with patch.object(client.app.state, 'trading_system') as mock_ts:\n            mock_ts.student = MagicMock()\n            mock_ts.router = MagicMock()\n\n            response = client.get('/health')\n            assert response.status_code == 200\n            data = response.json()\n            assert data['status'] == 'healthy'\n            assert data['models_loaded'] is True\n\n    def",
    "locations": [
      {
        "file": "tests/api/test_basic_endpoints.py",
        "start": 57,
        "end": 80
      },
      {
        "file": "tests/api/test_basic_endpoints_new.py",
        "start": 56,
        "end": 78
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 11,
    "tokens": 0,
    "code_snippet": "def test_health_endpoint_with_models_not_loaded(self, tmp_path):\n        \"\"\"Test health endpoint when models are not loaded\"\"\"\n        client = make_client(tmp_path)\n        setup_app_state(client)\n\n        # Mock trading system as not loaded\n        with patch.object(client.app.state, 'trading_system', None):\n            response = client.get('/health')\n            assert response.status_code == 200\n            data = response.json()\n            assert data['status'] == 'starting'  # Status is 'starting' when models not loaded",
    "locations": [
      {
        "file": "tests/api/test_basic_endpoints.py",
        "start": 80,
        "end": 90
      },
      {
        "file": "tests/api/test_basic_endpoints_new.py",
        "start": 80,
        "end": 91
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 12,
    "tokens": 0,
    "code_snippet": ")\n            except Exception as e:\n                error_msg = str(e)\n                why_code = \"WHY_EX_REJECT\"\n                if \"rate limit\" in error_msg.lower():\n                    why_code = \"WHY_RATE_LIMIT\"\n                elif \"timeout\" in error_msg.lower() or \"connection\" in error_msg.lower():\n                    why_code = \"WHY_CONN_ERR\"\n                \n                _log_events(\"ORDER.REJECT\", {\n                    \"details\": {\n                        \"close\"",
    "locations": [
      {
        "file": "skalp_bot/runner/run_live_aurora.py",
        "start": 553,
        "end": 564
      },
      {
        "file": "skalp_bot/runner/run_live_aurora.py",
        "start": 505,
        "end": 516
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 13,
    "tokens": 0,
    "code_snippet": "def _quantile(xs: List[float], q: float) -> float:\r\n    if not xs:\r\n        return 0.0\r\n    q = 0.0 if q < 0.0 else 1.0 if q > 1.0 else q\r\n    xs2 = sorted(xs)\r\n    pos = q * (len(xs2) - 1)\r\n    lo = int(pos)\r\n    hi = min(lo + 1, len(xs2) - 1)\r\n    frac = pos - lo\r\n    return xs2[lo] * (1 - frac) + xs2[hi] * frac\r\n\r\n\r\nclass",
    "locations": [
      {
        "file": "core/universe/ranking.py",
        "start": 63,
        "end": 75
      },
      {
        "file": "core/xai/alerts.py",
        "start": 65,
        "end": 77
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 19,
    "tokens": 0,
    "code_snippet": ",\n            time_to_first_fill_ms=0.0,\n            total_execution_time_ms=0.0,\n            fill_ratio=0.0,\n            maker_fill_ratio=0.0,\n            taker_fill_ratio=0.0,\n            avg_queue_position=None,\n            raw_edge_bps=0.0,\n            fees_bps=0.0,\n            slippage_in_bps=0.0,\n            slippage_out_bps=0.0,\n            adverse_bps=0.0,\n            latency_bps=0.0,\n            impact_bps=0.0,\n            rebate_bps=0.0,\n            implementation_shortfall_bps=0.0,\n            realized_spread_bps=0.0,\n            effective_spread_bps=0.0,\n            analysis_ts_ns=int(time.time_ns()),",
    "locations": [
      {
        "file": "core/tca/tca_analyzer.py",
        "start": 427,
        "end": 445
      },
      {
        "file": "core/tca/tca_analyzer.py",
        "start": 140,
        "end": 159
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 16,
    "tokens": 0,
    "code_snippet": "from __future__ import annotations\r\n\r\nfrom dataclasses import dataclass\r\nfrom typing import Deque, Dict, Iterable, List, Optional, Sequence, Tuple\r\nimport bisect\r\nimport math\r\nimport random\r\nfrom collections import deque\r\n\r\ntry:\r\n    import numpy as np  # type: ignore\r\nexcept Exception:  # pragma: no cover\r\n    np = None  # type: ignore\r\n\r\n# =============================\r\n# Empirical VaR / CVaR",
    "locations": [
      {
        "file": "core/risk/cvar.py",
        "start": 18,
        "end": 33
      },
      {
        "file": "core/risk/evt_pot.py",
        "start": 25,
        "end": 40
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 13,
    "tokens": 0,
    "code_snippet": "def _quantile(xs: List[float], q: float) -> float:\r\n    if not xs:\r\n        return 0.0\r\n    q = 0.0 if q < 0.0 else 1.0 if q > 1.0 else q\r\n    xs2 = sorted(xs)\r\n    pos = q * (len(xs2) - 1)\r\n    lo = int(pos)\r\n    hi = min(lo + 1, len(xs2) - 1)\r\n    frac = pos - lo\r\n    return xs2[lo] * (1 - frac) + xs2[hi] * frac\r\n\r\n\r\n@dataclass",
    "locations": [
      {
        "file": "core/regime/manager.py",
        "start": 40,
        "end": 52
      },
      {
        "file": "core/xai/alerts.py",
        "start": 65,
        "end": 77
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 12,
    "tokens": 0,
    "code_snippet": "ssl_context = ssl.create_default_context()\n        \n        try:\n            async with websockets.connect(url, ssl=ssl_context) as websocket:\n                self._log_event(\"WS.CONNECT\", {\"url\": url, \"symbol\": symbol}, symbol.upper())\n                \n                while self._running:\n                    try:\n                        message = await asyncio.wait_for(websocket.recv(), timeout=30)\n                        data = json.loads(message)\n                        \n                        # Binance sends event type in 'e' field",
    "locations": [
      {
        "file": "core/market/websocket_client.py",
        "start": 145,
        "end": 156
      },
      {
        "file": "core/market/websocket_client.py",
        "start": 107,
        "end": 118
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 14,
    "tokens": 0,
    "code_snippet": "def now_ns(self) -> int:\r\n        return time.perf_counter_ns()\r\n\r\n    def sleep_until_wall_ns(self, target_wall_ns: int) -> None:\r\n        remaining = target_wall_ns - self.now_ns()\r\n        if remaining > 0:\r\n            # Apply max_sleep_ns clamp if configured\r\n            if self.max_sleep_ns is not None and remaining > self.max_sleep_ns:\r\n                actual_target = self.now_ns() + self.max_sleep_ns\r\n                time.sleep(_ns_to_seconds(self.max_sleep_ns))\r\n            else:\r\n                time.sleep(_ns_to_seconds(remaining))\r\n\r\n    def",
    "locations": [
      {
        "file": "core/ingestion/sync_clock.py",
        "start": 136,
        "end": 149
      },
      {
        "file": "core/ingestion/sync_clock.py",
        "start": 86,
        "end": 99
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 6,
    "tokens": 0,
    "code_snippet": "(alpha: float = 0.05, mu0: float = 0.0, mu1: float = 0.1, beta: float = 0.2, min_samples: int = 5, max_samples: Optional[int] = None) -> \"CompositeSPRT\":\n    cfg = SPRTConfig(mu0=mu0, mu1=mu1, alpha=alpha, beta=beta, min_samples=min_samples, max_samples=max_samples)\n    return CompositeSPRT(cfg)\n\n\ndef create_sprt_bh_fdr",
    "locations": [
      {
        "file": "core/governance/sprt_glr.py",
        "start": 262,
        "end": 267
      },
      {
        "file": "core/governance/sprt_glr.py",
        "start": 257,
        "end": 262
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 6,
    "tokens": 0,
    "code_snippet": "(alpha: float = 0.05, mu0: float = 0.0, mu1: float = 0.1, beta: float = 0.2, min_samples: int = 5, max_samples: Optional[int] = None) -> \"CompositeSPRT\":\n    cfg = SPRTConfig(mu0=mu0, mu1=mu1, alpha=alpha, beta=beta, min_samples=min_samples, max_samples=max_samples)\n    return CompositeSPRT(cfg)\n\n\n__all__",
    "locations": [
      {
        "file": "core/governance/sprt_glr.py",
        "start": 267,
        "end": 272
      },
      {
        "file": "core/governance/sprt_glr.py",
        "start": 257,
        "end": 262
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 11,
    "tokens": 0,
    "code_snippet": "AlphaTxn(\n                ts_ns_mono=txn.ts_ns_mono,\n                ts_ns_wall=txn.ts_ns_wall,\n                test_id=txn.test_id,\n                alpha0=txn.alpha0,\n                spent=txn.spent,\n                outcome=txn.outcome,\n                token=txn.token,\n                history=list(txn.history),\n                closed_ts_ns=txn.closed_ts_ns,\n            ) for",
    "locations": [
      {
        "file": "core/governance/alpha_ledger.py",
        "start": 305,
        "end": 315
      },
      {
        "file": "core/governance/alpha_ledger.py",
        "start": 283,
        "end": 295
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 8,
    "tokens": 0,
    "code_snippet": ")\n        size = max(0.1, 10.0 + random.gauss(0.0, 3.0))\n        ts += max(0.0, random.expovariate(20.0))\n        out.append(Trade(timestamp=ts, price=100.0, size=size, side=Side.BUY if is_buy else Side.SELL))\n    return out\n\n\ndef _test_event_time_tfi_vpin",
    "locations": [
      {
        "file": "core/features/tfi.py",
        "start": 217,
        "end": 224
      },
      {
        "file": "core/features/tfi.py",
        "start": 203,
        "end": 210
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 21,
    "tokens": 0,
    "code_snippet": "@dataclass\n    class Trade:\n        timestamp: float\n        price: float\n        size: float\n        side: Side\n\n    @dataclass\n    class MarketSnapshot:\n        timestamp: float\n        bid_price: float\n        ask_price: float\n        bid_volumes_l: Sequence[float]\n        ask_volumes_l: Sequence[float]\n        trades: Sequence[Trade]\n\n        @property\n        def mid(self) -> float:\n            return 0.5 * (self.bid_price + self.ask_price)\n\n        @",
    "locations": [
      {
        "file": "core/features/microstructure.py",
        "start": 39,
        "end": 59
      },
      {
        "file": "core/signal/leadlag_hy.py",
        "start": 42,
        "end": 62
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 10,
    "tokens": 0,
    "code_snippet": ".append(MarketSnapshot(\r\n            timestamp=ts,\r\n            bid_price=bid,\r\n            ask_price=ask,\r\n            bid_volumes_l=[qb, 400, 300, 200, 100],\r\n            ask_volumes_l=[qa, 380, 280, 180, 80],\r\n            trades=tuple(tr for tr in trades if ts - tr.timestamp <= 5.0),\r\n        ))\r\n    \r\n    ab_high",
    "locations": [
      {
        "file": "core/features/absorption.py",
        "start": 369,
        "end": 378
      },
      {
        "file": "core/features/absorption.py",
        "start": 269,
        "end": 277
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 14,
    "tokens": 0,
    "code_snippet": "evt = {\r\n                        'order_id': oid,\r\n                        'ts': time.strftime('%Y-%m-%dT%H:%M:%S') + 'Z',\r\n                        'side': o.get('side'),\r\n                        'px': None,\r\n                        'qty': o['orig_qty'],\r\n                        'status': status,\r\n                        'reason': reason,\r\n                        'latency_ms_action': latency_action,\r\n                        'latency_ms_fill': None,\r\n                        'maker_queue_pos': None,\r\n                        'fill_qty_step': 0.0,\r\n                        'fill_ratio': 0.0,\r\n                        'slip_bps': None",
    "locations": [
      {
        "file": "core/execution/sim_local_sink.py",
        "start": 167,
        "end": 180
      },
      {
        "file": "core/execution/sim_local_sink.py",
        "start": 143,
        "end": 156
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 12,
    "tokens": 0,
    "code_snippet": ",\r\n                        'latency_ms_fill': None,\r\n                        'maker_queue_pos': None,\r\n                        'fill_qty_step': 0.0,\r\n                        'fill_ratio': 0.0,\r\n                        'slip_bps': None,\r\n                        'ttl_ms': self.ttl_ms,\r\n                    }\r\n                    self._emit_seed_if_needed(evt)\r\n                    self._ev.emit('ORDER_STATUS(sim)', evt)\r\n                    del self._orders[oid]\r\n                continue",
    "locations": [
      {
        "file": "core/execution/sim_local_sink.py",
        "start": 331,
        "end": 342
      },
      {
        "file": "core/execution/sim_local_sink.py",
        "start": 111,
        "end": 122
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 27,
    "tokens": 0,
    "code_snippet": "if e_maker > 0.0 and p_fill >= self._min_p:\n                return RouteDecision(\n                    route=\"maker\",\n                    e_maker_bps=e_maker,\n                    e_taker_bps=e_taker,\n                    p_fill=p_fill,\n                    reason=f\"SLA denied taker, fallback to maker (E_maker={e_maker:.2f}bps, Pfill={p_fill:.2f})\",\n                    maker_fee_bps=self._fees.maker_fee_bps,\n                    taker_fee_bps=self._fees.taker_fee_bps,\n                    net_e_maker_bps=e_maker,\n                    net_e_taker_bps=e_taker,\n                    scores={\"expected_maker_bps\": e_maker, \"taker_bps\": e_taker, \"p_fill\": p_fill}\n                )\n\n            # Special-case: if P(fill) is very low (below taker threshold) but taker\n            # edge is positive, prefer taker despite SLA edge floor. Tests rely on\n            # this behaviour for low-P scenarios.\n            if p_fill < p_taker_threshold and e_taker > 0.0:\n                return RouteDecision(\n                    route=\"taker\",\n                    e_maker_bps=e_maker,\n                    e_taker_bps=e_taker,\n                    p_fill=p_fill,\n                    reason=f\"Low Pfill {p_fill:.2f} < {p_taker_threshold:.2f}; override SLA and prefer taker (E_taker={e_taker:.2f})\",\n                    maker_fee_bps=self._fees.maker_fee_bps,\n                    taker_fee_bps=self._fees.taker_fee_bps,\n                    net_e_maker_bps=e_taker",
    "locations": [
      {
        "file": "core/execution/router_backup.py",
        "start": 247,
        "end": 273
      },
      {
        "file": "core/execution/router_backup.py",
        "start": 215,
        "end": 241
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 37,
    "tokens": 0,
    "code_snippet": ",\n                maker_fee_bps=self._fees.maker_fee_bps,\n                taker_fee_bps=self._fees.taker_fee_bps,\n                net_e_maker_bps=maker_net,\n                net_e_taker_bps=taker_net,\n                scores={\"expected_maker_bps\": exp_maker, \"taker_bps\": taker_net, \"p_fill\": p_fill},\n            )\n\n        # Standard decision logic: choose route with higher expected edge\n        if taker_net >= exp_maker and taker_net > 0.0:\n            return RouteDecision(\n                route=\"taker\",\n                e_maker_bps=e_maker,\n                e_taker_bps=e_taker,\n                p_fill=p_fill,\n                reason=f\"E_taker {taker_net:.2f} \u2265 E_maker {exp_maker:.2f}; SLA OK\",\n                maker_fee_bps=self._fees.maker_fee_bps,\n                taker_fee_bps=self._fees.taker_fee_bps,\n                net_e_maker_bps=maker_net,\n                net_e_taker_bps=taker_net,\n                scores={\"expected_maker_bps\": exp_maker, \"taker_bps\": taker_net, \"p_fill\": p_fill}\n            )\n        if exp_maker > taker_net and exp_maker > 0.0 and p_fill >= self._min_p:\n            return RouteDecision(\n                route=\"maker\",\n                e_maker_bps=e_maker,\n                e_taker_bps=e_taker,\n                p_fill=p_fill,\n                reason=f\"E_maker {exp_maker:.2f} > E_taker {taker_net:.2f}; Pfill {p_fill:.2f} \u2265 {self._min_p:.2f}\",\n                maker_fee_bps=self._fees.maker_fee_bps,\n                taker_fee_bps=self._fees.taker_fee_bps,\n                net_e_maker_bps=maker_net,\n                net_e_taker_bps=taker_net,\n                scores={\"expected_maker_bps\": exp_maker, \"taker_bps\": taker_net, \"p_fill\": p_fill}\n            )\n\n        # None attractive - use correct net edges in the denial message",
    "locations": [
      {
        "file": "core/execution/router_backup.py",
        "start": 361,
        "end": 397
      },
      {
        "file": "core/execution/router_backup.py",
        "start": 309,
        "end": 345
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 17,
    "tokens": 0,
    "code_snippet": "def _clip01(x: float) -> float:\n    return 0.0 if x < 0.0 else (1.0 if x > 1.0 else x)\n\n\ndef _estimate_p_fill(fill_features: Dict[str, Any]) -> float:\n    \"\"\"\n    \u041f\u0440\u043e\u0441\u0442\u0438\u0439, \u0434\u0435\u0442\u0435\u0440\u043c\u0456\u043d\u043e\u0432\u0430\u043d\u0438\u0439 \u0435\u0441\u0442\u0456\u043c\u0430\u0442\u043e\u0440 P(fill) \u0456\u0437 \u043e\u0437\u043d\u0430\u043a:\n    - OBI in [-1,1] \u0437\u0431\u0456\u043b\u044c\u0448\u0443\u0454 P\n    - spread_bps \u0437\u043c\u0435\u043d\u0448\u0443\u0454 P (5 bps ~ -0.25 \u0434\u043e P)\n    \"\"\"\n    obi = float(fill_features.get(\"obi\", 0.0))\n    spread_bps = float(fill_features.get(\"spread_bps\", 0.0))\n    p = 0.5 + 0.5 * obi - 0.05 * spread_bps\n    return _clip01(p)\n\n\nclass XaiLogger",
    "locations": [
      {
        "file": "core/execution/router.py",
        "start": 66,
        "end": 82
      },
      {
        "file": "core/execution/router_new.py",
        "start": 14,
        "end": 30
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 14,
    "tokens": 0,
    "code_snippet": ".get(\"sla\", {})\n        \n        self.edge_floor_bps: float = float(ex.get(\"edge_floor_bps\", 0.0))\n        self.p_min_fill: float = float(r.get(\"p_min_fill\", 0.25))\n        self.horizon_ms: int = int(r.get(\"horizon_ms\", 1500))\n        self.kappa_bps_per_ms: float = float(sla.get(\"kappa_bps_per_ms\", 0.0))\n        self.max_latency_ms: float = float(sla.get(\"max_latency_ms\", float(\"inf\")))\n        \n        # \u0434\u043e\u0434\u0430\u0442\u043a\u043e\u0432\u0456 \u043f\u043e\u0440\u043e\u0433\u0438\n        self.spread_deny_bps: float = float(r.get(\"spread_deny_bps\", 8.0))\n        self.maker_spread_ok_bps: float = float(r.get(\"maker_spread_ok_bps\", 2.0))\n        self.switch_margin_bps: float = float(r.get(\"switch_margin_bps\", 0.0))\n\n    def _init_from_modules",
    "locations": [
      {
        "file": "core/execution/router.py",
        "start": 131,
        "end": 144
      },
      {
        "file": "core/execution/router_new.py",
        "start": 49,
        "end": 62
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 14,
    "tokens": 0,
    "code_snippet": "from core.config.loader import get_config, ConfigError\r\nfrom core.execution.exchange.common import Fees\r\nfrom core.tca.hazard_cox import CoxPH\r\nfrom core.tca.latency import SLAGate\r\n\r\n\r\n@dataclass\r\nclass QuoteSnapshot:\r\n    bid_px: float\r\n    ask_px: float\r\n    bid_sz: float = 0.0\r\n    ask_sz: float = 0.0\r\n    ts_ns: int = 0\r\n    spread_bps",
    "locations": [
      {
        "file": "core/execution/enhanced_router.py",
        "start": 21,
        "end": 34
      },
      {
        "file": "core/execution/router_backup.py",
        "start": 41,
        "end": 55
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 10,
    "tokens": 0,
    "code_snippet": "def __init__(\r\n        self,\r\n        *,\r\n        hazard_model: Optional[CoxPH] = None,\r\n        slagate: Optional[SLAGate] = None,\r\n        min_p_fill: Optional[float] = None,\r\n        fees: Optional[Fees] = None,\r\n        exchange_name: str = \"default\",\r\n    ) -> None:\r\n        # Core components",
    "locations": [
      {
        "file": "core/execution/enhanced_router.py",
        "start": 82,
        "end": 91
      },
      {
        "file": "core/execution/router_backup.py",
        "start": 82,
        "end": 91
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 12,
    "tokens": 0,
    "code_snippet": "def _flatten(d: Mapping[str, Any], prefix: str = \"\") -> Dict[str, Any]:\r\n    out: Dict[str, Any] = {}\r\n    for k, v in d.items():\r\n        key = f\"{prefix}.{k}\" if prefix else k\r\n        if isinstance(v, Mapping):\r\n            out.update(_flatten(v, key))\r\n        else:\r\n            out[key] = v\r\n    return out\r\n\r\n\r\ndef diff_dicts",
    "locations": [
      {
        "file": "core/config/hotreload.py",
        "start": 35,
        "end": 46
      },
      {
        "file": "core/config/loader.py",
        "start": 87,
        "end": 97
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 10,
    "tokens": 0,
    "code_snippet": "a = _flatten(old)\r\n    b = _flatten(new)\r\n    changed: Set[str] = set()\r\n    keys = set(a.keys()).union(b.keys())\r\n    for k in keys:\r\n        if a.get(k) != b.get(k):\r\n            changed.add(k)\r\n    return changed\r\n\r\n# -------------------- Policy --------------------",
    "locations": [
      {
        "file": "core/config/hotreload.py",
        "start": 48,
        "end": 57
      },
      {
        "file": "core/config/loader.py",
        "start": 98,
        "end": 107
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 9,
    "tokens": 0,
    "code_snippet": "{\r\n                \"orders_placed\": self.metrics.orders_placed,\r\n                \"orders_filled\": self.metrics.orders_filled,\r\n                \"orders_cancelled\": self.metrics.orders_cancelled,\r\n                \"total_volume_usd\": self.metrics.total_volume_usd,\r\n                \"total_pnl_usd\": self.metrics.total_pnl_usd,\r\n                \"cancel_ratio\": self.metrics.cancel_ratio,\r\n                \"maker_fill_ratio\": self.metrics.maker_fill_ratio,\r\n                \"kill_switches_triggered\"",
    "locations": [
      {
        "file": "core/canary/canary_system.py",
        "start": 353,
        "end": 361
      },
      {
        "file": "core/canary/canary_system.py",
        "start": 274,
        "end": 282
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 9,
    "tokens": 0,
    "code_snippet": "def __init__(self, source_dir: str, test_command: str, timeout: int = 30):\n        self.source_dir = Path(source_dir)\n        self.test_command = test_command\n        self.timeout = timeout\n        self.mutants_created = 0\n        self.mutants_killed = 0\n        self.mutants_survived = 0\n\n    def get_python_files",
    "locations": [
      {
        "file": "tools/simple_mutator.py",
        "start": 21,
        "end": 29
      },
      {
        "file": "tools/ultra_simple_mutator.py",
        "start": 21,
        "end": 29
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 23,
    "tokens": 0,
    "code_snippet": "# Calculate results\n        mutation_score = (self.mutants_killed / self.mutants_created * 100) if self.mutants_created > 0 else 0\n\n        results = {\n            \"total_files\": len(python_files),\n            \"total_mutants\": self.mutants_created,\n            \"killed_mutants\": self.mutants_killed,\n            \"survived_mutants\": self.mutants_survived,\n            \"mutation_score\": round(mutation_score, 2),\n            \"timestamp\": time.time()\n        }\n\n        print(\"\\n\ud83d\udcca Mutation Testing Results:\")\n        print(f\"   Total mutants: {results['total_mutants']}\")\n        print(f\"   Killed: {results['killed_mutants']}\")\n        print(f\"   Survived: {results['survived_mutants']}\")\n        print(f\"   Mutation score: {results['mutation_score']}%\")\n\n        return results\n\ndef main():\n    if len(sys.argv) < 3:\n        print(\"Usage: python simple_mutator.py <source_dir> <test_command>\"",
    "locations": [
      {
        "file": "tools/simple_mutator.py",
        "start": 209,
        "end": 231
      },
      {
        "file": "tools/ultra_simple_mutator.py",
        "start": 317,
        "end": 339
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 14,
    "tokens": 0,
    "code_snippet": "import argparse\nimport os\nimport subprocess\nimport sys\nimport time\nfrom pathlib import Path\n\n# Add project root to path\nROOT = Path(__file__).resolve().parent.parent\nif str(ROOT) not in sys.path:\n    sys.path.insert(0, str(ROOT))\n\n\ndef",
    "locations": [
      {
        "file": "tools/run_canary.py",
        "start": 13,
        "end": 26
      },
      {
        "file": "tools/run_live_testnet.py",
        "start": 17,
        "end": 29
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 17,
    "tokens": 0,
    "code_snippet": "import os\n        \n        filepath = self.session_dir / filename\n        \n        if not filepath.exists():\n            return\n        \n        # Get current file size\n        current_size = os.path.getsize(filepath)\n        last_pos = self.file_positions.get(filename, 0)\n        \n        # Check for file rotation (file became smaller)\n        if current_size < last_pos:\n            last_pos = 0  # Reset position\n        \n        try:\n            async",
    "locations": [
      {
        "file": "tools/live_feed.py",
        "start": 226,
        "end": 242
      },
      {
        "file": "tools/live_feed.py",
        "start": 195,
        "end": 210
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 12,
    "tokens": 0,
    "code_snippet": "try:\n                out = subprocess.check_output([\"netstat\", \"-ano\"], creationflags=0x08000000).decode(errors='ignore')\n                pids = []\n                for line in out.splitlines():\n                    if f\":{port} \" in line and \"LISTENING\" in line.upper():\n                        parts = line.split()\n                        if parts:\n                            pids.append(parts[-1])\n                for pid in set(pids):\n                    try:\n                        subprocess.call([\"taskkill\", \"/PID\", pid, \"/F\", \"/T\"], creationflags=0x08000000)\n                        killed",
    "locations": [
      {
        "file": "tools/auroractl.py",
        "start": 169,
        "end": 180
      },
      {
        "file": "tools/auroractl.py",
        "start": 57,
        "end": 68
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 12,
    "tokens": 0,
    "code_snippet": "f_raw = kelly_binary(p_cal, rr, risk_aversion=1.0, clip=(0.0, 0.2))\r\n        notional_target = f_raw * equity\r\n\r\n        # Mock exchange filters\r\n        px = 50000.0\r\n        lot_step = 0.00001\r\n        min_notional = 10.0\r\n        max_notional = 5000.0\r\n\r\n        qty = fraction_to_qty(notional_target, px, lot_step, min_notional, max_notional)\r\n\r\n        # Should return the correctly calculated quantity",
    "locations": [
      {
        "file": "tests/test_sizing_live_integration.py",
        "start": 66,
        "end": 77
      },
      {
        "file": "tests/test_sizing_live_integration.py",
        "start": 28,
        "end": 39
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 12,
    "tokens": 0,
    "code_snippet": "import time\n        stabilizer = SizingStabilizer(min_resize_interval_sec=1.0)\n        \n        # Set last resize time to past\n        stabilizer.last_resize_time = time.monotonic() - 2.0\n        \n        # Call stabilize_fraction with different target and current to trigger line 540\n        result, metadata = stabilizer.stabilize_fraction(0.2, 0.1, apply_time_guard=True)\n        assert result == 0.2  # Should accept the change\n        assert metadata[\"final_fraction\"] == 0.2\n\n    def test_kelly_binary_safety_check_line_79",
    "locations": [
      {
        "file": "tests/test_sizing_kelly.py",
        "start": 896,
        "end": 907
      },
      {
        "file": "tests/test_sizing_kelly.py",
        "start": 852,
        "end": 863
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 16,
    "tokens": 0,
    "code_snippet": "def test_portfolio_kelly_numpy_solve_exception_lines_434_442(self):\n        \"\"\"Test portfolio_kelly numpy solve exception handling (lines 434-442).\"\"\"\n        from unittest.mock import patch\n        import core.sizing.kelly as kelly_mod\n        \n        # Mock numpy.linalg.solve to raise an exception\n        with patch('numpy.linalg.solve', side_effect=Exception(\"Solve failed\")), \\\n             patch('numpy.linalg.pinv') as mock_pinv:\n            mock_pinv.return_value.dot.return_value = [0.5, 0.5]  # Mock pinv result\n            \n            mu = [0.02, 0.03]\n            Sigma = [[0.04, 0.01], [0.01, 0.09]]\n            \n            w = kelly_mod.portfolio_kelly(mu, Sigma)\n            assert len(w) == 2\n            # Should use pinv fallback (line 436)",
    "locations": [
      {
        "file": "tests/test_sizing_kelly.py",
        "start": 951,
        "end": 966
      },
      {
        "file": "tests/test_sizing_kelly.py",
        "start": 800,
        "end": 815
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 14,
    "tokens": 0,
    "code_snippet": "sink = SimLocalSink(\n            cfg=self.base_config,\n            ev=self.mock_event_logger,\n            time_func=self.mock_time_func\n        )\n\n        market = {\n            'best_bid': 100.0,\n            'best_ask': 101.0,\n            'liquidity': {'bid': 10.0, 'ask': 10.0}\n        }\n\n        order = {\n            'order_id': 'test-124'",
    "locations": [
      {
        "file": "tests/test_sim_local_sink.py",
        "start": 133,
        "end": 146
      },
      {
        "file": "tests/test_sim_local_sink.py",
        "start": 94,
        "end": 107
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 14,
    "tokens": 0,
    "code_snippet": "sink = SimLocalSink(\n            cfg=self.base_config,\n            ev=self.mock_event_logger,\n            time_func=self.mock_time_func\n        )\n\n        market = {\n            'best_bid': 100.0,\n            'best_ask': 101.0,\n            'liquidity': {'bid': 10.0, 'ask': 10.0}\n        }\n\n        order = {\n            'order_id': 'test-125'",
    "locations": [
      {
        "file": "tests/test_sim_local_sink.py",
        "start": 172,
        "end": 185
      },
      {
        "file": "tests/test_sim_local_sink.py",
        "start": 94,
        "end": 107
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 14,
    "tokens": 0,
    "code_snippet": "sink = SimLocalSink(\n            cfg=self.base_config,\n            ev=self.mock_event_logger,\n            time_func=self.mock_time_func\n        )\n\n        market = {\n            'best_bid': 100.0,\n            'best_ask': 101.0,\n            'liquidity': {'bid': 10.0, 'ask': 10.0}\n        }\n\n        order = {\n            'order_id': 'test-126'",
    "locations": [
      {
        "file": "tests/test_sim_local_sink.py",
        "start": 209,
        "end": 222
      },
      {
        "file": "tests/test_sim_local_sink.py",
        "start": 94,
        "end": 107
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 14,
    "tokens": 0,
    "code_snippet": "sink = SimLocalSink(\n            cfg=self.base_config,\n            ev=self.mock_event_logger,\n            time_func=self.mock_time_func\n        )\n\n        market = {\n            'best_bid': 100.0,\n            'best_ask': 101.0,\n            'liquidity': {'bid': 10.0, 'ask': 10.0}\n        }\n\n        order = {\n            'order_id': 'test-sell-fill-price'",
    "locations": [
      {
        "file": "tests/test_sim_local_sink.py",
        "start": 591,
        "end": 604
      },
      {
        "file": "tests/test_sim_local_sink.py",
        "start": 94,
        "end": 107
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 8,
    "tokens": 0,
    "code_snippet": "):\n        \"\"\"Test score calculation with features\"\"\"\n        model = ScoreModel(weights={\"feature1\": 0.5, \"feature2\": 0.3}, intercept=-0.1)\n        features = {\"feature1\": 1.0, \"feature2\": 2.0}\n        score = model.score_only(features)\n        assert isinstance(score, float)\n\n    def test_sigmoid_function(self",
    "locations": [
      {
        "file": "tests/test_signal.py",
        "start": 20,
        "end": 27
      },
      {
        "file": "tools/mutation_test_standalone.py",
        "start": 17,
        "end": 25
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 11,
    "tokens": 0,
    "code_snippet": "):\n        \"\"\"Test reject function\"\"\"\n        p_values = [0.01, 0.02, 0.03, 0.04, 0.05]\n        rejected_mask, num_rejected = reject(p_values, alpha=0.05)\n        assert isinstance(rejected_mask, list)\n        assert isinstance(num_rejected, int)\n        assert len(rejected_mask) == len(p_values)\n        assert all(isinstance(r, bool) for r in rejected_mask)\n\n\nclass",
    "locations": [
      {
        "file": "tests/test_signal.py",
        "start": 50,
        "end": 60
      },
      {
        "file": "tools/mutation_test_standalone.py",
        "start": 47,
        "end": 57
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 32,
    "tokens": 0,
    "code_snippet": "):\n        \"\"\"Test adding tick data\"\"\"\n        calculator = CrossAssetHY()\n        calculator.add_tick(\"SOL\", 1000.0, 50.0)\n        # Should not raise exception\n        assert True\n\n\n# Simple comparison tests for mutation testing\ndef test_simple_comparisons():\n    \"\"\"Simple tests that mutation testing can work with\"\"\"\n    x = 5\n    y = 10\n\n    # These comparisons will be mutated by our simple mutator\n    assert x < y\n    assert x != y\n    assert y > x\n    assert x <= 5\n    assert y >= 10\n\n\ndef test_boolean_logic():\n    \"\"\"Boolean logic tests for mutation testing\"\"\"\n    a = True\n    b = False\n\n    # These will be mutated (and/or operations)\n    assert a and not b\n    assert a or b\n    assert not (a and b)\n    assert (a or b) and True",
    "locations": [
      {
        "file": "tests/test_signal.py",
        "start": 68,
        "end": 99
      },
      {
        "file": "tools/mutation_test_standalone.py",
        "start": 63,
        "end": 94
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 7,
    "tokens": 0,
    "code_snippet": "snapshot = {\"mid_price\": 50000.0, \"spread_bps\": 2.0, \"latency_ms\": 10.0}\r\n        account_state = {\"equity_usd\": 10000.0, \"positions\": {}}\r\n        \r\n        result = risk_guards.pre_trade_check(intent, snapshot, account_state)\r\n        \r\n        assert result.allow == False\r\n        assert result.why_code == \"WHY_RISK_GUARD_MAX_NOTIONAL\"",
    "locations": [
      {
        "file": "tests/test_risk_guards_live.py",
        "start": 81,
        "end": 87
      },
      {
        "file": "tests/test_risk_guards_live.py",
        "start": 69,
        "end": 75
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 7,
    "tokens": 0,
    "code_snippet": "snapshot = {\"mid_price\": 50000.0, \"spread_bps\": 2.0, \"latency_ms\": 10.0}\r\n        account_state = {\"equity_usd\": 10000.0, \"positions\": {}}\r\n        \r\n        result = risk_guards.pre_trade_check(intent, snapshot, account_state)\r\n        \r\n        assert result.allow == False\r\n        assert result.why_code == \"WHY_RISK_GUARD_CVAR\"",
    "locations": [
      {
        "file": "tests/test_risk_guards_live.py",
        "start": 98,
        "end": 104
      },
      {
        "file": "tests/test_risk_guards_live.py",
        "start": 69,
        "end": 75
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 8,
    "tokens": 0,
    "code_snippet": "intent = {\"symbol\": \"BTCUSDT\", \"side\": \"buy\", \"qty\": 0.001, \"price\": 50000.0}\r\n        snapshot = {\"mid_price\": 50000.0, \"spread_bps\": 2.0, \"latency_ms\": 10.0}\r\n        account_state = {\"equity_usd\": 10000.0, \"positions\": {}}\r\n        \r\n        result = risk_guards.pre_trade_check(intent, snapshot, account_state)\r\n        \r\n        assert result.allow == False\r\n        assert result.why_code == \"WHY_RISK_GUARD_EVT\"",
    "locations": [
      {
        "file": "tests/test_risk_guards_live.py",
        "start": 115,
        "end": 122
      },
      {
        "file": "tests/test_risk_guards_live.py",
        "start": 97,
        "end": 75
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 9,
    "tokens": 0,
    "code_snippet": "():\r\n    svc = importlib.import_module(\"api.service\")\r\n    app = svc.app\r\n    client = TestClient(app)\r\n\r\n    body = {\r\n        \"account\": {\"mode\": \"shadow\"},\r\n        \"order\": {\"symbol\": \"BTCUSDT\", \"side\": \"LONG\", \"qty\": 0.01, \"price\": 100.0},\r\n        \"market\": {\"latency_ms\": 1.0, \"score\": 0.0, \"a_bps\": 10.0, \"b_bps\": 10.0, \"spread_bps\": 1000.0",
    "locations": [
      {
        "file": "tests/test_pretrade_models.py",
        "start": 25,
        "end": 33
      },
      {
        "file": "tests/test_pretrade_models.py",
        "start": 7,
        "end": 15
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 8,
    "tokens": 0,
    "code_snippet": "def write_jsonl(p: Path, rows):\r\n    p.parent.mkdir(parents=True, exist_ok=True)\r\n    with p.open('w', encoding='utf-8') as f:\r\n        for r in rows:\r\n            f.write(json.dumps(r) + \"\\n\")\r\n\r\n\r\ndef test_metrics_summary_enriched",
    "locations": [
      {
        "file": "tests/test_metrics_summary_details.py",
        "start": 8,
        "end": 15
      },
      {
        "file": "tests/metrics/test_metrics_summary.py",
        "start": 10,
        "end": 17
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 15,
    "tokens": 0,
    "code_snippet": "raw = [\r\n        {\"ts\": 100, \"type\": \"trade\", \"symbol\": \"BTCUSDT\", \"price\": 100.0, \"qty\": 0.5},\r\n        {\"ts\": 150, \"type\": \"trade\", \"symbol\": \"BTCUSDT\", \"price\": 101.0},  # invalid (missing size)\r\n        {\"ts\": 200, \"type\": \"trade\", \"symbol\": \"BTCUSDT\", \"price\": 102.0, \"qty\": 0.1, \"tag\": \"boom\"},\r\n    ]\r\n\r\n    def transform(evt):\r\n        if evt.get(\"tag\") == \"boom\":\r\n            raise RuntimeError(\"transform failure\")\r\n        return evt\r\n\r\n    clk = ManualClock(start_wall_ns=0)\r\n    r = Replay(source=raw, normalizer=Normalizer(strict=False), clock=clk, strict=False, pace=True)\r\n\r\n    # Should not raise any exceptions",
    "locations": [
      {
        "file": "tests/test_ingestion_replay.py",
        "start": 118,
        "end": 132
      },
      {
        "file": "tests/test_ingestion_replay.py",
        "start": 72,
        "end": 86
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 10,
    "tokens": 0,
    "code_snippet": "assert hasattr(decision, 'e_maker_bps')\n        assert hasattr(decision, 'e_taker_bps')\n        assert hasattr(decision, 'p_fill')\n        assert hasattr(decision, 'reason')\n        assert hasattr(decision, 'maker_fee_bps')\n        assert hasattr(decision, 'taker_fee_bps')\n        assert hasattr(decision, 'net_e_maker_bps')\n        assert hasattr(decision, 'net_e_taker_bps')\n\n    def",
    "locations": [
      {
        "file": "tests/test_execution_router.py",
        "start": 292,
        "end": 301
      },
      {
        "file": "tests/unit/test_xai_decision_trail.py",
        "start": 63,
        "end": 72
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 14,
    "tokens": 0,
    "code_snippet": "def __init__(self, responses=None):\r\n        self.responses = responses or {}\r\n        self.requests = []\r\n\r\n    def request(self, method, url, *, params=None, headers=None, json=None):\r\n        self.requests.append((method, url, params, headers, json))\r\n        # Return mock response based on URL pattern\r\n        for pattern, response in self.responses.items():\r\n            if pattern in url:\r\n                return response\r\n        return {}\r\n\r\n\r\ndef",
    "locations": [
      {
        "file": "tests/test_exchange_adapters.py",
        "start": 28,
        "end": 41
      },
      {
        "file": "tests/test_unified_exchange_adapter.py",
        "start": 58,
        "end": 71
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 9,
    "tokens": 0,
    "code_snippet": "mc = MondrianConformalBinary(alpha=0.1)\n\n        p_hat = [0.8, 0.2, 0.9, 0.1]\n        y = [1, 0, 1, 0]\n        groups = [\"A\", \"A\", \"B\", \"B\"]\n\n        mc.fit(p_hat, y, groups)\n\n        # No group should use global scores",
    "locations": [
      {
        "file": "tests/test_calibration_icp.py",
        "start": 226,
        "end": 234
      },
      {
        "file": "tests/test_calibration_icp.py",
        "start": 211,
        "end": 219
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 9,
    "tokens": 0,
    "code_snippet": "mc = MondrianConformalBinary(alpha=0.1)\n\n        p_hat = [0.8, 0.2, 0.9, 0.1]\n        y = [1, 0, 1, 0]\n        groups = [\"A\", \"A\", \"B\", \"B\"]\n\n        mc.fit(p_hat, y, groups)\n\n        # Test confident prediction for group A",
    "locations": [
      {
        "file": "tests/test_calibration_icp.py",
        "start": 241,
        "end": 249
      },
      {
        "file": "tests/test_calibration_icp.py",
        "start": 211,
        "end": 219
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 8,
    "tokens": 0,
    "code_snippet": "# Add project root to sys.path\nPROJECT_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))\nif PROJECT_ROOT not in sys.path:\n    sys.path.insert(0, PROJECT_ROOT)\n\n\ndef find_free_port():\n    \"\"\"Find a free port for testing.\"\"\"",
    "locations": [
      {
        "file": "tests/test_api_integration.py",
        "start": 15,
        "end": 22
      },
      {
        "file": "tests/test_api_validation.py",
        "start": 12,
        "end": 19
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 9,
    "tokens": 0,
    "code_snippet": "):\r\n    def request(\r\n        self,\r\n        method: str,\r\n        url: str,\r\n        *,\r\n        params: Optional[Mapping[str, object]] = None,\r\n        headers: Optional[Mapping[str, str]] = None,\r\n        json: Optional[object] = None,",
    "locations": [
      {
        "file": "scripts/run_live.py",
        "start": 55,
        "end": 63
      },
      {
        "file": "core/execution/exchange/common.py",
        "start": 233,
        "end": 129
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 10,
    "tokens": 0,
    "code_snippet": "try:\r\n            bid = float(str(bid_val)) if bid_val is not None else 0.0\r\n        except (ValueError, TypeError):\r\n            bid = 0.0\r\n        try:\r\n            ask = float(str(ask_val)) if ask_val is not None else 0.0\r\n        except (ValueError, TypeError):\r\n            ask = 0.0\r\n        return Book(bid=bid, ask=ask)\r\n    raise",
    "locations": [
      {
        "file": "scripts/run_live.py",
        "start": 123,
        "end": 132
      },
      {
        "file": "scripts/run_live.py",
        "start": 101,
        "end": 110
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 18,
    "tokens": 0,
    "code_snippet": "def _get_nested(d: dict, parts: list):\r\n            cur = d\r\n            for p in parts:\r\n                if not isinstance(cur, dict) or p not in cur:\r\n                    return None\r\n                cur = cur[p]\r\n            return cur\r\n\r\n        def _set_nested(d: dict, parts: list, value):\r\n            cur = d\r\n            for p in parts[:-1]:\r\n                if p not in cur or not isinstance(cur[p], dict):\r\n                    cur[p] = {}\r\n                cur = cur[p]\r\n            cur[parts[-1]] = value\r\n\r\n        def _find_best_split_and_set(base: dict, key: str, value):\r\n            parts",
    "locations": [
      {
        "file": "scripts/run_live.py",
        "start": 161,
        "end": 178
      },
      {
        "file": "scripts/run_replay.py",
        "start": 203,
        "end": 222
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 14,
    "tokens": 0,
    "code_snippet": ") as fh:\r\n            fh.write(f\"APPLIED PROFILE: {args.profile}\\n\")\r\n            fh.write(\"CHANGED KEYS:\\n\")\r\n            for p in changed:\r\n                old = before\r\n                for part in p.split('.'):\r\n                    old = old.get(part, None) if isinstance(old, dict) else None\r\n                new = cfg\r\n                for part in p.split('.'):\r\n                    new = new.get(part, None) if isinstance(new, dict) else None\r\n                fh.write(f\"- {p}: {old!r} -> {new!r}\\n\")\r\n        print(f\"PROFILE: applied {args.profile} -> {out_path}\")\r\n\r\n    http",
    "locations": [
      {
        "file": "scripts/run_live.py",
        "start": 221,
        "end": 234
      },
      {
        "file": "scripts/run_replay.py",
        "start": 287,
        "end": 300
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 6,
    "tokens": 0,
    "code_snippet": "ece = 0.0 if self.ece is None else float(self.ece)\r\n        logloss = 0.0 if self.logloss is None else float(self.logloss)\r\n        return math.exp(-eta * ece) * math.exp(-zeta * logloss)\r\n\r\n\r\n@dataclass",
    "locations": [
      {
        "file": "core/types.py",
        "start": 182,
        "end": 187
      },
      {
        "file": "core/calibration/calibrator.py",
        "start": 40,
        "end": 43
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 11,
    "tokens": 0,
    "code_snippet": "if not (0.0 <= p <= 1.0):\r\n        raise ValueError(\"p must be in [0,1]\")\r\n    if G < 0 or L < 0:\r\n        raise ValueError(\"G and L must be non-negative\")\r\n    return p * G - (1.0 - p) * L - c\r\n\r\n\r\ndef p_star_threshold(r: float, c_prime: float, delta: float = 0.0) -> float:\r\n    \"\"\"Minimal calibrated probability to enter, given payoff ratio r=G/L and c' = c/L.\r\n    p* = (1 + c') / (1 + r). A practical buffer \u03b4\u22650 can be added: p > p* + \u03b4.\r\n    \"\"\"",
    "locations": [
      {
        "file": "core/types.py",
        "start": 292,
        "end": 302
      },
      {
        "file": "core/tca/edge_budget.py",
        "start": 28,
        "end": 36
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 9,
    "tokens": 0,
    "code_snippet": "if r <= 0:\r\n        raise ValueError(\"r must be > 0\")\r\n    if c_prime < 0:\r\n        raise ValueError(\"c' must be \u2265 0\")\r\n    base = (1.0 + c_prime) / (1.0 + r)\r\n    return min(1.0, max(0.0, base + max(0.0, delta)))\r\n\r\n\r\ndef latency_degradation",
    "locations": [
      {
        "file": "core/types.py",
        "start": 303,
        "end": 311
      },
      {
        "file": "core/tca/edge_budget.py",
        "start": 37,
        "end": 45
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 8,
    "tokens": 0,
    "code_snippet": ") or \"\").upper()\r\n        oid = str(kwargs.get(\"order_id\") or kwargs.get(\"orderId\") or \"\")\r\n        if status in TERMINAL_STATES and oid:\r\n            key = (\"TERM\", oid, status)\r\n            if self._seen_cid_ts.contains(key):\r\n                return\r\n            self._seen_cid_ts.add(key)\r\n        self._write(self._w_failed",
    "locations": [
      {
        "file": "core/order_logger.py",
        "start": 332,
        "end": 339
      },
      {
        "file": "core/order_logger.py",
        "start": 311,
        "end": 318
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 7,
    "tokens": 0,
    "code_snippet": "s = str(ev.get(\"status\") or ev.get(\"state\") or ev.get(\"lifecycle\") or \"\").upper()\r\n        if s:\r\n            seen.add(s)\r\n    for s in priority:\r\n        if s in seen:\r\n            return s\r\n    return \"UNKNOWN\"",
    "locations": [
      {
        "file": "core/order_lifecycle.py",
        "start": 28,
        "end": 34
      },
      {
        "file": "core/order_logger.py",
        "start": 377,
        "end": 383
      }
    ]
  },
  {
    "source": "jscpd",
    "lines": 8,
    "tokens": 0,
    "code_snippet": "(\r\n        ts_iso=_get_ts_iso(snapshot),\r\n        decision_id=decision_id or '',\r\n        order_id=str(d.get('order_id') or d.get('id') or ''),\r\n        symbol=str(d.get('symbol') or ''),\r\n        side=str(d.get('side') or ''),\r\n        qty=float(d.get('qty') or d.get('amount') or 0.0),\r\n        error_code",
    "locations": [
      {
        "file": "core/converters.py",
        "start": 108,
        "end": 115
      },
      {
        "file": "core/converters.py",
        "start": 84,
        "end": 91
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.signal.leadlag_hy",
        "start": 63,
        "end": 313
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "calibrator",
        "start": 47,
        "end": 226
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.config.schema_validator",
        "start": 37,
        "end": 212
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "evt_pot",
        "start": 33,
        "end": 198
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "icp",
        "start": 23,
        "end": 176
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "cvar",
        "start": 224,
        "end": 371
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.signal.score",
        "start": 68,
        "end": 205
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.config.hotreload",
        "start": 24,
        "end": 154
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "drift",
        "start": 59,
        "end": 185
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.config.schema_validator",
        "start": 235,
        "end": 312
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "lambdas",
        "start": 38,
        "end": 155
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "icp",
        "start": 247,
        "end": 336
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "cvar",
        "start": 128,
        "end": 223
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "evt_pot",
        "start": 201,
        "end": 274
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.universe.hysteresis",
        "start": 29,
        "end": 91
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "microprice",
        "start": 42,
        "end": 139
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "calibrator",
        "start": 229,
        "end": 291
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.features.obi",
        "start": 43,
        "end": 125
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "lambdas",
        "start": 172,
        "end": 237
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.features.tfi",
        "start": 196,
        "end": 248
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.features.tfi",
        "start": 85,
        "end": 150
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_shadow_broker",
        "start": 93,
        "end": 120
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.signal.leadlag_hy",
        "start": 28,
        "end": 63
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "calibrator",
        "start": 327,
        "end": 360
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "icp",
        "start": 197,
        "end": 246
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "calibrator",
        "start": 367,
        "end": 413
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "microprice",
        "start": 154,
        "end": 190
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_basic_endpoints",
        "start": 9,
        "end": 47
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "repo_core_features_microprice_py_microprice_l_1_lk_micro_premium_streaming_wrapper_self_tests",
        "start": 24,
        "end": 57
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "tests.test_signal",
        "start": 64,
        "end": 99
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.features.microstructure",
        "start": 38,
        "end": 59
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "calibrator",
        "start": 413,
        "end": 443
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.features.microstructure",
        "start": 38,
        "end": 58
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.features.obi",
        "start": 148,
        "end": 170
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "drift",
        "start": 224,
        "end": 255
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_shadow_broker",
        "start": 16,
        "end": 35
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.features.tfi",
        "start": 66,
        "end": 84
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "repo_core_features_microprice_py_microprice_l_1_lk_micro_premium_streaming_wrapper_self_tests",
        "start": 153,
        "end": 173
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.config.loader",
        "start": 87,
        "end": 114
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.features.obi",
        "start": 124,
        "end": 144
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_api_survived_mutants",
        "start": 245,
        "end": 272
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_basic_endpoints",
        "start": 57,
        "end": 81
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "repo_scripts_run_shadow",
        "start": 116,
        "end": 131
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.config.schema_validator",
        "start": 213,
        "end": 233
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.features.tfi",
        "start": 150,
        "end": 172
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.config.schema_validator",
        "start": 331,
        "end": 346
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_absorption",
        "start": 118,
        "end": 140
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "tests.test_signal",
        "start": 16,
        "end": 39
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.tca.edge_budget",
        "start": 27,
        "end": 49
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "features_cross_asset",
        "start": 27,
        "end": 46
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_enhanced_idempotency_partials",
        "start": 83,
        "end": 97
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_api_survived_mutants",
        "start": 21,
        "end": 39
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_xai_decision_trail",
        "start": 29,
        "end": 48
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "run_live",
        "start": 221,
        "end": 233
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "run_live",
        "start": 177,
        "end": 189
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.execution.router",
        "start": 46,
        "end": 57
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "icp",
        "start": 183,
        "end": 196
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_tca_api_backward_compat",
        "start": 40,
        "end": 51
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_tca_api_backward_compat",
        "start": 13,
        "end": 24
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "tests.test_sizing_kelly",
        "start": 496,
        "end": 508
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "tests.test_signal",
        "start": 44,
        "end": 59
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_absorption",
        "start": 21,
        "end": 41
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "tests.test_api_integration",
        "start": 33,
        "end": 46
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_portfolio_correlation_effect",
        "start": 33,
        "end": 49
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.xai.__init__",
        "start": 21,
        "end": 31
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.regime.manager",
        "start": 40,
        "end": 52
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.order_lifecycle",
        "start": 14,
        "end": 24
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.execution.exchange.__init__",
        "start": 27,
        "end": 37
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "cvar",
        "start": 26,
        "end": 61
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.features.obi",
        "start": 126,
        "end": 137
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "microprice",
        "start": 140,
        "end": 151
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core_signal_leadlag_hy_py_hy_lead_lag_glr_te_embargo_single_file_self_tests",
        "start": 86,
        "end": 99
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "calibrator",
        "start": 31,
        "end": 42
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core_calibration_py_probabilistic_calibration_platt_temperature_isotonic_ece_brier_log_loss_prequential_conformal_ci_self_tests",
        "start": 23,
        "end": 38
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_enhanced_idempotency_partials",
        "start": 86,
        "end": 97
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_absorption",
        "start": 63,
        "end": 82
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "tests.test_config_loader",
        "start": 18,
        "end": 27
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_basic_endpoints_new",
        "start": 236,
        "end": 245
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.regime.manager",
        "start": 40,
        "end": 51
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.execution.router",
        "start": 259,
        "end": 270
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.execution.exchange.binance",
        "start": 130,
        "end": 140
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "cvar",
        "start": 72,
        "end": 103
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "drift",
        "start": 257,
        "end": 269
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.types",
        "start": 214,
        "end": 227
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core_signal_leadlag_hy_py_hy_lead_lag_glr_te_embargo_single_file_self_tests",
        "start": 62,
        "end": 78
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_tca_api_backward_compat",
        "start": 15,
        "end": 24
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_shadow_broker",
        "start": 640,
        "end": 650
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_shadow_broker",
        "start": 604,
        "end": 613
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_shadow_broker",
        "start": 567,
        "end": 576
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_shadow_broker",
        "start": 532,
        "end": 542
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_shadow_broker",
        "start": 496,
        "end": 506
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_shadow_broker",
        "start": 326,
        "end": 336
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_shadow_broker",
        "start": 290,
        "end": 299
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_shadow_broker",
        "start": 253,
        "end": 262
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_shadow_broker",
        "start": 218,
        "end": 228
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_shadow_broker",
        "start": 182,
        "end": 192
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_enhanced_idempotency_partials",
        "start": 221,
        "end": 233
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "tests.test_sizing_live_integration",
        "start": 142,
        "end": 155
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_router_backup",
        "start": 438,
        "end": 446
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "tests.test_exchange_adapters",
        "start": 24,
        "end": 42
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "tests.test_api_integration",
        "start": 15,
        "end": 32
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_xai_decision_trail",
        "start": 84,
        "end": 95
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_basic_endpoints",
        "start": 81,
        "end": 91
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.execution.router",
        "start": 132,
        "end": 145
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "tools.run_canary",
        "start": 38,
        "end": 48
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_sim_local_basic",
        "start": 8,
        "end": 18
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_enhanced_idempotency_partials",
        "start": 120,
        "end": 131
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_enhanced_idempotency_partials",
        "start": 90,
        "end": 97
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_xai_decision_trail",
        "start": 86,
        "end": 95
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_xai_decision_trail",
        "start": 52,
        "end": 61
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_execution_router_v1",
        "start": 170,
        "end": 177
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_execution_router_v1",
        "start": 255,
        "end": 262
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.universe.__init__",
        "start": 12,
        "end": 19
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.regime.__init__",
        "start": 15,
        "end": 22
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.order_lifecycle",
        "start": 27,
        "end": 34
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "alpha_ledger",
        "start": 227,
        "end": 236
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.execution.router",
        "start": 351,
        "end": 358
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.execution.router",
        "start": 299,
        "end": 308
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.execution.router",
        "start": 219,
        "end": 228
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.execution.enhanced_router",
        "start": 26,
        "end": 33
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.config.api_integration",
        "start": 36,
        "end": 44
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "repo_scripts_run_shadow",
        "start": 57,
        "end": 64
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.features.tfi",
        "start": 179,
        "end": 196
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.signal.leadlag_hy",
        "start": 48,
        "end": 55
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.features.microstructure",
        "start": 45,
        "end": 52
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "icp",
        "start": 97,
        "end": 110
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "icp",
        "start": 144,
        "end": 157
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "features_cross_asset",
        "start": 36,
        "end": 46
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core_signal_leadlag_hy_py_hy_lead_lag_glr_te_embargo_single_file_self_tests",
        "start": 152,
        "end": 159
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "calibrator",
        "start": 472,
        "end": 486
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "calibrator",
        "start": 458,
        "end": 468
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "tools.simple_mutator",
        "start": 21,
        "end": 30
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "tools.run_canary",
        "start": 63,
        "end": 73
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_tca_api_backward_compat",
        "start": 17,
        "end": 24
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_shadow_broker",
        "start": 184,
        "end": 192
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_shadow_broker",
        "start": 64,
        "end": 72
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_shadow_broker",
        "start": 42,
        "end": 50
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_shadow_broker",
        "start": 148,
        "end": 155
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_router_decide_expected_edge",
        "start": 11,
        "end": 17
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_enhanced_idempotency_partials",
        "start": 265,
        "end": 271
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_enhanced_idempotency_partials",
        "start": 120,
        "end": 128
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_enhanced_idempotency_partials",
        "start": 83,
        "end": 92
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "tests.test_sizing_kelly",
        "start": 487,
        "end": 496
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_tfi_complete",
        "start": 327,
        "end": 340
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_absorption",
        "start": 261,
        "end": 275
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_absorption",
        "start": 231,
        "end": 245
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "tests.test_api_integration",
        "start": 69,
        "end": 77
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "tests.test_api_integration",
        "start": 46,
        "end": 54
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_xai_decision_trail",
        "start": 58,
        "end": 66
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "tests.integration.test_full_b2b7_pipeline",
        "start": 139,
        "end": 147
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "tests.integration.test_full_b2b7_pipeline",
        "start": 93,
        "end": 101
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_enhanced_idempotency_partials",
        "start": 152,
        "end": 158
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_metrics_exposition",
        "start": 9,
        "end": 18
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "skalp_bot.runner.run_live_aurora",
        "start": 348,
        "end": 354
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "skalp_bot.integrations.aurora_gate",
        "start": 20,
        "end": 26
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "run_live",
        "start": 169,
        "end": 176
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "run_live",
        "start": 161,
        "end": 168
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.features.microstructure",
        "start": 26,
        "end": 34
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.execution.sla",
        "start": 105,
        "end": 111
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.execution.router",
        "start": 394,
        "end": 405
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.execution.exchange.binance",
        "start": 134,
        "end": 140
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "cvar",
        "start": 26,
        "end": 39
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "repo_scripts_run_shadow",
        "start": 93,
        "end": 99
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "calibrator",
        "start": 31,
        "end": 38
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "repo_core_features_obi_py_order_book_imbalance_l_1_lk_depth_metrics_single_file_self_tests",
        "start": 24,
        "end": 34
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.features.obi",
        "start": 105,
        "end": 118
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "repo_core_features_microprice_py_microprice_l_1_lk_micro_premium_streaming_wrapper_self_tests",
        "start": 24,
        "end": 34
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "repo_core_calibration_icp_py_split_mondrian_conformal_venn_abers_self_tests",
        "start": 23,
        "end": 39
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "repo_core_calibration_calibrator",
        "start": 51,
        "end": 60
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "microprice",
        "start": 119,
        "end": 132
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.features.absorption",
        "start": 42,
        "end": 50
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.types",
        "start": 117,
        "end": 129
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core_signal_leadlag_hy_py_hy_lead_lag_glr_te_embargo_single_file_self_tests",
        "start": 184,
        "end": 190
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core_signal_leadlag_hy_py_hy_lead_lag_glr_te_embargo_single_file_self_tests",
        "start": 113,
        "end": 120
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "calibrator",
        "start": 449,
        "end": 457
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core_calibration_py_probabilistic_calibration_platt_temperature_isotonic_ece_brier_log_loss_prequential_conformal_ci_self_tests",
        "start": 23,
        "end": 33
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "tools.run_canary",
        "start": 108,
        "end": 113
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_shadow_broker_complete",
        "start": 136,
        "end": 141
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_shadow_broker",
        "start": 64,
        "end": 71
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_shadow_broker",
        "start": 42,
        "end": 49
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_shadow_broker",
        "start": 269,
        "end": 281
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_shadow_broker",
        "start": 407,
        "end": 412
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_shadow_broker",
        "start": 93,
        "end": 98
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_enhanced_idempotency_partials",
        "start": 185,
        "end": 195
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_enhanced_idempotency_partials",
        "start": 139,
        "end": 150
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_enhanced_idempotency_partials",
        "start": 211,
        "end": 221
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "tests.test_signal",
        "start": 82,
        "end": 91
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_tfi_complete",
        "start": 305,
        "end": 313
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_obi_complete",
        "start": 186,
        "end": 191
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_absorption",
        "start": 205,
        "end": 215
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_xai_decision_trail",
        "start": 130,
        "end": 135
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_xai_decision_trail",
        "start": 52,
        "end": 57
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_xai_decision_trail",
        "start": 50,
        "end": 56
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_xai_decision_trail",
        "start": 107,
        "end": 112
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_enhanced_idempotency_partials",
        "start": 185,
        "end": 192
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "tests.integration.oms.test_order_lifecycle",
        "start": 74,
        "end": 79
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "tests.integration.oms.test_concurrent_orders",
        "start": 269,
        "end": 274
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "tests.integration.oms.test_concurrent_orders",
        "start": 75,
        "end": 80
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "test_basic_endpoints_new",
        "start": 236,
        "end": 241
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "run_live",
        "start": 203,
        "end": 209
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.xai.__init__",
        "start": 25,
        "end": 30
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.execution.router",
        "start": 66,
        "end": 81
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.execution.router",
        "start": 8,
        "end": 14
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.execution.enhanced_router",
        "start": 105,
        "end": 110
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.execution.enhanced_router",
        "start": 43,
        "end": 50
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.execution.enhanced_router",
        "start": 70,
        "end": 75
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "evt_pot",
        "start": 105,
        "end": 110
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "evt_pot",
        "start": 153,
        "end": 159
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.features.tfi",
        "start": 196,
        "end": 202
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.features.tfi",
        "start": 211,
        "end": 216
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.features.tfi",
        "start": 46,
        "end": 63
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.signal.leadlag_hy",
        "start": 28,
        "end": 37
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "drift",
        "start": 189,
        "end": 205
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "drift",
        "start": 86,
        "end": 92
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "drift",
        "start": 133,
        "end": 138
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.types",
        "start": 105,
        "end": 112
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core.features.microstructure",
        "start": 21,
        "end": 30
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "features_microstructure",
        "start": 42,
        "end": 47
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "features_cross_asset",
        "start": 27,
        "end": 36
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "core_signal_leadlag_hy_py_hy_lead_lag_glr_te_embargo_single_file_self_tests",
        "start": 100,
        "end": 105
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 1,
    "tokens": 0,
    "code_snippet": "",
    "locations": [
      {
        "file": "calibrator",
        "start": 486,
        "end": 491
      }
    ]
  },
  {
    "source": "pylint",
    "lines": 11,
    "tokens": 0,
    "code_snippet": "    import numpy as np  # type: ignore\nexcept Exception:  # pragma: no cover\n    np = None  # type: ignore\n\n# -------- Optional import from core/types; minimal fallbacks if unavailable -----\ntry:  # pragma: no cover - exercised in integration\n    from aurora.core.types import ProbabilityMetrics, ConformalInterval\nexcept Exception: (duplicate-code)\n\n-----------------------------------\nYour code has been rated at 0.00/10",
    "locations": [
      {
        "file": "core_calibration_py_probabilistic_calibration_platt_temperature_isotonic_ece_brier_log_loss_prequential_conformal_ci_self_tests",
        "start": 23,
        "end": 32
      },
      {
        "file": "edge_budget_py",
        "start": 23,
        "end": 32
      }
    ]
  }
]
