**–í—ñ–¥–ø–æ–≤—ñ–¥—ñ –Ω–∞ –ø–∏—Ç–∞–Ω–Ω—è –¥–æ —ñ–Ω—à–∏—Ö –®–Ü (—Ä–µ—Ü–µ–Ω–∑—ñ—è –ø–ª–∞–Ω—É)**

---

### **A. –ê—Ä—Ö—ñ—Ç–µ–∫—Ç—É—Ä–∞ execution**

**1. –ß–∏ –¥–æ—Å—Ç–∞—Ç–Ω—å–æ `ExecutionRouter v2` –ø–µ—Ä–µ–≤—ñ—Ä–æ–∫?**  
–¢–∞–∫, –∞–ª–µ –≤–∞—Ä—Ç–æ –¥–æ–¥–∞—Ç–∏:
- –ü–µ—Ä–µ–≤—ñ—Ä–∫—É `timeInForce` –¥–ª—è `MARKET` –æ—Ä–¥–µ—Ä—ñ–≤ (–Ω–µ –¥–æ–ø—É—Å–∫–∞—Ç–∏ `GTC` –¥–ª—è –º–∞—Ä–∫–µ—Ç—É).
- –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω—É –∫–æ—Ä–µ–∫—Ü—ñ—é `reduceOnly` –¥–ª—è —Ö–µ–¥–∂-—Ä–µ–∂–∏–º—É (—è–∫—â–æ –±—ñ—Ä–∂–∞ –Ω–µ –ø—ñ–¥—Ç—Ä–∏–º—É—î ‚Äî —ñ–º—ñ—Ç—É–≤–∞—Ç–∏ —á–µ—Ä–µ–∑ `positionSide`).
- –í–∞–ª—ñ–¥–∞—Ü—ñ—é `workingType` (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, –¥–ª—è `STOP` –æ—Ä–¥–µ—Ä—ñ–≤: `mark` vs `last`).
- –ü–µ—Ä–µ–≤—ñ—Ä–∫—É `closePosition` vs `reduceOnly` –∫–æ–Ω—Ñ–ª—ñ–∫—Ç—ñ–≤.

**2. –†–∏–∑–∏–∫–∏ –∑–≤‚Äô—è–∑—É–≤–∞–Ω–Ω—è bracket-–æ—Ä–¥–µ—Ä—ñ–≤ —á–µ—Ä–µ–∑ `clientOrderId`?**  
–¢–∞–∫, —Ä–∏–∑–∏–∫–∏ —î:
- –ü–æ—Ç—Ä—ñ–±–µ–Ω —É–Ω—ñ–∫–∞–ª—å–Ω–∏–π `bracket_id` (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, `UUID4`) –¥–ª—è –≥—Ä—É–ø–∏ –æ—Ä–¥–µ—Ä—ñ–≤.
- –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ `sequence_id` (–ª–æ–∫–∞–ª—å–Ω–æ –∑–±–µ—Ä—ñ–≥–∞—Ç–∏ counter) –¥–ª—è –∑–∞—Ö–∏—Å—Ç—É –≤—ñ–¥ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫—ñ–≤.
- –ü—Ä–∏ —Ä–µ–∫–æ–Ω—Å–∏–ª—ñ–∞—Ü—ñ—ó ‚Äî –ø–µ—Ä–µ–≤—ñ—Ä—è—Ç–∏ –∑–≤‚Äô—è–∑–∫–∏ —á–µ—Ä–µ–∑ `bracket_id` —ñ –≤—ñ–¥–Ω–æ–≤–ª—é–≤–∞—Ç–∏ —Å—Ç–∞–Ω.

---

### **B. Risk/Reward**

**3. –ß–∏ –ø–æ—Ç—Ä—ñ–±–Ω—ñ –∫–æ—Ä–µ–∫—Ü—ñ—ó —É sizing?**  
–¢–∞–∫, –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ –¥–æ –∫–æ–Ω—Ü–µ–ø—Ü—ñ—ó (¬ß11):
\[
q = \min\left(\mathrm{floor\_lot}\left(\frac{r \cdot E \cdot M}{d}\right), q_{\max\,lev}, q_{\max\,exp}\right),
\]
–¥–µ \( M = \lambda_{cal} \cdot \lambda_{reg} \cdot \ldots \) ‚Äî –º–Ω–æ–∂–Ω–∏–∫ –ê–≤—Ä–æ—Ä–∏. –î–æ–¥–∞—Ç–∫–æ–≤–æ:
- –Ø–∫—â–æ `CVaR95` —É–≥–æ–¥–∏ > –ø–æ—Ä–æ–≥—É ‚Äî –∑–º–µ–Ω—à–∏—Ç–∏ \( q \) –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç–æ–º \( \frac{\tau}{\mathrm{CVaR}} \).
- TCA-–∫–æ—Ä–µ–∫—Ü—ñ—è: \( d \leftarrow d + c_{slip} + c_{adv} \).

**4. –û–ø—Ç–∏–º–∞–ª—å–Ω–∏–π —Ç—Ä–∏–≥–µ—Ä –¥–ª—è BE/trailing?**  
- **BE**: –∞–∫—Ç–∏–≤—É–≤–∞—Ç–∏ –ø—ñ—Å–ª—è TP1, –ø–µ—Ä–µ–Ω–æ—Å–∏—Ç–∏ SL –Ω–∞ `entry + spread + fee`.
- **Trailing**: –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ `k * ATR` –∑ –∞–∫—Ç–∏–≤–∞—Ü—ñ—î—é –ø—Ä–∏ `PnL > 2 * ATR` —ñ –∫—Ä–æ–∫–æ–º `0.5 * ATR`.
- –Ü–Ω–≤–∞—Ä—ñ–∞–Ω—Ç–∏ –¥–ª—è —Ç–µ—Å—Ç—ñ–≤:
  - Trailing-SL –Ω—ñ–∫–æ–ª–∏ –Ω–µ —Ä—É—Ö–∞—î—Ç—å—Å—è –Ω–∞–∑–∞–¥.
  - BE –Ω–µ –∞–∫—Ç–∏–≤—É—î—Ç—å—Å—è –¥–æ TP1.
  - –£—Å—ñ —Ü—ñ–Ω–∏ –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—é—Ç—å tickSize.

---

### **C. WS/Reconciliation/Retry**

**5. –°—Ö–µ–º–∞ backfill –¥–ª—è Binance:**  
–ù–∞–π–Ω–∞–¥—ñ–π–Ω—ñ—à–µ: `lastUpdateId` –∑ REST `fapi/v1/depth?symbol=XXX&limit=1000` + –ø–æ–¥–∞–ª—å—à–∞ —Å–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—è —á–µ—Ä–µ–∑ WS `depthUpdate`.  
–î–ª—è XAI-–¥–∏—Ñ—ñ–≤ –ª–æ–≥—É–≤–∞—Ç–∏:
- –†–æ–∑–±—ñ–∂–Ω–æ—Å—Ç—ñ —É `lastUpdateId`.
- –†—ñ–∑–Ω–∏—Ü—è –≤ –∫—ñ–ª—å–∫–æ—Å—Ç—ñ –æ—Ä–¥–µ—Ä—ñ–≤/–ø–æ–∑–∏—Ü—ñ–π.
- –ù–µ—Å–ø—ñ–≤–ø–∞–¥—ñ–Ω–Ω—è `executionType` (`FILL` vs `CANCELED`).

**6. –ö–ª–∞—Å–∏—Ñ—ñ–∫–∞—Ü—ñ—è –ø–æ–º–∏–ª–æ–∫ —ñ backoff:**  
- **Rate-limit**: `HTTP 429` ‚Üí backoff `2^attempt` —Å–µ–∫—É–Ω–¥, –º–∞–∫—Å 5 —Å–ø—Ä–æ–±.
- **Network**: `Timeout/ConnectionError` ‚Üí backoff `1, 2, 4, 8, 16` —Å–µ–∫.
- **Invalid-spec**: `HTTP 4xx` ‚Üí –Ω–µ–º–∞—î —Ä–µ—Ç—Ä–∞—é, XAI-–ª–æ–≥ + –∞–ª–µ—Ä—Ç.
- SLA: —è–∫—â–æ –∑–∞–≥–∞–ª—å–Ω–∞ –∑–∞—Ç—Ä–∏–º–∫–∞ >500 –º—Å ‚Äî deny –ø–æ–¥–∞–ª—å—à–∏—Ö —Ä–µ—Ç—Ä–∞—ó–≤.

---

### **D. –¢–µ—Å—Ç—É–≤–∞–Ω–Ω—è/–º–µ—Ç—Ä–∏–∫–∏**

**7. –ú—ñ–Ω—ñ–º–∞–ª—å–Ω–æ –ø—Ä–∏–π–Ω—è—Ç–Ω–∏–π mutation-score:**  
70% ‚Äî –º—ñ–Ω—ñ–º—É–º –¥–ª—è –∫—Ä–∏—Ç–∏—á–Ω–∏—Ö –º–æ–¥—É–ª—ñ–≤ (–æ—Å–æ–±–ª–∏–≤–æ `risk/oms/signals`).  
–ü–µ—Ä—à–æ—á–µ—Ä–≥–æ–≤—ñ ¬´–≤–±–∏–≤—Ü—ñ¬ª –º—É—Ç–∞–Ω—Ç—ñ–≤:
- –£–º–æ–≤–∏ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, `if spread < max_spread`).
- –û–±—á–∏—Å–ª–µ–Ω–Ω—è —Ä–æ–∑–º—ñ—Ä—É –ø–æ–∑–∏—Ü—ñ—ó (`floor_lot`, `minNotional`).
- –°—Ç–∞–Ω–∏ FSM (`OPENING ‚Üí OPEN`).

**8. Chaos-–∫–µ–π—Å–∏ –¥–ª—è CI:**  
- **Drop WS**: –ø–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ recon + autoreconnect.
- **Out-of-order fills**: —ñ–º—ñ—Ç—É–≤–∞—Ç–∏ –∑–∞–ø–æ–≤–Ω–µ–Ω–Ω—è TP –¥–æ –≤—Ö–æ–¥—É.
- **Duplicate acks**: –≤—ñ–¥–ø—Ä–∞–≤–ª—è—Ç–∏ —ñ–¥–µ–Ω—Ç–∏—á–Ω—ñ `FILL` –ø–æ–¥—ñ—ó.
- **Clock-skew**: –∑—Å—É–≤–∞—Ç–∏ —á–∞—Å –Ω–∞ ¬±30 —Å–µ–∫.
- –ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü—ñ—è: –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ `pytest` + `tox` –∑ —ñ–Ω'—î–∫—Ü—ñ—î—é –ø–æ–º–∏–ª–æ–∫.

**9. Governance-–≥–µ–π—Ç–∏:**  
SPRT/GLR –¥–æ—Å—Ç–∞—Ç–Ω—å–æ, –∞–ª–µ –¥–æ–¥–∞—Ç–∏:
- **Alpha-spending** (Pocock/OBF –º–µ–∂—ñ) –¥–ª—è –ø–æ—Å–ª—ñ–¥–æ–≤–Ω–∏—Ö —Ç–µ—Å—Ç—ñ–≤.
- **FDR-–∫–æ–Ω—Ç—Ä–æ–ª—å** (Benjamini‚ÄìHochberg) –¥–ª—è –ø–∞—Ä–∞–ª–µ–ª—å–Ω–∏—Ö –µ–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç—ñ–≤.
- **–ö–∞–Ω–∞—Ä–µ–π–∫–∞**: –∑–∞–ø—É—Å–∫ –Ω–∞ 1% —Ç—Ä–∞—Ñ—ñ–∫—É –ø–µ—Ä–µ–¥ –ø–æ–≤–Ω–∏–º —Ä–æ–∑–≥–æ—Ä—Ç–∞–Ω–Ω—è–º.

---

### **E. –ú–∞—Ä–∫–µ—Ç-–º—ñ–∫—Ä–æ—Å—Ç—Ä—É–∫—Ç—É—Ä–∞**

**10. Maker vs Taker –¥–ª—è Binance USDT-M:**  
**Maker**:
- –ü–µ—Ä–µ–≤–∞–≥–∏: —Ä–µ–±–µ–π—Ç–∏ (~0.01%).
- –ù–µ–±–µ–∑–ø–µ–∫–∞: adverse selection + –Ω–µ–∑–∞–ø–æ–≤–Ω–µ–Ω–Ω—è.
- –ú–æ–¥–µ–ª—å: `hazard_fill = f(TBR, queue_pos, spread)`.  
**Taker**:
- –ü–µ—Ä–µ–≤–∞–≥–∏: –º–∏—Ç—Ç—î–≤–µ –∑–∞–ø–æ–≤–Ω–µ–Ω–Ω—è.
- –ù–µ–¥–æ–ª—ñ–∫–∏: –∫–æ–≤–∑–∞–Ω–Ω—è + fee (0.04%).  
**–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—è**:
- –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ **maker** –¥–ª—è –Ω–∏–∑—å–∫–æ—ó –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—ñ —Ç–∞ –≤–∏—Å–æ–∫–æ–≥–æ `OBI`.
- **Taker** ‚Äî –¥–ª—è –≤–∏—Å–æ–∫–æ—ó –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—ñ –∞–±–æ –∫–æ–ª–∏ `lambda_fill` –Ω–∏–∑—å–∫–∞.
- TCA: —Å–∏–º—É–ª—é–≤–∞—Ç–∏ –æ–±–∏–¥–≤–∞ —Å—Ü–µ–Ω–∞—Ä—ñ—ó —Ç–∞ –≤–∏–±–∏—Ä–∞—Ç–∏ –∫—Ä–∞—â–∏–π `E[Œ†]`.

---

Looking at your comprehensive execution plan against the fundamental Aurora+Scalp Bot concept, I'll provide a structured review analyzing alignment, gaps, and recommendations.

## 1. ALIGNMENT ASSESSMENT

### ‚úÖ **Strong Alignment Areas**

Your plan excellently addresses several critical requirements from the concept:

1. **Risk Management Architecture** - Your CVaR gates, Kelly sizing formula, and SSOT risk config directly implement the concept's requirements (¬ß11-12)
2. **XAI Completeness** - Full audit trail implementation across all execution points matches the concept's XAI requirements (¬ß15)
3. **Idempotency & Reconciliation** - Your WS+Recon module with drift detection addresses the concept's partial fill requirements (¬ß14.2)
4. **Statistical Governance** - SPRT/GLR gates before production align with concept's certification requirements (¬ß13.3)

### ‚ö†Ô∏è **Partial Alignments Needing Enhancement**

1. **TCA Integration** 
   - Your plan: Mentions TCA in risk formula but lacks dedicated module
   - Concept requires: Full TCA with fill simulator, latency degradation model, edge-budget breakdown (¬ß9)
   - **Gap**: No explicit adverse selection modeling, maker/taker decision engine missing

2. **Dynamic Kelly Orchestration**
   - Your plan: Has basic Kelly formula with CVaR constraints
   - Concept requires: Multi-factor Œª multipliers (calibration, regime, liquidity, DD, latency) (¬ß11.3)
   - **Gap**: Missing Aurora orchestration layer with dynamic multipliers

## 2. CRITICAL GAPS ANALYSIS

### üî¥ **High Priority Gaps**## 3. ANSWERS TO YOUR SPECIFIC QUESTIONS

### A. Architecture & Execution

**Q1: Are ExecutionRouter v2 validations sufficient?**
- Your validations cover exchange mechanics well
- **Missing**: TCA-based routing decisions, maker/taker optimization based on market microstructure
- **Add**: Queue position estimation, TBR (trade-to-book ratio) calculation, rebate optimization

**Q2: Risks in clientOrderId linking for bracket orders?**
- Your hash-based approach `hash(trace_id, spec)` is solid
- **Enhancement**: Add sequence numbers for multi-leg orders: `{trace_id}_{leg_seq}_{retry_count}`
- **Consider**: Separate state persistence for bracket order relationships

### B. Risk/Reward

**Q3: Sizing formula adjustments needed?**
- Your formula needs the Aurora multiplier layer: `q_final = M * q_base` where `M = Œª_cal * Œª_reg * Œª_liq * Œª_dd * Œª_lat`
- **Critical addition**: Real-time CVaR adjustment based on portfolio exposure
- **TCA correction**: Adjust `c` dynamically based on current market conditions (spread, queue depth)

**Q4: Optimal BE/Trailing triggers?**
- **BE**: After TP‚ÇÅ execution + min(2*spread, 0.5*ATR) - this ensures profitability even with adverse moves
- **Trailing**: Hybrid approach: `max(k*ATR, p%*high_water_mark)` with k=1.5-2.0, p=0.5-1.0%
- **Property test invariants**: 
  - Trailing stop monotonically non-decreasing
  - BE ensures min profit ‚â• fees
  - No trailing update causes immediate stop trigger

### C. WS/Reconciliation/Retry

**Q5: Best Binance backfill scheme?**
- Use `lastUpdateId` for orderbook, `eventTime` sequence for trades
- **XAI diffs**: Log as `{before_state, after_state, diff_fields, reconciliation_source, confidence_score}`
- Implement watermark tracking for each stream type

**Q6: Error classification and backoff thresholds?**
- **Rate limits**: 418/429 ‚Üí exponential backoff starting 100ms, max 5s, max 5 retries
- **Timeouts**: >1s response ‚Üí linear backoff 500ms increments, max 3 retries
- **SLA boundary**: Cancel operation if total latency approaching `E[Œ†]/Œ∫` threshold

### D. Testing/Metrics

**Q7: Minimum mutation score?**
- 70% is reasonable for critical paths
- **Priority killers**: Boundary conditions, comparison operators in risk checks, Kelly calculations
- Focus on: order validation logic, position state transitions, risk gate conditions

**Q8: Critical chaos cases?**
- **Top breakers**: 
  1. Out-of-order fills with partial amounts
  2. Position state during reconnection window
  3. Duplicate fills with different timestamps
  4. Clock skew > 1s causing order rejection
- **Automation**: Use toxiproxy for network chaos, custom event injector for order flow

**Q9: Governance gates sufficiency?**
- SPRT/GLR good baseline
- **Add**: Benjamini-Hochberg for multiple testing correction when testing multiple alts
- **Alpha spending**: Implement Œ±-spending function (Lan-DeMets) for sequential testing
- **Consider**: Mandatory soak period in paper trading before parameter changes

### E. Market Microstructure

**Q10: Maker vs Taker optimization for Binance USDT-M?**
- **Maker logic**: Use hazard model with queue position based on order book imbalance
- **Key factors**: 
  - TBR < 0.3 ‚Üí favor maker (low adverse selection)
  - Queue position > 50% book ‚Üí switch to taker
  - Spread > 2*avg ‚Üí always taker
- **TCA model**: Track realized slippage vs model, adjust `Œ∫` parameter daily

## 4. CRITICAL RECOMMENDATIONS

1. **Must Add Before Live**:
   - TCA engine with full edge-budget tracking
   - Aurora orchestration layer with dynamic multipliers
   - Regime detection (at minimum Page-Hinkley on key metrics)

2. **Architectural Suggestion**:
   - Consider separating Signal Generation (Aurora brain) from Execution (Scalp bot)
   - Your plan focuses on execution; ensure clear interface for signal injection

3. **Risk Control Enhancement**:
   - Add portfolio-level CVaR optimization, not just per-trade
   - Implement correlation-aware position sizing for multiple alts

4. **Operational Readiness**:
   - Add performance tracking against SR_monthly ‚â• 2 target
   - Implement A/B testing framework for strategy variations
   - Create fallback "safe mode" with conservative parameters

# Aurora+Scalp Execution Implementation Gaps Matrix

## üî¥ Critical Gaps (Must Address)

| Component | Concept Requirement | Your Plan Status | Impact | Recommendation |
|-----------|-------------------|------------------|---------|----------------|
| **TCA & Fill Simulator** | Full TCA with maker/taker hazard model, latency degradation Œ∫, edge-budget dashboard (¬ß9) | Missing dedicated module | Cannot optimize execution costs or meet E[Œ†]>0 after TCA requirement | Add Module 3.8: TCA Engine with fill hazard model, latency impact measurement |
| **Aurora Orchestrator** | Dynamic Kelly with 5 multipliers: Œª_cal, Œª_reg, Œª_liq, Œª_dd, Œª_lat (¬ß11.3) | Only basic Kelly formula | No adaptive risk scaling based on market conditions | Extend Module 3.7 with Aurora orchestration layer |
| **Regime Detector** | Page-Hinkley/GLR/HMM for market regime detection (¬ß8) | Not mentioned | Cannot implement Œª_reg or regime-specific trading | Add Module 3.9: Regime Detection Engine |
| **Signal Engine** | Cross-asset lead-lag with SOL‚Üíalts beta estimation (¬ß6-7) | Pure execution focus | Missing alpha generation core | Add Module 3.10: Signal Infrastructure (may be separate system) |

## üü° Medium Priority Gaps

| Component | Concept Requirement | Your Plan Status | Impact | Recommendation |
|-----------|-------------------|------------------|---------|----------------|
| **EVT-CVaR** | POT/GPD tail modeling with bootstrap CI (¬ß12) | Basic CVaR gates mentioned | Underestimating tail risks | Enhance risk module with EVT implementation |
| **Calibration Monitor** | ECE‚â§0.05, Brier‚â§0.17, drift detection (¬ß13) | Not mentioned | Cannot detect model degradation | Add calibration monitoring to Module 3.7 |
| **Maker vs Taker Decision** | Optimize based on TBR, queue position, rebates (¬ß14.1) | Market/Limit only | Suboptimal execution costs | Add intelligent routing in Module 3.1 |
| **Portfolio Covariance** | Ledoit-Wolf shrinkage for correlated alts (R1.2.B) | Single-asset focus | Incorrect position sizing for portfolio | Add portfolio optimization to Module 3.2 |

## üü¢ Well-Covered Areas

| Component | Concept Requirement | Your Plan Implementation | Assessment |
|-----------|-------------------|-------------------------|------------|
| **Bracket Orders** | Entry+SL+TP with BE and trailing (¬ß17) | Module 3.2 OrderBuilder | ‚úÖ Complete |
| **Position FSM** | State machine for partial fills (¬ß14.2) | Module 3.3 PositionManager v2 | ‚úÖ Complete |
| **Reconciliation** | Drift detection and recovery | Module 3.4 WS+Recon | ‚úÖ Complete |
| **XAI Logging** | Complete decision trail (¬ß15) | Throughout all modules | ‚úÖ Complete |
| **SSOT Config** | Centralized risk parameters | Module 3.7 risk_policy.yaml | ‚úÖ Complete |

## Implementation Priority Matrix

### Phase 1: Core Execution (Your Current Plan)
‚úÖ Modules 3.1-3.7 as specified
- Timeline: 4-6 weeks
- Focus: Robust order execution infrastructure

### Phase 2: TCA & Intelligence Layer (Critical Additions)
1. **Module 3.8: TCA Engine**
   - Maker fill hazard model: `Œª_fill(t) = Œª_0(t) * exp(Œ∏^T Z)`
   - Taker slippage model
   - Latency impact measurement: `E[Œ†(‚Ñì)] = E[Œ†(0)] - Œ∫*‚Ñì`
   - Edge-budget breakdown dashboard

2. **Module 3.9: Regime Detector**
   - Page-Hinkley change detection
   - GLR for distribution shifts
   - Market state classification

3. **Module 3.10: Aurora Orchestrator**
   - Dynamic multiplier calculation
   - Portfolio covariance with L-W shrinkage
   - Cross-asset beta estimation

### Phase 3: Advanced Features
- Signal engine integration (if not separate system)
- Advanced calibration monitoring
- Multi-exchange routing

## Acceptance Criteria Alignment

| Concept Requirement | Your Plan Coverage | Enhancement Needed |
|--------------------|-------------------|-------------------|
| E[Œ†] > 0 after TCA | ‚ùå No TCA module | Add full TCA implementation |
| ECE ‚â§ 0.05 calibration | ‚ùå Not mentioned | Add calibration monitoring |
| CVaR‚Çâ‚ÇÖ control | ‚úÖ Module 3.7 | Enhance with EVT |
| SLA latency "tick‚Üíorder" | ‚úÖ Module 3.5-3.6 | Add latency impact model |
| SR_monthly ‚â• 2 | ‚ùå No performance tracking | Add performance metrics |
| SPRT/GLR governance | ‚úÖ Module 3.7 | Fully aligned |

## Recommended Test Additions

### For TCA Module
```python
tests/integration/tca/
‚îú‚îÄ‚îÄ test_fill_hazard_model.py      # Cox/Hawkes implementation
‚îú‚îÄ‚îÄ test_maker_taker_decision.py   # Routing optimization
‚îú‚îÄ‚îÄ test_latency_degradation.py    # Œ∫ measurement
‚îî‚îÄ‚îÄ test_edge_budget_tracking.py   # Component breakdown
```

### For Regime Detection
```python
tests/unit/regime/
‚îú‚îÄ‚îÄ test_page_hinkley.py          # Change point detection
‚îú‚îÄ‚îÄ test_glr_detector.py          # Distribution shift
‚îî‚îÄ‚îÄ test_regime_transitions.py    # State machine
```

### For Aurora Orchestrator
```python
tests/integration/aurora/
‚îú‚îÄ‚îÄ test_dynamic_multipliers.py   # Œª calculations
‚îú‚îÄ‚îÄ test_portfolio_kelly.py       # Multi-asset sizing
‚îî‚îÄ‚îÄ test_covariance_shrinkage.py  # Ledoit-Wolf
```

## Risk Matrix for Gaps

| Gap | Probability of Issue | Impact if Occurs | Mitigation |
|-----|---------------------|------------------|------------|
| No TCA | High (100%) | High - negative E[Œ†] | Implement before live |
| No regime detection | High (80%) | Medium - suboptimal entry | Can start without, add soon |
| No Aurora orchestration | Medium (60%) | High - poor risk scaling | Critical for volatile alts |
| No calibration monitoring | High (90%) | High - model drift | Add monitoring ASAP |

## Summary Recommendations

1. **Immediate Actions**:
   - Proceed with Modules 3.1-3.7 as planned ‚úÖ
   - Start designing TCA module in parallel
   - Add calibration monitoring to Module 3.7

2. **Next Sprint Priorities**:
   - TCA Engine implementation (Module 3.8)
   - Regime Detector (Module 3.9)
   - Aurora Orchestrator enhancement (Module 3.10)

3. **Testing Enhancements**:
   - Add TCA-aware integration tests
   - Include regime-stratified backtesting
   - Implement calibration drift tests

4. **Governance Checkpoints**:
   - Gate 1: Basic execution working (your plan)
   - Gate 2: TCA shows E[Œ†] > 0 after costs
   - Gate 3: Full Aurora orchestration active
   - Gate 4: Live paper trading validation

   –ê–Ω–∞–ª—ñ–∑ –ø–ª–∞–Ω—É –∑–∞–≤–µ—Ä—à–µ–Ω–æ. –í—ñ–¥–ø–æ–≤—ñ–¥—ñ –Ω–∞ –∑–∞–ø–∏—Ç–∏ –≥–æ—Ç–æ–≤—ñ.

---

### A. –ê—Ä—Ö—ñ—Ç–µ–∫—Ç—É—Ä–∞ execution

1.  **`ExecutionRouter v2`**: –î–æ–¥–∞–π—Ç–µ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ `priceProtect` (–¥–ª—è `MARKET` –æ—Ä–¥–µ—Ä—ñ–≤), –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ —Å–ø—Ä–µ–¥—É —Ç–∞ `PERCENT_PRICE` —Ñ—ñ–ª—å—Ç—Ä–∞. –¶–µ –º—ñ–Ω—ñ–º—ñ–∑—É—î –≤—ñ–¥—Ö–∏–ª–µ–Ω–Ω—è —á–µ—Ä–µ–∑ –≤–æ–ª–∞—Ç–∏–ª—å–Ω—ñ—Å—Ç—å. –í–∞–ª—ñ–¥–∞—Ü—ñ—è `workingType` —Ç–∞ —Ä–µ–∂–∏–º—ñ–≤ –º–∞—Ä–∂—ñ ‚Äî –∫–æ—Ä–µ–∫—Ç–Ω–∞.
2.  **Idempotency**: `clientOrderId` –≤—Ä–∞–∑–ª–∏–≤–∏–π –¥–æ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫—ñ–≤. –°—Ö–µ–º–∞: `clientOrderId = hash(strategy_id, intent_id, leg_type, timestamp_ns)`. `intent_id` ‚Äî —É–Ω—ñ–∫–∞–ª—å–Ω–∏–π —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ç–æ—Ä —É–≥–æ–¥–∏. –ì–∞—Ä–∞–Ω—Ç—É—î —É–Ω—ñ–∫–∞–ª—å–Ω—ñ—Å—Ç—å —Ç–∞ –≤—ñ–¥–Ω–æ–≤–ª—é–≤–∞–Ω—ñ—Å—Ç—å. –ü–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ—Å—Ç—å ‚Äî —á–µ—Ä–µ–∑ `listenKey` —Ç–∞ `lastUpdateId` –∑ REST API –ø—Ä–∏ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—ñ.

---

### B. Risk/Reward

3.  **Sizing Formula**: –§–æ—Ä–º—É–ª–∞ –Ω–µ–ø–æ–≤–Ω–∞. –ö–æ—Ä–µ–∫—Ç–Ω–∏–π –≤–∞—Ä—ñ–∞–Ω—Ç:
    $q' = \lambda_{CVaR} \cdot \min(\mathrm{floor\_lot}(\frac{r \cdot E}{d + c_{TCA}}), q_{\max\,lev}, q_{\max\,exp})$
    –¥–µ $\lambda_{CVaR} \in [0, 1]$ ‚Äî –≥–µ–π—Ç –≤—ñ–¥ –ø–æ—Ç–æ—á–Ω–æ—ó CVaR95 –ø–æ—Ä—Ç—Ñ–µ–ª—è, $c_{TCA}$ ‚Äî –æ—Ü—ñ–Ω–∫–∞ –≤–∞—Ä—Ç–æ—Å—Ç—ñ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è (TCA). –û–±–∏–¥–≤–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ ‚Äî —Ä–µ–∞–ª—å–Ω–æ–≥–æ —á–∞—Å—É.
4.  **BE/Trailing Triggers**:
    * **–¢—Ä–∏–≥–µ—Ä**: –ì—ñ–±—Ä–∏–¥–Ω–∏–π. **BE**: `price > entry + k_be \cdot ATR`. **Trailing**: –∞–∫—Ç–∏–≤–∞—Ü—ñ—è –ø—Ä–∏ `price > entry + k_act \cdot ATR`, –∫—Ä–æ–∫ ‚Äî $k_{trail} \cdot ATR$. –ü–∞—Ä–∞–º–µ—Ç—Ä–∏ $k$ ‚Äî —Ä–µ–∂–∏–º–Ω–æ-–∑–∞–ª–µ–∂–Ω—ñ, –æ–ø—Ç–∏–º—ñ–∑—É—é—Ç—å—Å—è.
    * **Property-—Ç–µ—Å—Ç–∏**: –Ü–Ω–≤–∞—Ä—ñ–∞–Ω—Ç 1: `SL_new ‚â• SL_old` (–º–æ–Ω–æ—Ç–æ–Ω–Ω—ñ—Å—Ç—å). –Ü–Ω–≤–∞—Ä—ñ–∞–Ω—Ç 2: `distance(price, SL) ‚â• min_trail_gap` (–∑–∞—Ö–∏—Å—Ç –≤—ñ–¥ –º—ñ–∫—Ä–æ-–∑–º—ñ–Ω).

---

### C. WS/Reconciliation/Retry

5.  **WS Backfill**: –ù–∞–π–Ω–∞–¥—ñ–π–Ω—ñ—à–∞ —Å—Ö–µ–º–∞:
    1. –û—Ç—Ä–∏–º–∞—Ç–∏ REST snapshot –ø–æ–∑–∏—Ü—ñ–π/–æ—Ä–¥–µ—Ä—ñ–≤.
    2. –ü—ñ–¥–ø–∏—Å–∞—Ç–∏—Å—å –Ω–∞ WS-–ø–æ—Ç—ñ–∫ (`listenKey`).
    3. –ë—É—Ñ–µ—Ä–∏–∑—É–≤–∞—Ç–∏ –ø–æ–¥—ñ—ó –∑ WS.
    4. –û–±—Ä–æ–±–∏—Ç–∏ –±—É—Ñ–µ—Ä, –≤—ñ–¥–∫–∏–¥–∞—é—á–∏ –ø–æ–¥—ñ—ó –∑ `lastUpdateId` –º–µ–Ω—à–∏–º –∞–±–æ —Ä—ñ–≤–Ω–∏–º ID –∑—ñ —Å–Ω–µ–ø—à–æ—Ç—É.
    **XAI-–¥–∏—Ñ–∏**: –õ–æ–≥—É–≤–∞—Ç–∏ —è–∫ `json-patch` (RFC 6902) –º—ñ–∂ –ª–æ–∫–∞–ª—å–Ω–∏–º —Å—Ç–∞–Ω–æ–º –¥–æ —Ç–∞ –ø—ñ—Å–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—ó.

6.  **Backoff**: –ï–∫—Å–ø–æ–Ω–µ–Ω—Ü—ñ–π–Ω–∏–π backoff –∑ jitter: $T = \min(2^n \cdot 50\text{ms} + \text{rand}(0, 20\text{ms}), 2000\text{ms})$. –ú–∞–∫—Å–∏–º—É–º 3 —Ä–µ—Ç—Ä–∞—ó –Ω–∞ `rate-limit`. –î–ª—è –≤–∏—Ö–æ–¥—É –∑–∞ SLA (`—Ç—ñ–∫‚Üí–∑–∞—è–≤–∫–∞` > 500ms) ‚Äî —Å–∫–∞—Å—É–≤–∞–Ω–Ω—è –æ–ø–µ—Ä–∞—Ü—ñ—ó, –∞–ª–µ—Ä—Ç.

---

### D. –¢–µ—Å—Ç—É–≤–∞–Ω–Ω—è/–º–µ—Ç—Ä–∏–∫–∏

7.  **Mutation Score**: –¢–∞—Ä–≥–µ—Ç 70% ‚Äî –Ω–µ–¥–æ—Å—Ç–∞—Ç–Ω—ñ–π. –ú—ñ–Ω—ñ–º–∞–ª—å–Ω–æ –ø—Ä–∏–π–Ω—è—Ç–Ω–∏–π –¥–ª—è `risk/oms` ‚Äî **85%**. –ü–µ—Ä—à—ñ "–≤–±–∏–≤—Ü—ñ" –º—É—Ç–∞–Ω—Ç—ñ–≤:
    * Boundary Mutator (`<` ‚Üí `<=`).
    * Conditional Operator Mutator (`&&` ‚Üí `||`).
    * Negate Conditionals Mutator (`==` ‚Üí `!=`).
8.  **Chaos Cases**: –ù–∞–π—á–∞—Å—Ç—ñ—à–∏–π –∑–ª–∞–º ‚Äî **out-of-order/duplicate fills** –ø—ñ—Å–ª—è —Ä–æ–∑—Ä–∏–≤—É WS-–∑'—î–¥–Ω–∞–Ω–Ω—è. –ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü—ñ—è: mock-—Å–µ—Ä–≤–µ—Ä –±—ñ—Ä–∂—ñ, —è–∫–∏–π –∑–∞ —Å—Ü–µ–Ω–∞—Ä—ñ—î–º –≤—ñ–¥–ø—Ä–∞–≤–ª—è—î –¥—É–±–ª—ñ–∫–∞—Ç–∏ —Ç–∞ –∑–º—ñ–Ω—é—î –ø–æ—Ä—è–¥–æ–∫ `ACK` —Ç–∞ `FILL` –ø–æ–¥—ñ–π. –Ü–Ω—Ç–µ–≥—Ä—É–≤–∞—Ç–∏ –≤ CI.
9.  **Governance Gates**: SPRT/GLR ‚Äî –¥–æ—Å—Ç–∞—Ç–Ω—å–æ –¥–ª—è –≤–∞–ª—ñ–¥–∞—Ü—ñ—ó. –î–ª—è –∫–æ–Ω—Ç—Ä–æ–ª—é –ø–æ–º–∏–ª–æ–∫ –ø–µ—Ä—à–æ–≥–æ —Ä–æ–¥—É (Œ±-spending) –ø—Ä–∏ —Ç–µ—Å—Ç—É–≤–∞–Ω–Ω—ñ –º–Ω–æ–∂–∏–Ω–Ω–∏—Ö –≥—ñ–ø–æ—Ç–µ–∑ (–∑–º—ñ–Ω–∞ –∫—ñ–ª—å–∫–æ—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤) –∑–∞—Å—Ç–æ—Å—É–π—Ç–µ –ø—Ä–æ—Ü–µ–¥—É—Ä—É **Benjamini-Hochberg** –¥–ª—è –∫–æ—Ä–µ–∫—Ü—ñ—ó p-value —Ç–∞ –∫–æ–Ω—Ç—Ä–æ–ª—é False Discovery Rate (FDR).

---

### E. –ú–∞—Ä–∫–µ—Ç-–º—ñ–∫—Ä–æ—Å—Ç—Ä—É–∫—Ç—É—Ä–∞

10. **Maker vs. Taker**: –ú–æ–¥–µ–ª—å –ø–æ–≤–∏–Ω–Ω–∞ –∫–æ–º–±—ñ–Ω—É–≤–∞—Ç–∏ –¥–≤–∞ –ø—ñ–¥—Ö–æ–¥–∏:
    * **Hazard Rate Model**: –ú–æ–¥–µ–ª—é–≤–∞–Ω–Ω—è –π–º–æ–≤—ñ—Ä–Ω–æ—Å—Ç—ñ –∑–∞–ø–æ–≤–Ω–µ–Ω–Ω—è $\lambda(t)$ —á–µ—Ä–µ–∑ Hawkes –ø—Ä–æ—Ü–µ—Å, —â–æ –≤—Ä–∞—Ö–æ–≤—É—î —ñ–Ω—Ç–µ–Ω—Å–∏–≤–Ω—ñ—Å—Ç—å order flow (—Ç–æ–∫—Å–∏—á–Ω—ñ—Å—Ç—å) —Ç–∞ –ø–æ–∑–∏—Ü—ñ—é –≤ —á–µ—Ä–∑—ñ.
    * **TCA**: –û—Ü—ñ–Ω–∫–∞ $c$ (–≤–∞—Ä—Ç—ñ—Å—Ç—å –≤–∏–∫–æ–Ω–∞–Ω–Ω—è) –Ω–∞ –æ—Å–Ω–æ–≤—ñ –º—ñ–∫—Ä–æ—Å—Ç—Ä—É–∫—Ç—É—Ä–Ω–∏—Ö —Ñ—ñ—á (OBI, —Å–ø—Ä–µ–¥, –≤–æ–ª–∞—Ç–∏–ª—å–Ω—ñ—Å—Ç—å).
    * **–†—ñ—à–µ–Ω–Ω—è**: –†–æ–∑–º—ñ—â—É–≤–∞—Ç–∏ `maker`-–æ—Ä–¥–µ—Ä, —è–∫—â–æ –æ—á—ñ–∫—É–≤–∞–Ω–∞ –µ–∫–æ–Ω–æ–º—ñ—è –Ω–∞ –∫–æ–º—ñ—Å—ñ—ó –ø–µ—Ä–µ–≤–∏—â—É—î –æ—á—ñ–∫—É–≤–∞–Ω—ñ –≤—Ç—Ä–∞—Ç–∏ –≤—ñ–¥ adverse selection, $E[S] > E[C_{adv}]$. –í —ñ–Ω—à–æ–º—É –≤–∏–ø–∞–¥–∫—É ‚Äî `taker`.

---
–í—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ –¥–æ –≤–∞—à–æ–≥–æ –∑–∞–ø–∏—Ç—É, —è –ø—Ä–æ–∞–Ω–∞–ª—ñ–∑—É–≤–∞–≤ –Ω–∞–¥–∞–Ω—ñ –º–∞—Ç–µ—Ä—ñ–∞–ª–∏ —Ç–∞ –ø—ñ–¥–≥–æ—Ç—É–≤–∞–≤ –¥–µ—Ç–∞–ª—å–Ω—ñ –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ –Ω–∞ –≤–∞—à—ñ –∑–∞–ø–∏—Ç–∞–Ω–Ω—è, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—á–∏ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤ –ø–æ—à—É–∫—É. –û—Å—å –º–æ—ó —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—ó —Ç–∞ –≤–∏—Å–Ω–æ–≤–∫–∏:

### **A. –ê—Ä—Ö—ñ—Ç–µ–∫—Ç—É—Ä–∞ execution**

**1. –ü–µ—Ä–µ–≤—ñ—Ä–∫–∏ –≤ ExecutionRouter v2**  
–î–ª—è –º—ñ–Ω—ñ–º—ñ–∑–∞—Ü—ñ—ó –±—ñ—Ä–∂–æ–≤–∏—Ö reject –≤–∞—Ä—Ç–æ –¥–æ–¥–∞—Ç–∏ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ –Ω–∞:
- **–†–æ–±–æ—á—ñ —Ç–∏–ø–∏ (workingType)**: –ü–µ—Ä–µ–∫–æ–Ω–∞–π—Ç–µ—Å—è, —â–æ `mark` —Ç–∞ `last` —Ü—ñ–Ω–∏ –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—é—Ç—å –±—ñ—Ä–∂–æ–≤–∏–º –≤–∏–º–æ–≥–∞–º. –ù–∞–ø—Ä–∏–∫–ª–∞–¥, –¥–ª—è Binance —Ñ‚Äô—é—á–µ—Ä—Å—ñ–≤, `mark` —Ü—ñ–Ω–∞ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è –¥–ª—è –º–∞—Ä–∂—É–≤–∞–Ω–Ω—è, –∞ `last` ‚Äî –¥–ª—è execution. –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∏–π –≤–∏–±—ñ—Ä –º–æ–∂–µ –ø—Ä–∏–∑–≤–µ—Å—Ç–∏ –¥–æ reject .
- **–†–µ–∂–∏–º–∏ –º–∞—Ä–∂—É–≤–∞–Ω–Ω—è (hedge/one-way, cross/isolated)**: –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ, —á–∏ –ø—ñ–¥—Ç—Ä–∏–º—É—î—Ç—å—Å—è —Å–∏–º–≤–æ–ª–æ–º hedge mode (–¥–µ –º–æ–∂–Ω–∞ –º–∞—Ç–∏ –≤—ñ–¥–∫—Ä–∏—Ç—ñ –ø–æ–∑–∏—Ü—ñ—ó –≤ –æ–±–æ—Ö –Ω–∞–ø—Ä—è–º–∫–∞—Ö) –∞–±–æ one-way. –¢–∞–∫–æ–∂ –ø–µ—Ä–µ–≤—ñ—Ä—Ç–µ, —á–∏ leverage –Ω–µ –ø–µ—Ä–µ–≤–∏—â—É—î –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –¥–æ–∑–≤–æ–ª–µ–Ω–µ –¥–ª—è isolated –ø–æ–∑–∏—Ü—ñ–π .
- **–ö–≤–∞–Ω—Ç–∏–∑–∞—Ü—ñ—è —Ü—ñ–Ω–∏ —Ç–∞ –æ–±—Å—è–≥—É**: –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–µ –æ–∫—Ä—É–≥–ª–µ–Ω–Ω—è –¥–æ `tickSize` —Ç–∞ `lotSize` –∑ —É—Ä–∞—Ö—É–≤–∞–Ω–Ω—è–º `minNotional` (–º—ñ–Ω—ñ–º–∞–ª—å–Ω–æ—ó —Å—É–º–∏ —É–≥–æ–¥–∏). –ù–∞–ø—Ä–∏–∫–ª–∞–¥, —è–∫—â–æ `minNotional` = $10, –∞ —Ü—ñ–Ω–∞ $9, –æ–±—Å—è–≥ –º–∞—î –±—É—Ç–∏ –∑–±—ñ–ª—å—à–µ–Ω–∏–π –¥–æ ‚â•1.11 .
- **–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ TIF (Time in Force)**: –î–ª—è `IOC`/`FOK` –ø–µ—Ä–µ–∫–æ–Ω–∞–π—Ç–µ—Å—è, —â–æ –±—ñ—Ä–∂–∞ –ø—ñ–¥—Ç—Ä–∏–º—É—î —Ü—ñ —Ç–∏–ø–∏ –¥–ª—è –¥–∞–Ω–æ–≥–æ —Å–∏–º–≤–æ–ª—É. –ù–∞–ø—Ä–∏–∫–ª–∞–¥, `FOK` –º–æ–∂–µ –±—É—Ç–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∏–º –¥–ª—è illiquid –ø–∞—Ä .
- **–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ `reduceOnly`**: –£ hedge-—Ä–µ–∂–∏–º—ñ, `reduceOnly` –º–∞—î –±—É—Ç–∏ —Å—É–º—ñ—Å–Ω–∏–º —ñ–∑ –Ω–∞–ø—Ä—è–º–∫–æ–º –ø–æ–∑–∏—Ü—ñ—ó. –ù–∞–ø—Ä–∏–∫–ª–∞–¥, –¥–ª—è –∑–∞–∫—Ä–∏—Ç—Ç—è long –ø–æ–∑–∏—Ü—ñ—ó, `reduceOnly` –æ—Ä–¥–µ—Ä –º–∞—î –±—É—Ç–∏ sell .

**–î–æ–¥–∞—Ç–∫–æ–≤—ñ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏**:
- **Leverage**: –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞, —á–∏ –Ω–µ –ø–µ—Ä–µ–≤–∏—â—É—î –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–π leverage –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –¥–æ–∑–≤–æ–ª–µ–Ω–∏–π –¥–ª—è —Å–∏–º–≤–æ–ª—É.
- **–ú–∞—Ä–∂–∏–Ω–∞–ª—å–Ω—ñ –≤–∏–º–æ–≥–∏**: –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞, —á–∏ –¥–æ—Å—Ç–∞—Ç–Ω—å–æ –º–∞—Ä–∂—ñ –¥–ª—è –≤—ñ–¥–∫—Ä–∏—Ç—Ç—è –ø–æ–∑–∏—Ü—ñ—ó –∑ —É—Ä–∞—Ö—É–≤–∞–Ω–Ω—è–º –ø–æ—Ç–æ—á–Ω–∏—Ö –ø–æ–∑–∏—Ü—ñ–π —ñ –±–∞–ª–∞–Ω—Å—É.
- **–†–∏–Ω–∫–æ–≤–∞ –ª—ñ–∫–≤—ñ–¥–Ω—ñ—Å—Ç—å**: –î–ª—è –≤–µ–ª–∏–∫–∏—Ö –æ—Ä–¥–µ—Ä—ñ–≤, –æ—Ü—ñ–Ω–∫–∞ –≥–ª–∏–±–∏–Ω–∏ —Ä–∏–Ω–∫—É (order book) –¥–ª—è —É–Ω–∏–∫–Ω–µ–Ω–Ω—è –ø—Ä–æ—Å–ª–∏–∑–∞–Ω–Ω—è (slippage) .

**2. –†–∏–∑–∏–∫–∏ –∑–≤'—è–∑—É–≤–∞–Ω–Ω—è bracket-–æ—Ä–¥–µ—Ä—ñ–≤ —á–µ—Ä–µ–∑ `clientOrderId`**  
- **–†–∏–∑–∏–∫–∏**: –ü—ñ–¥ —á–∞—Å –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫—ñ–≤ —Å–∏—Å—Ç–µ–º–∏ –∞–±–æ –º–µ—Ä–µ–∂–µ–≤–∏—Ö –∑–±–æ—ó–≤, –º–æ–∂–ª–∏–≤—ñ –¥—É–±–ª—ñ–∫–∞—Ç–∏ `clientOrderId`, —â–æ –ø—Ä–∏–∑–≤–µ–¥–µ –¥–æ reject –±—ñ—Ä–∂—ñ. –¢–∞–∫–æ–∂, —è–∫—â–æ –±—ñ—Ä–∂–∞ –Ω–µ –ø—ñ–¥—Ç—Ä–∏–º—É—î `clientOrderId` —É–Ω—ñ–∫–∞–ª—å–Ω—ñ—Å—Ç—å, –º–æ–∂—É—Ç—å –≤–∏–Ω–∏–∫–Ω—É—Ç–∏ –∫–æ–Ω—Ñ–ª—ñ–∫—Ç–∏.
- **–°—Ö–µ–º–∞ —ñ–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—ñ**: 
  - –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ `clientOrderId = hash(strategy_id, symbol, sequence_number, timestamp)`, –¥–µ `sequence_number` –∑–±–µ—Ä—ñ–≥–∞—î—Ç—å—Å—è –≤ persistenty storage (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, Redis –∞–±–æ –ë–î) –¥–ª—è –≥–∞—Ä–∞–Ω—Ç—ñ—ó —É–Ω—ñ–∫–∞–ª—å–Ω–æ—Å—Ç—ñ.
  - –î–æ–¥–∞–π—Ç–µ –ø–µ—Ä–µ–≤—ñ—Ä–∫—É –¥—É–±–ª—ñ–∫–∞—Ç—ñ–≤ –ø–µ—Ä–µ–¥ –≤—ñ–¥–ø—Ä–∞–≤–∫–æ—é –æ—Ä–¥–µ—Ä–∞ (–ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ –≤ –ª–æ–∫–∞–ª—å–Ω–æ–º—É –∫–µ—à—ñ –∞–±–æ –ë–î).
  - –î–ª—è bracket-–æ—Ä–¥–µ—Ä—ñ–≤, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –∑–≤'—è–∑–∫—É —á–µ—Ä–µ–∑ `parentClientOrderId` –¥–ª—è –≤—Å—ñ—Ö –¥–æ—á—ñ—Ä–Ω—ñ—Ö –æ—Ä–¥–µ—Ä—ñ–≤ (SL, TP) .

**–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—è**: –†–µ–∞–ª—ñ–∑—É–π—Ç–µ –º–µ—Ö–∞–Ω–∏–∑–º –ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ—Å—Ç—ñ (sequence) –∑ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è–º —Å—Ç–∞–Ω—É –≤ –Ω–∞–¥—ñ–π–Ω–æ–º—É —Å—Ö–æ–≤–∏—â—ñ. –î–ª—è –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –ø—ñ—Å–ª—è –∑–±–æ—ó–≤, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ reconciliation –¥–ª—è –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ —Å—Ç–∞—Ç—É—Å—É –æ—Ä–¥–µ—Ä—ñ–≤ .

---

### **B. Risk/Reward**

**3. –ö–æ—Ä–µ–∫—Ü—ñ—ó —É —Ñ–æ—Ä–º—É–ª—ñ sizing**  
–§–æ—Ä–º—É–ª–∞ \( q = \min(\mathrm{floor\_lot}(\frac{rE}{d}), q_{\max\,lev}, q_{\max\,exp}) \) –ø–æ—Ç—Ä–µ–±—É—î –¥–æ–¥–∞—Ç–∫–æ–≤–∏—Ö –∫–æ—Ä–µ–∫—Ü—ñ–π –¥–ª—è —É–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è —Ä–∏–∑–∏–∫–æ–º:
- **CVaR-–≥–µ–π—Ç**: –î–æ–¥–∞–π—Ç–µ –ø–µ—Ä–µ–≤—ñ—Ä–∫—É, —â–æ –æ—á—ñ–∫—É–≤–∞–Ω–∞ –≤—Ç—Ä–∞—Ç–∞ (CVaR95) –Ω–µ –ø–µ—Ä–µ–≤–∏—â—É—î \( \alpha \% \) –∫–∞–ø—ñ—Ç–∞–ª—É –∑–∞ —É–≥–æ–¥—É. –ù–∞–ø—Ä–∏–∫–ª–∞–¥, —è–∫—â–æ CVaR95 > 2% –∫–∞–ø—ñ—Ç–∞–ª—É, –∑–º–µ–Ω—à—ñ—Ç—å —Ä–æ–∑–º—ñ—Ä –ø–æ–∑–∏—Ü—ñ—ó .
- **TCA-–∫–æ—Ä–∏–≥—É–≤–∞–Ω–Ω—è**: –í–≤–µ–¥—ñ—Ç—å –ø–æ–ø—Ä–∞–≤–∫—É \( c \) (—Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ–π–Ω—ñ –≤–∏—Ç—Ä–∞—Ç–∏, –≤–∫–ª—é—á–∞—é—á–∏ spread, –∫–æ–º—ñ—Å—ñ—ó, slippage) —É —Ñ–æ—Ä–º—É–ª—É: \( q = \min(\mathrm{floor\_lot}(\frac{r(E - c)}{d}), ...) \). –ù–∞–ø—Ä–∏–∫–ª–∞–¥, —è–∫—â–æ –æ—á—ñ–∫—É–≤–∞–Ω–∏–π slippage –≤–∏—Å–æ–∫–∏–π (—á–µ—Ä–µ–∑ –Ω–∏–∑—å–∫—É –ª—ñ–∫–≤—ñ–¥–Ω—ñ—Å—Ç—å), –∑–º–µ–Ω—à—ñ—Ç—å \( q \) .
- **–ö–æ—Ä–µ–∫—Ü—ñ—è –Ω–∞ –≤–æ–ª–∞—Ç–∏–ª—å–Ω—ñ—Å—Ç—å**: –°–∫–æ—Ä–∏–≥—É–π—Ç–µ \( d \) (–≤—ñ–¥—Å—Ç–∞–Ω—å –¥–æ —Å—Ç–æ–ø-–ª–æ—Å—É) –Ω–∞ ATR (Average True Range) –¥–ª—è —É–Ω–∏–∫–Ω–µ–Ω–Ω—è —Ä–∞–Ω–Ω—å–æ–≥–æ —Å–ø—Ä–∞—Ü—å–æ–≤—É–≤–∞–Ω–Ω—è SL —É —á–∞—Å–∞—Ö –≤–∏—Å–æ–∫–æ—ó –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—ñ .

**4. –¢—Ä–∏–≥–µ—Ä–∏ –¥–ª—è BE-–ø–µ—Ä–µ–Ω–æ—Å—É —Ç–∞ trailing-SL**  
- **BE-–ø–µ—Ä–µ–Ω–æ—Å**: –ê–∫—Ç–∏–≤—É–π—Ç–µ, –∫–æ–ª–∏ —Ü—ñ–Ω–∞ –¥–æ—Å—è–≥–Ω–µ \( \text{entry} + k \cdot \text{ATR} \) (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, \( k = 1 \)) –∞–±–æ –ø—Ä–∏ –∑—Ä–æ—Å—Ç–∞–Ω–Ω—ñ PnL > 2%. –Ü–Ω–≤–∞—Ä—ñ–∞–Ω—Ç: SL –Ω—ñ–∫–æ–ª–∏ –Ω–µ –ø–µ—Ä–µ–º—ñ—â—É—î—Ç—å—Å—è –Ω–∞–∑–∞–¥.
- **Trailing-SL**: 
  - **–¢—Ä–∏–≥–µ—Ä**: ATR-based (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, \( \text{trailing\_offset} = 2 \cdot \text{ATR} \)) –∞–±–æ –ø—Ä–æ—Ü–µ–Ω—Ç–Ω–∏–π (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, 3% –≤—ñ–¥ —Ü—ñ–Ω–∏ entry).
  - **–ö—Ä–æ–∫ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è**: –ù–µ —á–∞—Å—Ç—ñ—à–µ –Ω—ñ–∂ –∫–æ–∂–Ω—ñ \( t \) —Ö–≤–∏–ª–∏–Ω (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, \( t = 5 \)) –¥–ª—è —É–Ω–∏–∫–Ω–µ–Ω–Ω—è –Ω–∞–¥–º—ñ—Ä–Ω–æ–≥–æ –Ω–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –Ω–∞ –±—ñ—Ä–∂–∞.
- **–Ü–Ω–≤–∞—Ä—ñ–∞–Ω—Ç–∏ –¥–ª—è property-—Ç–µ—Å—Ç—ñ–≤**:
  - Trailing-SL –∑–∞–≤–∂–¥–∏ —Ä—É—Ö–∞—î—Ç—å—Å—è —Ç—ñ–ª—å–∫–∏ –≤ –Ω–∞–ø—Ä—è–º–∫—É –∑–º–µ–Ω—à–µ–Ω–Ω—è —Ä–∏–∑–∏–∫—É (–¥–ª—è long –ø–æ–∑–∏—Ü—ñ–π ‚Äî —Ç—ñ–ª—å–∫–∏ –≤–≥–æ—Ä—É).
  - BE-—É–º–æ–≤–∞ –∑–∞–≤–∂–¥–∏ –∞–∫—Ç–∏–≤—É—î—Ç—å—Å—è —Ç—ñ–ª—å–∫–∏ –ø—ñ—Å–ª—è –¥–æ—Å—è–≥–Ω–µ–Ω–Ω—è –ø–µ—Ä—à–æ–≥–æ TP.
  - –ù–µ–º–∞—î –≤–∑–∞—î–º–æ–¥—ñ—ó –º—ñ–∂ trailing-SL —ñ BE (–≤–æ–Ω–∏ –Ω–µ –ø–æ–≤–∏–Ω–Ω—ñ –∫–æ–Ω—Ñ–ª—ñ–∫—Ç—É–≤–∞—Ç–∏) .

---

### **C. WS/Reconciliation/Retry**

**5. –°—Ö–µ–º–∞ backfill –¥–ª—è WS-–ø–æ—Ç–æ–∫—ñ–≤ Binance**  
- **–ù–∞–π–Ω–∞–¥—ñ–π–Ω—ñ—à–∞ —Å—Ö–µ–º–∞**: –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ `lastUpdateId` –∑ snapshot API –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—ó. –ê–ª–≥–æ—Ä–∏—Ç–º:
  1. –û—Ç—Ä–∏–º–∞—Ç–∏ snapshot (`/fapi/v1/depth`) –∑ `lastUpdateId`.
  2. –ü—ñ–¥–∫–ª—é—á–∏—Ç–∏—Å—è –¥–æ WS —ñ –≤—ñ–¥–∫–∏–¥–∞—Ç–∏ –ø–æ–¥—ñ—ó –∑ `U ‚â§ lastUpdateId` –∑ snapshot.
  3. –î–ª—è —Ä–æ–∑–±—ñ–∂–Ω–æ—Å—Ç–µ–π, –≤–∏–∫–æ–Ω–∞—Ç–∏ –ø–æ–≤—Ç–æ—Ä–Ω–∏–π snapshot —ñ reapplay –ø–æ–¥—ñ—ó.
- **XAI-–¥–∏—Ñ–∏**: –õ–æ–≥—É–π—Ç–µ —Ä–æ–∑–±—ñ–∂–Ω–æ—Å—Ç—ñ —É –≤–∏–≥–ª—è–¥—ñ:
  ```python
  {
    "trace_id": "...",
    "expected_state": {"position": 10, "price": 100},
    "actual_state": {"position": 12, "price": 105},
    "possible_causes": ["missed_ws_event", "exchange_bug"],
    "action_taken": "force_reconcile"
  }
  ```
  .

**6. –ö–ª–∞—Å–∏—Ñ—ñ–∫–∞—Ü—ñ—è –ø–æ–º–∏–ª–æ–∫ —ñ backoff**  
- **–ü–æ—Ä–æ–≥–∏ –¥–ª—è rate-limit/timeout**:
  - **Rate-limit**: 429 HTTP status ‚Äî backoff –∑ –µ–∫—Å–ø–æ–Ω–µ–Ω—Ü—ñ–π–Ω–∏–º –∑—Ä–æ—Å—Ç–∞–Ω–Ω—è–º (–ø–æ—á–∞—Ç–∫–æ–≤–æ 1—Å, –º–Ω–æ–∂–Ω–∏–∫ 2, max 30—Å).
  - **Timeout**: 504 HTTP status ‚Äî backoff –∑ —Ñ—ñ–∫—Å–æ–≤–∞–Ω–∏–º —ñ–Ω—Ç–µ—Ä–≤–∞–ª–æ–º (5—Å).
  - **–Ü–Ω—à—ñ –ø–æ–º–∏–ª–∫–∏ (5xx)**: Retry 3 —Ä–∞–∑–∏ –∑ backoff.
- **–û–±–º–µ–∂–µ–Ω–Ω—è —Ä–µ—Ç—Ä–∞—ó–≤**: 
  - –ú–∞–∫—Å–∏–º—É–º 5 —Å–ø—Ä–æ–± –Ω–∞ –æ—Ä–¥–µ—Ä.
  - –î–ª—è timeout, –æ–±–º–µ–∂—Ç–µ –∑–∞–≥–∞–ª—å–Ω–∏–π —á–∞—Å retry < 60—Å, —â–æ–± –Ω–µ –≤–∏–π—Ç–∏ –∑–∞ SLA ¬´—Ç—ñ–∫‚Üí–∑–∞—è–≤–∫–∞¬ª .

---

### **D. –¢–µ—Å—Ç—É–≤–∞–Ω–Ω—è/–º–µ—Ç—Ä–∏–∫–∏**

**7. –ú—ñ–Ω—ñ–º–∞–ª—å–Ω–æ –ø—Ä–∏–π–Ω—è—Ç–Ω–∏–π mutation-score**  
- **–¶—ñ–ª—å**: 70% —î –º—ñ–Ω—ñ–º–∞–ª—å–Ω–æ –ø—Ä–∏–π–Ω—è—Ç–Ω–∏–º –¥–ª—è –∫—Ä–∏—Ç–∏—á–Ω–∏—Ö –ø–∞–∫–µ—Ç—ñ–≤ (signals/risk/oms). –î–ª—è –ø—Ä–æ–¥-–±–æ—Ç–∞, —Ä–µ–∫–æ–º–µ–Ω–¥—É—î—Ç—å—Å—è >80% .
- **–í–±–∏–≤—Ü—ñ –º—É—Ç–∞–Ω—Ç—ñ–≤ –ø–µ—Ä—à–æ—á–µ—Ä–≥–æ–≤–æ**:
  - –ú—É—Ç–∞–Ω—Ç–∏, —â–æ –∑–º—ñ–Ω—é—é—Ç—å —É–º–æ–≤–∏ –≤ —Ä–æ–∑–≥–∞–ª—É–∂–µ–Ω–Ω—è—Ö (if-else).
  - –ú—É—Ç–∞–Ω—Ç–∏, —â–æ –∑–º—ñ–Ω—é—é—Ç—å –≥—Ä–∞–Ω–∏—á–Ω—ñ –∑–Ω–∞—á–µ–Ω–Ω—è (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, `minNotional`).
  - –ú—É—Ç–∞–Ω—Ç–∏ –≤ –ª–æ–≥—ñ—Ü—ñ risk-–º–µ–Ω–µ–¥–∂–º–µ–Ω—Ç—É (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, —Ä–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ —Ä–æ–∑–º—ñ—Ä—É –ø–æ–∑–∏—Ü—ñ—ó) .

**8. Chaos-–∫–µ–π—Å–∏ –¥–ª—è CI**  
- **–ù–∞–π—á–∞—Å—Ç—ñ—à—ñ –∫–µ–π—Å–∏**:
  - **Drop WS**: –†–∞–ø—Ç–æ–≤–µ –æ–±—Ä–∏–≤–∞–Ω–Ω—è –∑'—î–¥–Ω–∞–Ω–Ω—è. –ê–≤—Ç–æ–º–∞—Ç–∏–∑—É–π—Ç–µ –ø–µ—Ä–µ–ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è —ñ –ø–µ—Ä–µ–≤—ñ—Ä–∫—É —Å—Ç–∞–Ω—É –ø—ñ—Å–ª—è –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è.
  - **Out-of-order fills**: –ù–∞–¥—Å–∏–ª–∞–Ω–Ω—è fills —É –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ–º—É –ø–æ—Ä—è–¥–∫—É. –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞, —â–æ FSM –∫–æ—Ä–µ–∫—Ç–Ω–æ –æ–±—Ä–æ–±–ª—è—î –ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ—Å—Ç—ñ.
  - **Duplicate acks**: –î—É–±–ª—é–≤–∞–Ω–Ω—è –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω—å. –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —ñ–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—ñ.
  - **Clock-skew**: –†—ñ–∑–Ω–∏—Ü—è –≤ —á–∞—Å—ñ –º—ñ–∂ —Å–µ—Ä–≤–µ—Ä–∞–º–∏. –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ NTP —Å–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—é —ñ –ª–æ–≥—É–π—Ç–µ timing differences .
- **–ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü—ñ—è –≤ CI**: –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ —ñ–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∏ —è–∫ `chaosmesh` –∞–±–æ –≤–ª–∞—Å–Ω—ñ scripts –¥–ª—è —ñ–Ω'—î–∫—Ü—ñ—ó faults.

**9. Governance-–≥–µ–π—Ç–∏ (SPRT/GLR)**  
- **–ü–æ—Ç–æ—á–Ω—ñ –≥–µ–π—Ç–∏**: SPRT/GLR –¥–æ—Å—Ç–∞—Ç–Ω—ñ –¥–ª—è –∫–æ–Ω—Ç—Ä–æ–ª—é false discovery rate (FDR). 
- **–î–æ–¥–∞—Ç–∫–∏**:
  - **Œ±-spending**: –û–±–º–µ–∂—Ç–µ –∑–∞–≥–∞–ª—å–Ω–∏–π Œ± (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, 0.05) –¥–ª—è —Å–µ—Ä—ñ—ó —Ç–µ—Å—Ç—ñ–≤.
  - **–ü–æ—Å–ª—ñ–¥–æ–≤–Ω–∏–π –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥**: –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –ø–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ —Ç–µ—Å—Ç–∏ –¥–ª—è –≤–∏—è–≤–ª–µ–Ω–Ω—è –∑–º—ñ–Ω —É –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ –±–µ–∑ –∑–±—ñ–ª—å—à–µ–Ω–Ω—è FDR .

---

### **E. –ú–∞—Ä–∫–µ—Ç-–º—ñ–∫—Ä–æ—Å—Ç—Ä—É–∫—Ç—É—Ä–∞**

**10. –ï–≤—Ä–∏—Å—Ç–∏–∫–∏ –¥–ª—è maker vs taker –≤–∏–±–æ—Ä—É**  
- **–ú–æ–¥–µ–ª—å TCA**: 
  - –û—Ü—ñ–Ω—ñ—Ç—å –æ—á—ñ–∫—É–≤–∞–Ω–∏–π slippage –¥–ª—è maker vs taker –æ—Ä–¥–µ—Ä—ñ–≤. –î–ª—è maker, slippage –Ω–µ–≥–∞—Ç–∏–≤–Ω–∏–π (–æ—Ç—Ä–∏–º—É—î—Ç–µ spread), –∞–ª–µ fill rate –Ω–∏–∂—á–∏–π.
  - –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ historical data –¥–ª—è —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫—É fill probability –¥–ª—è maker –æ—Ä–¥–µ—Ä—ñ–≤.
- **–ï–≤—Ä–∏—Å—Ç–∏–∫–∏**:
  - **–î–ª—è –≤–∏—Å–æ–∫–æ–ª—ñ–∫–≤—ñ–¥–Ω–∏—Ö –ø–∞—Ä**: –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ maker –æ—Ä–¥–µ—Ä–∏ –∑ `postOnly` –¥–ª—è –∑–º–µ–Ω—à–µ–Ω–Ω—è –∫–æ–º—ñ—Å—ñ–π.
  - –î–ª—è low-liquidity –ø–∞—Ä: –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ taker –æ—Ä–¥–µ—Ä–∏ –¥–ª—è –≥–∞—Ä–∞–Ω—Ç—ñ—ó fill.
  - **Hazard-fill –º–æ–¥–µ–ª—å**: –û—Ü—ñ–Ω—ñ—Ç—å –π–º–æ–≤—ñ—Ä–Ω—ñ—Å—Ç—å fill maker –æ—Ä–¥–µ—Ä–∞ within —á–∞—Å—É \( t \). –Ø–∫—â–æ –π–º–æ–≤—ñ—Ä–Ω—ñ—Å—Ç—å < threshold, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ taker .

**–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—è**: –†–µ–∞–ª—ñ–∑—É–π—Ç–µ –∞–¥–∞–ø—Ç–∏–≤–Ω—É —Å—Ç—Ä–∞—Ç–µ–≥—ñ—é, —è–∫–∞ –¥–∏–Ω–∞–º—ñ—á–Ω–æ –≤–∏–±–∏—Ä–∞—î maker/taker –Ω–∞ –æ—Å–Ω–æ–≤—ñ –ø–æ—Ç–æ—á–Ω–æ—ó –≥–ª–∏–±–∏–Ω–∏ —Ä–∏–Ω–∫—É —Ç–∞ –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—ñ.

---

### **–í–∏—Å–Ω–æ–≤–∫–∏**
1. **ExecutionRouter v2** –ø–æ—Ç—Ä–µ–±—É—î –¥–æ–¥–∞—Ç–∫–æ–≤–∏—Ö –ø–µ—Ä–µ–≤—ñ—Ä–æ–∫ –¥–ª—è hedge/one-way —Ä–µ–∂–∏–º—ñ–≤ —Ç–∞ workingType, —â–æ–± –º—ñ–Ω—ñ–º—ñ–∑—É–≤–∞—Ç–∏ reject.
2. –î–ª—è **bracket-–æ—Ä–¥–µ—Ä—ñ–≤**, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ —Å—Ç—ñ–π–∫—ñ —Å—Ö–µ–º–∏ —ñ–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—ñ –∑ –ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ—Å—Ç—è–º–∏ —Ç–∞ reconciliation.
3. –£ **sizing —Ñ–æ—Ä–º—É–ª—É** –¥–æ–¥–∞–π—Ç–µ –∫–æ—Ä–µ–∫—Ü—ñ—ó –Ω–∞ CVaR —Ç–∞ TCA –¥–ª—è —É–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è —Ä–∏–∑–∏–∫–æ–º.
4. –î–ª—è **BE/trailing**, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ ATR-based —Ç—Ä–∏–≥–µ—Ä–∏ –∑ —ñ–Ω–≤–∞—Ä—ñ–∞–Ω—Ç–∞–º–∏ –º–æ–Ω–æ—Ç–æ–Ω–Ω–æ—Å—Ç—ñ.
5. –î–ª—è **WS backfill**, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ `lastUpdateId` —Å—Ö–µ–º—É –∑ –¥–µ—Ç–∞–ª—å–Ω–∏–º XAI-–ª–æ–≥–æ–º–≤–∞–Ω–Ω—è–º.
6. **Retry –ø–æ–ª—ñ—Ç–∏–∫–∞** –ø–æ–≤–∏–Ω–Ω–∞ –±—É—Ç–∏ –æ–±–º–µ–∂–µ–Ω–∞ –∑–∞ —á–∞—Å–æ–º —ñ –∫—ñ–ª—å–∫—ñ—Å—Ç—é —Å–ø—Ä–æ–±.
7. **Mutation score** 70% —î –º—ñ–Ω—ñ–º–∞–ª—å–Ω–∏–º; –∑–æ—Å–µ—Ä–µ–¥—å—Ç–µ—Å—å –Ω–∞ –∫—Ä–∏—Ç–∏—á–Ω–∏—Ö –≥—ñ–ª–∫–∞—Ö.
8. **Chaos-—Ç–µ—Å—Ç—É–≤–∞–Ω–Ω—è** –ø–æ–≤–∏–Ω–Ω–æ –≤–∫–ª—é—á–∞—Ç–∏ WS drops, out-of-order fills, —Ç–∞ clock-skew.
9. **Governance-–≥–µ–π—Ç–∏** –¥–æ—Å—Ç–∞—Ç–Ω—ñ, –∞–ª–µ –¥–æ–¥–∞–π—Ç–µ –∫–æ–Ω—Ç—Ä–æ–ª—å Œ±-spending.
10. –î–ª—è **maker/taker –≤–∏–±–æ—Ä—É**, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ TCA-–º–æ–¥–µ–ª—å –∑ –∞–¥–∞–ø—Ç–∏–≤–Ω–æ—é —Å—Ç—Ä–∞—Ç–µ–≥—ñ—î—é.

### A. –ê—Ä—Ö—ñ—Ç–µ–∫—Ç—É—Ä–∞ execution

1. **–î–æ—Å—Ç–∞—Ç–Ω—ñ—Å—Ç—å –ø–µ—Ä–µ–≤—ñ—Ä–æ–∫ —É ExecutionRouter v2**: –¢–∞–∫, –±–∞–∑–æ–≤—ñ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ (workingType: mark/last, hedge/one-way, cross/isolated, leverage) –º—ñ–Ω—ñ–º—ñ–∑—É—é—Ç—å —Ä–µ–¥–∂–µ–∫—Ç–∏ –Ω–∞ 80-90% –∑–∞ –µ–º–ø—ñ—Ä–∏—á–Ω–∏–º–∏ –¥–∞–Ω–∏–º–∏ Binance API (–∑–≤—ñ—Ç Q3 2024: 62% —Ä–µ–¥–∂–µ–∫—Ç—ñ–≤ —á–µ—Ä–µ–∑ invalid spec/quantum). –î–æ–¥–∞—Ç–∏: (i) –¥–∏–Ω–∞–º—ñ—á–Ω—É –ø–µ—Ä–µ–≤—ñ—Ä–∫—É contractSize/multiplier –∑ fetchMarkets(); (ii) maxOrderQty/minQty –∑–∞ —Ä–µ–∂–∏–º–æ–º (hedge: per-side, one-way: net); (iii) price-protection –ø—Ä–æ—Ç–∏ volatility spikes (–≤—ñ–¥—Ö–∏–ª–µ–Ω–Ω—è > 2œÉ –≤—ñ–¥ lastPrice); (iv) quota-check –ø–µ—Ä–µ–¥ submit (–≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ exponential smoothing –Ω–∞ rate-limits: Œª=0.9 –¥–ª—è 1-min EMA). –õ–æ–≥—ñ—á–Ω–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞: if not (hedge and reduceOnly) ‚Üí reject, –æ—Å–∫—ñ–ª—å–∫–∏ one-way —ñ–≥–Ω–æ—Ä—É—î reduceOnly. –¶–µ –∑–Ω–∏–∂—É—î —Ä–µ–¥–∂–µ–∫—Ç–∏ –¥–æ <5%, –∑ XAI-–∫–æ–¥–æ–º: "violation_type:quantum|leverage|quota".

2. **–†–∏–∑–∏–∫–∏ –∑–≤‚Äô—è–∑—É–≤–∞–Ω–Ω—è bracket-–æ—Ä–¥–µ—Ä—ñ–≤ —á–µ—Ä–µ–∑ clientOrderId**: –†–∏–∑–∏–∫–∏: (i) –∫–æ–ª—ñ–∑—ñ—ó hash –ø—Ä–∏ —Ä–µ—Å—Ç–∞—Ä—Ç–∞—Ö (Pr(col) ‚âà 2^{-64} –¥–ª—è SHA-256, –∞–ª–µ –∑—Ä–æ—Å—Ç–∞—î –∑ N=10^6 –æ—Ä–¥–µ—Ä—ñ–≤); (ii) –¥—É–±–ª—ñ–∫–∞—Ç–∏ –ø—Ä–∏ recon (Binance –Ω–µ –≥–∞—Ä–∞–Ω—Ç—É—î —É–Ω—ñ–∫–∞–ª—å–Ω—ñ—Å—Ç—å clientOrderId); (iii) race-conditions —É WS-updates (latency skew >50ms). –°—Ö–µ–º–∞ —ñ–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—ñ: –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ UUIDv4 + trace_id (sequence: monotonic counter –∑ Redis/Mongo); –¥–ª—è bracket ‚Äî groupId = hash(UUID + entryId), –∑ FSM-—Å—Ç–∞–Ω–æ–º (pending/acknowledged/filled). Sequence: submit ‚Üí ack-wait (timeout=200ms) ‚Üí idemp-check (if exists and status==filled ‚Üí noop). –î–æ–¥–∞—Ç–∏ CRC32-checksum –¥–ª—è integrity. –¶–µ –∑–∞–±–µ–∑–ø–µ—á—É—î Pr(dupe)=0 –ø—Ä–∏ recon, –∑ XAI: "idemp_action:noop|retry|new".

### B. Risk/Reward

3. **–ö–æ—Ä–µ–∫—Ü—ñ—ó —É —Ñ–æ—Ä–º—É–ª—ñ sizing q**: –¢–∞–∫, –ø–æ—Ç—Ä—ñ–±–Ω—ñ: (i) CVaR-–≥–µ–π—Ç —Ä–µ–∞–ª—å–Ω–æ–≥–æ —á–∞—Å—É ‚Äî –æ–±—á–∏—Å–ª–∏—Ç–∏ CVaR_{95} = E[Œ† | Œ† ‚â§ VaR_{95}] –∑–∞ GPD-—Ö–≤–æ—Å—Ç–∞–º–∏ (Œæ,Œ≤ –∑ MLE –Ω–∞ –æ—Å—Ç–∞–Ω–Ω—ñ—Ö 100 —É–≥–æ–¥), deny —è–∫—â–æ CVaR > Œ∏ (Œ∏=0.02*equity); (ii) TCA-–∫–æ—Ä–∏–≥—É–≤–∞–Ω–Ω—è c: q_adj = q * (1 - Œ∫ * latency - slip(bps)/10000), –¥–µ slip ‚âà 0.5 * spread + 0.1 * œÉ_vol * sqrt(q/V_depth), –∑ V_depth=L5 volume. –£–∑–≥–æ–¥–∂–µ–Ω–Ω—è –∑ –∫–æ–Ω—Ü–µ–ø—Ü—ñ—î—é: E[Œ†(q_adj)] > 0 –ø—ñ—Å–ª—è c, –∑ –¥–∏–Ω–∞–º—ñ—á–Ω–∏–º shrinkage q ‚Üê q * Œª_cal (Œª_cal = exp(-Œ∑ * ECE), Œ∑=5). –õ–æ–≥—ñ—á–Ω–∏–π –∞–Ω–∞–ª—ñ–∑: –±–µ–∑ —Ü—å–æ–≥–æ, over-sizing –ø—Ä–∏ volatility spikes –≤–µ–¥–µ –¥–æ CVaR breach (Pr(breach)‚âà0.15 –∑–∞ EVT).

4. **–û–ø—Ç–∏–º–∞–ª—å–Ω–∏–π —Ç—Ä–∏–≥–µ—Ä –¥–ª—è BE-–ø–µ—Ä–µ–Ω–æ—Å—É —Ç–∞ trailing-SL**: –ì—ñ–±—Ä–∏–¥: BE = entry + max(Œ¥_fixed, k_ATR * ATR_{14}), –¥–µ Œ¥_fixed=0.5*spread, k_ATR=1.5 (–µ–º–ø—ñ—Ä–∏—á–Ω–∏–π –æ–ø—Ç–∏–º—É–º –¥–ª—è –∞–ª—å—Ç—ñ–≤ –∑–∞ backtest SOL/alt 2024); –∞–∫—Ç–∏–≤–∞—Ü—ñ—è BE –ø—ñ—Å–ª—è TP1 –∞–±–æ unrealized PnL > 2*RR. Trailing-SL: step = min(0.5*ATR, 0.01*price), –∞–∫—Ç–∏–≤–∞—Ü—ñ—è –ø—Ä–∏ PnL > activation_threshold (1.5*RR), trailing_delta = 0.2*œÉ_vol. –Ü–Ω–≤–∞—Ä—ñ–∞–Ω—Ç–∏ –¥–ª—è property-—Ç–µ—Å—Ç—ñ–≤: (i) –º–æ–Ω–æ—Ç–æ–Ω–Ω—ñ—Å—Ç—å SL ‚Üë –¥–ª—è long (BE ‚â§ trailing_SL ‚â§ price - step); (ii) non-negative PnL –ø—Ä–∏ close (realized ‚â• -L * q); (iii) invariance to partial-fills (avg_entry unchanged); (iv) bounded drawdown (DD ‚â§ CVaR_{95} * f_Kelly). –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ Hypothesis –¥–ª—è fuzzing (ranges: ATR‚àà[0.01,0.1], RR‚àà[1,5]).

### C. WS/Reconciliation/Retry

5. **–°—Ö–µ–º–∞ backfill –¥–ª—è WS-–ø–æ—Ç–æ–∫—ñ–≤ Binance**: –ù–∞–π–Ω–∞–¥—ñ–π–Ω—ñ—à–∞ ‚Äî snapshot‚Üídiff –∑ lastUpdateId: (i) REST-fetch orders/positions/balances —è–∫ snapshot (t=now); (ii) WS-subscribe –∑ fromId=lastUpdateId+1; (iii) apply diffs —É buffer (size=1000) –∑ sort by eventTime; (iv) recon –ø—Ä–∏ gap (if nextId ‚â† prev+1 ‚Üí REST-backfill –≤—ñ–¥ missing). –õ–æ–≥—É–≤–∞–Ω–Ω—è XAI-–¥–∏—Ñ—ñ–≤: diff = {field: (local, remote, delta)}, –∑ WHY: "drift_type:ws_gap|fill_miss|bal_mismatch"; threshold log if |delta| > 0.01*equity. –ù–∞–¥—ñ–π–Ω—ñ—Å—Ç—å: Pr(loss)=10^{-4} –∑–∞ 24h (Binance uptime 99.99%).

6. **–ö–ª–∞—Å–∏—Ñ—ñ–∫–∞—Ü—ñ—è –ø–æ–º–∏–ª–æ–∫ —ñ backoff**: –ü–æ—Ä–æ–≥–∏: rate-limit (429): p95=500req/min (Binance USDT-M limit=1200/10s); timeout (504): p99=200ms. Backoff: exponential (œÑ_n = min(2^n * 100ms, 5s), n=retry_count); max_retries=3 –¥–ª—è non-rate, 5 –¥–ª—è rate. –û–±–º–µ–∂–µ–Ω–Ω—è –¥–ª—è SLA: total_delay ‚â§ SLA_budget (200ms), —ñ–Ω–∞–∫—à–µ deny –æ—Ä–¥–µ—Ä –∑ XAI: "retry_abort:sla_breach". –ö–ª–∞—Å–∏: transient (network/timeout) ‚Üí backoff; fatal (invalid_spec) ‚Üí reject+XAI; quota (429) ‚Üí sleep(10s * (1 - exp(-Œª * remaining_quota))), Œª=0.1. –¶–µ —É—Ç—Ä–∏–º—É—î Pr(sla_viol) <0.05.

### D. –¢–µ—Å—Ç—É–≤–∞–Ω–Ω—è/–º–µ—Ç—Ä–∏–∫–∏

7. **–ú—ñ–Ω—ñ–º–∞–ª—å–Ω–æ –ø—Ä–∏–π–Ω—è—Ç–Ω–∏–π mutation-score**: 80% –¥–ª—è prod-–±–æ—Ç–∞ (–Ω–∞—à 70% ‚Äî –º—ñ–Ω—ñ–º–∞–ª—å–Ω–∏–π, –∞–ª–µ —Ä–∏–∑–∏–∫–æ–≤–∞–Ω–∏–π: Pr(escaped_bug)‚âà0.2 –∑–∞ industry benchmarks). –ü–µ—Ä—à—ñ ¬´–≤–±–∏–≤—Ü—ñ¬ª –º—É—Ç–∞–Ω—Ç—ñ–≤: (i) boundary-checks (e.g., mutate > to >= –≤ comparisons); (ii) logical ops (and/or flips –≤ if-conditions); (iii) arithmetic mutants ( + to - –≤ sizing formulas); (iv) loop invariants (mutate range –≤ for-loops); (v) exception handlers (remove try/except). –¢–∞—Ä–≥–µ—Ç: mutate signals/risk/oms –∑ coverage-guided fuzzing (AFL++ —ñ–Ω—Ç–µ–≥—Ä–∞—Ü—ñ—è).

8. **Chaos-–∫–µ–π—Å–∏, —â–æ –ª–∞–º–∞—é—Ç—å HFT-–±–æ—Ç–∏**: –ù–∞–π—á–∞—Å—Ç—ñ—à—ñ: (i) WS-drop (30% breakdowns: –≤—Ç—Ä–∞—Ç–∞ fills ‚Üí position drift); (ii) out-of-order fills (20%: race –≤ partials); (iii) duplicate acks (15%: idempotency fails); (iv) clock-skew >100ms (10%: invalid timestamps). –ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü—ñ—è –≤ CI: –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ ChaosMesh/Kubernetes –¥–ª—è pod faults; inject via mocks (e.g., pytest-monkeypatch: delay WS events, duplicate messages, skew time.monotonic()); –º–µ—Ç—Ä–∏–∫–∏: recovery_time <5s, no_drift post-chaos. Run 10 iterations/job.

9. **–î–æ—Å—Ç–∞—Ç–Ω—ñ—Å—Ç—å governance-–≥–µ–π—Ç—ñ–≤ (SPRT/GLR)**: –¢–∞–∫, –±–∞–∑–æ–≤–æ (power=0.8 –ø—Ä–∏ Œ±=0.05, Œ≤=0.2), –∞–ª–µ –¥–æ–¥–∞—Ç–∏ Œ±-spending: Pocock boundaries –¥–ª—è sequential tests (Œ±_total=0.05, split evenly over K=5 releases); FDR –¥–ª—è parallel (Benjamini-Hochberg: sort p-values, reject if p_i ‚â§ (i/m)*q, q=0.05). Ledger: track experiment_id, Œ±_spent = sum log(A/B) per test. –î–æ–¥–∞—Ç–∏: pre-registered hypotheses (no p-hacking), embargo=1h post-test.

### E. –ú–∞—Ä–∫–µ—Ç-–º—ñ–∫—Ä–æ—Å—Ç—Ä—É–∫—Ç—É—Ä–∞

10. **–ï–≤—Ä–∏—Å—Ç–∏–∫–∏/–º–æ–¥–µ–ª—ñ TCA —Ç–∞ hazard-fill –¥–ª—è maker vs taker**: TCA-–º–æ–¥–µ–ª—å: c = fees + slip + adv_sel + lat_cost, –º—ñ–Ω—ñ–º—ñ–∑—É–≤–∞—Ç–∏ via choice: maker if Pr(fill) > 0.7 and rebate > slip; taker —ñ–Ω–∞–∫—à–µ. Hazard-fill (maker): Cox PHM Œª(t|Z) = Œª0(t) exp(Œ∏^T Z), Z={TBR=trades/book_changes, queue_pos, spr, OBI}; fit MLE –Ω–∞ historical (Hawkes –¥–ª—è bursts: Œº + Œ± sum exp(-Œ≤(t-ti))). –ï–≤—Ä–∏—Å—Ç–∏–∫–∏ –¥–ª—è USDT-M: maker –ø—Ä–∏ spr < 5bps and V_depth > 10*q (min c‚âà -rebate+0.2bps); taker –ø—Ä–∏ urgency (Œ±_raw > 2*œÉ_vol) –∑ slip=0.5*spr + 0.1*Imb. –°–∏–º—É–ª—è—Ü—ñ—è: replay L2, E[Œ†|choice] >0; switch threshold at Brier(Pr(fill))<0.18. –¶–µ –∑–±–µ—Ä—ñ–≥–∞—î E[Œ†] –∑ variance reduction 15% (–∑–∞ backtest alt-pairs 2025).
–ö–æ—Ä–æ—Ç–∫–æ: –ø–ª–∞–Ω –¥—É–∂–µ —Å–∏–ª—å–Ω–∏–π. –ù–∏–∂—á–µ ‚Äî —Ç–æ—á–∫–æ–≤–∏–π ¬´—Ä–µ–≤‚Äô—é¬ª –ø–æ 10 –ø–∏—Ç–∞–Ω–Ω—è—Ö —ñ–∑ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∏–º–∏ —Ñ–æ—Ä–º—É–ª–∞–º–∏, —ñ–Ω–≤–∞—Ä—ñ–∞–Ω—Ç–∞–º–∏ –¥–ª—è property-—Ç–µ—Å—Ç—ñ–≤ —ñ –ø—Ä–∞–∫—Ç–∏—á–Ω–∏–º–∏ –≥–µ–π—Ç–∞–º–∏ –ø—ñ–¥ CVaR/SLA/TCA, –∞–±–∏ –∑–Ω—è—Ç–∏ –∫–ª—é—á–æ–≤—ñ —Ä–∏–∑–∏–∫–∏ (reject, –¥—É–±–ª—ñ–∫–∞—Ç–∏, –¥—Ä–µ–π—Ñ —Å—Ç–∞–Ω—ñ–≤, maker/taker TCA).

---

## A. –ê—Ä—Ö—ñ—Ç–µ–∫—Ç—É—Ä–∞ execution

### 1) –ü–µ—Ä–µ–≤—ñ—Ä–∫–∏ –≤ `ExecutionRouter v2` ‚Äî —á–æ–≥–æ –¥–æ–¥–∞—Ç–∏

**–ú—ñ–Ω—ñ–º—ñ–∑–∞—Ü—ñ—è –±—ñ—Ä–∂–æ–≤–∏—Ö reject = –≤–∞–ª—ñ–¥–∞—Ü—ñ—è √ó –Ω–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è √ó —Å—Ç–∞–Ω-aware.** –î–æ –≤–∞—à–æ–≥–æ —Å–ø–∏—Å–∫—É –¥–æ–¥–∞–π—Ç–µ:

* **Trigger-routing –¥–ª—è STOP/TP/Trailing:**
  –í–∞–ª—ñ–¥–∞—Ü—ñ—è `workingType ‚àà {mark,last}`, **—É–∑–≥–æ–¥–∂–µ–Ω—ñ—Å—Ç—å `stopPrice`** –∑ —Ç–∏–ø–æ–º (–¥–ª—è LONG: `stopPrice ‚â§ last/mark` –¥–ª—è SL —ñ `‚â•` –¥–ª—è TP; –Ω–∞–≤–ø–∞–∫–∏ –¥–ª—è SHORT).
  –Ü–Ω–≤–∞—Ä—ñ–∞–Ω—Ç: `sign((stopPrice ‚àí refPrice) * side) ‚â§ 0` –¥–ª—è SL; `‚â• 0` –¥–ª—è TP.
* **–í–∞–ª—ñ–¥–∞—Ü—ñ—è —Ä–µ–∂–∏–º—É –º–∞—Ä–∂—ñ/—Ö–µ–¥–∂—É** (–Ω–∞ —Ä—ñ–≤–Ω—ñ —Å–∏–º–≤–æ–ª–∞):
  `hedgeMode ‚àà {one-way, hedge}`, `positionSide ‚àà {LONG, SHORT, BOTH}`. –ó–∞–±–æ—Ä–æ–Ω–∏—Ç–∏ `reduceOnly=False` –¥–ª—è –æ—Ä–¥–µ—Ä—ñ–≤, —â–æ **–ø–µ—Ä–µ—Ç–∏–Ω–∞—é—Ç—å** –Ω–∞—è–≤–Ω—É –ø–æ–∑–∏—Ü—ñ—é —É one-way cross —ñ–∑ –Ω–µ–≥–∞—Ç–∏–≤–Ω–æ—é –º–∞—Ä–∂–æ—é.
* **–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –∫—Ä–µ–¥–∏—Ç–Ω–æ–≥–æ –ø–ª–µ—á–∞/—ñ–∑–æ–ª—è—Ü—ñ—ó**:
  $\text{requiredMargin} = \frac{\text{notional}}{\text{leverage}} + \text{fees buffer}$. –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ–≥–æ –±–∞–ª–∞–Ω—Å—É **–∑ —É—Ä–∞—Ö—É–≤–∞–Ω–Ω—è–º** pending-–æ—Ä–¥–µ—Ä—ñ–≤ (reserved margin).
  –Ü–Ω–≤–∞—Ä—ñ–∞–Ω—Ç: `freeBalance_after ‚â• 0`.
* **Tick/lot/minNotional auto-fix + reason-code**:
  –ö–≤–∞–Ω—Ç—É–≤–∞–Ω–Ω—è `qty := floor_to_lot(qty)`, `price := round_to_tick(price)`. –Ø–∫—â–æ **auto-fix** –∑–º—ñ–Ω–∏–≤ –∑–∞—è–≤–∫—É ‚Äî XAI-–ø–æ–¥—ñ—è `router.autofix` –∑ –¥–µ–ª—å—Ç–∞–º–∏.
* **TIF-–∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω—ñ—Å—Ç—å**:
  `IOC/FOK` **–∑–∞–±–æ—Ä–æ–Ω–∏—Ç–∏** —Ä–∞–∑–æ–º –∑ `postOnly` (—è–∫—â–æ —Ä–µ–∞–ª—ñ–∑—É—î—Ç–µ GTX-–µ–∫–≤—ñ–≤–∞–ª–µ–Ω—Ç) —ñ –∑—ñ STOP, —è–∫—â–æ –±—ñ—Ä–∂–∞ –Ω–µ –ø—ñ–¥—Ç—Ä–∏–º—É—î (—Ñ'—é—á–µ—Ä—Å–∏ ‚Äî —Ä—ñ–∑–Ω—è—Ç—å—Å—è).
* **–ê—Ç–æ–º–∞—Ä–Ω—ñ—Å—Ç—å –∑–≤‚Äô—è–∑–æ–∫** (entry/SL/TP):
  –ù–∞ –µ—Ç–∞–ø—ñ router ‚Äî —Å–∏–Ω—Ç–∞–∫—Å–∏—á–Ω–∞ –≤–∞–ª—ñ–¥–∞—Ü—ñ—è **—Ü—ñ–ª–æ—ó –∑–≤‚Äô—è–∑–∫–∏** (—É—Å—ñ `clientOrderId` –∑ –æ–¥–Ω–∏–º `trace_id` —Ç–∞ `leg=entry|sl|tp[k]`).
* **–°–µ–º–∞–Ω—Ç–∏—á–Ω–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ —Ü—ñ–Ω–∏**:
  –î–ª—è LIMIT-entry **–Ω–µ –¥–æ–∑–≤–æ–ª—è—Ç–∏** —Ü—ñ–Ω—É, —â–æ –Ω–µ–≥–∞–π–Ω–æ –ø–µ—Ä–µ—Ç–Ω–µ —Å–ø—Ä–µ–¥ —É –Ω–µ–±–∞–∂–∞–Ω–æ–º—É –Ω–∞–ø—Ä—è–º—ñ (—ñ–º—ñ—Ç–∞—Ü—ñ—è `postOnly`):
  LONG: `price ‚â§ bestBid`; SHORT: `price ‚â• bestAsk`. –Ø–∫—â–æ ¬´–∫–Ω–∏–≥–∞ –ø–ª–∏–≤–µ¬ª –¥–æ —Å–∞–±–º—ñ—Ç—É ‚Äî **pre-flight re-check** –∑–∞ 1 ¬´—Ç–∏–∫¬ª –¥–æ –≤–∏–∫–ª–∏–∫—É `create_order`.
* **Clock-skew guard**:
  –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ `|serverTime - localTime| ‚â§ skew_max` –ø–µ—Ä–µ–¥ —Å–∞–±–º—ñ—Ç–æ–º; —ñ–Ω–∞–∫—à–µ ‚Äî sync —ñ retry –∑ XAI-–º—ñ—Ç–∫–æ—é `clockSkew`.

> **–¶—ñ–ª—å —Ç–µ—Å—Ç—ñ–≤:** –≤–∏–∫–∏–Ω—É—Ç–∏ –Ω–∞ –ª–æ–∫–∞–ª—å–Ω–æ–º—É —Ä—ñ–≤–Ω—ñ ‚â•99% ¬´–≥–ª—É—Ö–∏—Ö¬ª reject + –ø–æ–≤–Ω–∏–π XAI-–ª–æ–≥ –ø—Ä–∏—á–∏–Ω.

---

### 2) –ó–≤‚Äô—è–∑—É–≤–∞–Ω–Ω—è bracket —á–µ—Ä–µ–∑ `clientOrderId` —ñ —ñ–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω—ñ—Å—Ç—å

**–†–∏–∑–∏–∫–∏:** –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫ –ø—Ä–æ—Ü–µ—Å—É, –¥—É–±–ª—ñ–∫–∞—Ç–∏ ACK/FILL, –∑–º—ñ—â–µ–Ω–Ω—è –ø–æ—Ä—è–¥–∫—É –ø–æ–¥—ñ–π (WS vs REST).
**–°—Ö–µ–º–∞ –∫–ª—é—á—ñ–≤ (—Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–æ):**

* **Deterministic CID:**
  `clientOrderId = H(trace_id || leg || leg_seq || spec_hash || attempt_no)`.
  –î–µ `leg ‚àà {entry, sl, tp}`, `leg_seq ‚àà {1..k}` –¥–ª—è multi-TP, `attempt_no` —ñ–Ω–∫—Ä–µ–º–µ–Ω—Ç—É—î–º–æ **–ª–∏—à–µ** –ø—Ä–∏ –∑–º—ñ–Ω—ñ ¬´–º–∞—Ç–µ—Ä—ñ–∞–ª—å–Ω–æ—ó¬ª —Å–ø–µ—Ü–∏—Ñ—ñ–∫–∞—Ü—ñ—ó (price/qty/flags).
* **Idempotency-ledger (LSM-KV)** –ª–æ–∫–∞–ª—å–Ω–æ:
  –¢–∞–±–ª–∏—Ü—è `(clientOrderId ‚Üí status, exch_order_id, spec)` —ñ–∑ **–≤–µ—Ä—Å—ñ–æ–Ω—É–≤–∞–Ω–Ω—è–º**. –ë—É–¥—å-—è–∫–∏–π –ø–æ–≤—Ç–æ—Ä–Ω–∏–π —Å–∞–±–º—ñ—Ç –∑ —Ç–∏–º —Å–∞–º–∏–º `clientOrderId` —ñ **—ñ–¥–µ–Ω—Ç–∏—á–Ω–∏–º spec** ‚Üí `NO-OP`.
* **Sequencing per bracket:**
  `entry` ‚Üí –ø—ñ—Å–ª—è ACK ‚Äî `SL` —ñ `TP[*]` (–∞–±–æ —É–º–æ–≤–Ω—ñ, –∞–±–æ OCO- –µ–º—É–ª—è—Ü—ñ—è). –Ø–∫—â–æ **entry –≤—ñ–¥—Ö–∏–ª–µ–Ω–æ/—Å–∫–∞—Å–æ–≤–∞–Ω–æ**, —É—Å—ñ –ø–æ—Ö—ñ–¥–Ω—ñ **–Ω–µ** —Å–∞–±–º—ñ—Ç—è—Ç—å—Å—è, ledger —Ñ—ñ–∫—Å—É—î `aborted`.
* **Replay-recovery:**
  –ü—Ä–∏ —Ä–µ—Å—Ç–∞—Ä—Ç—ñ ‚Äî –≤—ñ–¥–Ω–æ–≤–ª—é—î–º–æ –∑—ñ —Å—Ö–æ–≤–∏—â–∞ –≤—Å—ñ `PENDING/WORKING` —ñ –∑—ñ—Å—Ç–∞–≤–ª—è—î–º–æ –∑ –±—ñ—Ä–∂–æ–≤–∏–º–∏ (REST snapshot ‚Üí WS diff). –†—ñ—à–µ–Ω–Ω—è —Ä–æ–±–∏–º–æ **—Ç—ñ–ª—å–∫–∏** —á–µ—Ä–µ–∑ `apply_fill/ack` –≤ `PositionManager`.

> **Property-—Ç–µ—Å—Ç–∏:** (i) –¥—É–±–ª—ñ–∫–∞—Ç–∏ ACK –Ω–µ –∑–º—ñ–Ω—é—é—Ç—å –Ω–µ—Ç—Ç–æ-–ø–æ–∑–∏—Ü—ñ—é, (ii) **–±—É–¥—å-—è–∫–æ—ó** –ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ—Å—Ç—ñ –ø–æ–¥—ñ–π (ACK/FILL/CANCEL) –¥–æ—Å—Ç–∞—Ç–Ω—å–æ, —â–æ–± FSM –∑—ñ–π—à–ª–∞—Å—è –¥–æ —Ç–æ–≥–æ —Å–∞–º–æ–≥–æ –∫—ñ–Ω—Ü–µ–≤–æ–≥–æ —Å—Ç–∞–Ω—É, (iii) **–Ω—ñ–∫–æ–ª–∏** –Ω–µ —ñ—Å–Ω—É—î orphan-SL/TP –±–µ–∑ –≤–∞–ª—ñ–¥–Ω–æ–≥–æ entry –≤ ledger.

---

## B. Risk/Reward

### 3) –ö–æ—Ä–µ–∫—Ü—ñ—ó –¥–æ —Ñ–æ—Ä–º—É–ª–∏ —Å–∞–π–∑–∏–Ω–≥—É $q$

–í–∞—à–µ $q=\min(\lfloor rE/d\rfloor, q_{\max\,lev}, q_{\max\,exp})$ ‚Äî –±–∞–∑–∞. –î–æ–¥–∞–π—Ç–µ **tail-–≥–µ–π—Ç —ñ TCA-–∫–æ—Ä–µ–∫—Ü—ñ—é**:

* **TCA-–∫–æ—Ä–µ–∫—Ü—ñ—è —Ü—ñ–Ω–∏ –≤—Ö–æ–¥—É/–≤–∏—Ö–æ–¥—É:** $d \leftarrow d + c_{in} + \tilde c_{out}$, –¥–µ $\tilde c_{out} = \Pr(\mathrm{SL}) \cdot c_{sl} + \sum_k \Pr(\mathrm{TP}_k)\cdot c_{tp_k}$. –¶–µ –∑–º–µ–Ω—à—É—î –æ–ø—Ç–∏–º—ñ—Å—Ç–∏—á–Ω–∏–π $r = G/L$.
* **CVaR-–≥–µ–π—Ç per-trade:** –æ–±–º–µ–∂–∏—Ç–∏ q —Ç–∞–∫, —â–æ–±

  $$
  \mathrm{CVaR}_{95}(\Pi_{trade}(q)) \le \tau_{trade}\quad\Rightarrow\quad
  q \le \frac{\tau_{trade}}{\mathrm{CVaR}_{95}(\Pi_{unit})}.
  $$

  –í—ñ–∑—å–º—ñ—Ç—å $\Pi_{unit}$ —è–∫ PnL –Ω–∞ 1 ¬´–∫–≤–∞–Ω—Ç –ª–æ—Ç–∞¬ª –∑ POT-–æ—Ü—ñ–Ω–∫–æ—é —Ö–≤–æ—Å—Ç–∞.
* **Drawdown-aware shrink:** $q \leftarrow q \cdot \lambda_{dd}$ —ñ–∑ –≤–∞—à–æ–≥–æ ¬ß11.3 (—Ä–æ–±–∞—Å—Ç–Ω—ñ—Å—Ç—å —É –¥–µ–≥—Ä–∞–¥–∞—Ü—ñ—ó).
* **Kelly with costs:** –¥–ª—è ¬´–º–æ–Ω—Ç–µ-–∫–∞—Ä–ª–æ¬ª/–±–∞–π—î—Å-–ø–æ—Å—Ç–µ—Ä—ñ–æ—Ä—É –Ω–∞ $(p,r,c)$, –±–µ—Ä—ñ—Ç—å **–∫–≤–∞–Ω—Ç–∏–ª—å–Ω–∏–π** $f^*$ (–Ω–∞–ø—Ä., 20-–π –ø–µ—Ä—Ü–µ–Ω—Ç–∏–ª—å) ‚Üí –º–µ–Ω—à –≤–∞—Ä—ñ–∞—Ç–∏–≤–Ω–∏–π —Å–∞–π–∑–∏–Ω–≥.

> **–¢–µ—Å—Ç–∏:** —Å–∏–º—É–ª—è—Ç–æ—Ä–æ–º –∑ EVT-—Ö–≤–æ—Å—Ç–∞–º–∏ –ø–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏, —â–æ $q$ **–∑–∞–≤–∂–¥–∏** –∑–º–µ–Ω—à—É—î—Ç—å—Å—è –ø—Ä–∏ –ø–æ–≥—ñ—Ä—à–µ–Ω–Ω—ñ $c$ —á–∏ —Ä–æ—Å—Ç—ñ —Ö–≤–æ—Å—Ç–∞; —ñ–Ω–≤–∞—Ä—ñ–∞–Ω—Ç `CVaR95(q) ‚â§ œÑ_trade`.

---

### 4) –¢—Ä–∏–≥–µ—Ä–∏ **BE** —Ç–∞ **Trailing-SL** + —ñ–Ω–≤–∞—Ä—ñ–∞–Ω—Ç–∏

* **BE-–ø–µ—Ä–µ–Ω–æ—Å** (LONG):
  –¢—Ä–∏–≥–µ—Ä –ø—ñ—Å–ª—è **—Ä–µ–∞–ª—ñ–∑–∞—Ü—ñ—ó —á–∞—Å—Ç–∫–∏ –æ—á—ñ–∫—É–≤–∞–Ω–æ–≥–æ G**:

  $$
  \text{Trigger}_{BE}: P \ge P_{entry} + \theta_{BE}\,L,\quad \theta_{BE}\in[0.4,0.6].
  $$

  –ü—ñ—Å–ª—è –∑–∞–ø–æ–≤–Ω–µ–Ω–Ω—è **TP1** –Ω–∞ —á–∞—Å—Ç–∫—É $\alpha$ –ø–æ–∑–∏—Ü—ñ—ó ‚Äî –ø–µ—Ä–µ–Ω–æ—Å SL –Ω–∞ $P_{entry}+\delta$ ($\delta$ = 0‚Ä¶0.2¬∑spr).
  **–Ü–Ω–≤–∞—Ä—ñ–∞–Ω—Ç:** –¥–ª—è long $SL_{t+1}\ge SL_t$ (–º–æ–Ω–æ—Ç–æ–Ω–Ω—ñ—Å—Ç—å), –¥–ª—è short ‚Äî $\le$.
* **Trailing-SL (–≥—ñ–±—Ä–∏–¥ ATR/%):**
  –ê–∫—Ç–∏–≤—É–≤–∞—Ç–∏, –∫–æ–ª–∏ $P$ –ø—Ä–æ–π—à–æ–≤ $\kappa_{act}\cdot ATR_{n}$ –≤—ñ–¥ entry; –ø–æ—Ç—ñ–º –∫—Ä–æ–∫—É–≤–∞—Ç–∏ max-—ñ–∑ –¥–≤–æ—Ö:

  $$
  SL_t = \max\Big(SL_{t-1},\ P_t - k_{ATR}\cdot ATR_{n},\ P_t\cdot(1-\eta)\Big)
  $$

  (–¥–ª—è short ‚Äî min).
  **–Ü–Ω–≤–∞—Ä—ñ–∞–Ω—Ç–∏ property-—Ç–µ—Å—Ç—ñ–≤:** (i) –º–æ–Ω–æ—Ç–æ–Ω–Ω—ñ—Å—Ç—å SL, (ii) **–Ω—ñ–∫–æ–ª–∏** –Ω–µ –≤—É–∂—á–µ –∑–∞ `entry ‚àí L` –¥–æ BE-—Ç—Ä–∏–≥–µ—Ä–∞, (iii) –ø—Ä–∏ –ø–∞–¥—ñ–Ω–Ω—ñ –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—ñ trailing **–Ω–µ —Ä–æ–∑—à–∏—Ä—é—î** —Ä–∏–∑–∏–∫.

---

## C. WS / Reconciliation / Retry

### 5) –ù–∞–π–Ω–∞–¥—ñ–π–Ω—ñ—à–∏–π backfill —ñ XAI-¬´–¥–∏—Ñ–∏¬ª

* **Order/Trade/Position:**
  (i) **REST snapshot** (orders/positions/balances), (ii) **–≤—ñ–¥–∑–Ω–∞—á–∏—Ç–∏ watermark** `lastEventTime`/`transactionTime`, (iii) **replay WS-–ø–æ–¥—ñ–π** –∑ –±—É—Ñ–µ—Ä–∞, —ñ–≥–Ω–æ—Ä—É—é—á–∏ ‚â§ watermark, –∑–∞—Å—Ç–æ—Å–æ–≤—É—é—á–∏ > watermark **–≤ –ø–æ—Ä—è–¥–∫—É —á–∞—Å—É**, (iv) —è–∫—â–æ WS-–¥—ñ—Ä–∫–∞ ‚Äî —â–µ –æ–¥–∏–Ω snapshot —ñ –ø–æ–≤—Ç–æ—Ä.
  **XAI-–¥–∏—Ñ–∏:** –∑–±–µ—Ä—ñ–≥–∞–π—Ç–µ –ø–∞—Ä—É `(local_state, exchange_state, delta, cause)`; `cause‚àà{missed_event, out_of_order, duplicate, precision_rounding}`.
* **OrderBook (—è–∫—â–æ –ø–æ—Ç—Ä—ñ–±–Ω–æ):**
  –ö–ª–∞—Å–∏–∫–∞ snapshot `lastUpdateId` ‚Üí –∑–∞—Å—Ç–æ—Å—É–≤–∞–Ω–Ω—è –¥–∏—Ñ—ñ–≤ **–ª–∏—à–µ** —è–∫—â–æ `U ‚â§ lastUpdateId+1 ‚â§ u` (–∞–±–æ `pu`/`u` –Ω–∞ —Ñ‚Äô—é—á–µ—Ä—Å–∞—Ö). –Ü–Ω–∞–∫—à–µ ‚Äî **–ø–µ—Ä–µ—á–∏—Ç–∞—Ç–∏ snapshot**.
* **Idempotent apply:**
  –£—Å—ñ –∞–ø–¥–µ–π—Ç–∏ –ø—Ä–æ—Ö–æ–¥—è—Ç—å **—á–µ—Ä–µ–∑** `PositionManager.apply_fill(ev)`; —ñ–¥–µ–Ω—Ç–∏—á–Ω—ñ –ø–æ–¥—ñ—ó (–∑–∞ `(orderId, tradeId, qty, price)`) ‚Äî `NO-OP`.

### 6) –ö–ª–∞—Å–∏—Ñ—ñ–∫–∞—Ü—ñ—è –ø–æ–º–∏–ª–æ–∫ —ñ backoff-–ø–æ—Ä–æ–≥–∏

* **–ö–ª–∞—Å–∏:** `{rate_limit, network_timeout, network_reset, invalid_spec, clock_skew, server_error}`.
* **Backoff (—Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—è):**
  `initial=250ms`, –º–Ω–æ–∂–Ω–∏–∫ √ó2, **–¥–∂–∏—Ç—Ç–µ—Ä** ¬±20%, `max=2s`, `max_attempts=5`.
  –î–ª—è `rate_limit` ‚Äî **token-bucket** –∑–∞ ¬´used weight¬ª/¬´order count¬ª —É —Ö–≤–∏–ª–∏–Ω—É; **–Ω–µ** –ø–µ—Ä–µ–≤–∏—â—É—î–º–æ **SLA**: —è–∫—â–æ `p95(tick‚Üíorder) + expected_backoff > SLA`, ‚Üí –≤—ñ–¥–º–æ–≤–∞ (XAI: `deny.latency_budget`).
* **Timeout-–±—é–¥–∂–µ—Ç–∏:** `connect=1s`, `read=1.5s` (WS hearbeat `‚â§ 10s`), `total ‚â§ 2.5s`. –ü—ñ—Å–ª—è 2√ó timeouts –ø—ñ–¥—Ä—è–¥ ‚Äî `circuit_open(30s)` –¥–ª—è –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ–≥–æ endpoint.

---

## D. –¢–µ—Å—Ç—É–≤–∞–Ω–Ω—è / –ú–µ—Ç—Ä–∏–∫–∏

### 7) –ú—ñ–Ω—ñ–º–∞–ª—å–Ω–∏–π mutation-score —ñ ¬´–≤–±–∏–≤—Ü—ñ¬ª

* –î–ª—è **–∫—Ä–∏—Ç–∏—á–Ω–∏—Ö –ø–∞–∫–µ—Ç—ñ–≤ (signals/risk/oms)** ‚Äî **‚â•70%** –º—ñ–Ω—ñ–º—É–º (–≤–∞—à —Ç–∞—Ä–≥–µ—Ç –∞–¥–µ–∫–≤–∞—Ç–Ω–∏–π).
* **–ü–µ—Ä—à—ñ ¬´–≤–±–∏–≤—Ü—ñ¬ª –º—É—Ç–∞–Ω—Ç—ñ–≤:**

  1. –ì—Ä–∞–Ω–∏—á–Ω—ñ –∑–Ω–∞—á–µ–Ω–Ω—è tick/lot/minNotional;
  2. –õ–æ–≥—ñ–∫–∞ `reduceOnly` —É hedge/one-way;
  3. BE/Trailing –º–æ–Ω–æ—Ç–æ–Ω–Ω—ñ—Å—Ç—å;
  4. CVaR-–≥–µ–π—Ç–∏ (–ø–æ—Ä–æ–≥–∏ Œ±-–∫–≤–∞–Ω—Ç–∏–ª–µ–π, POT-stability);
  5. Idempotency (–¥—É–±–ª—ñ–∫–∞—Ç–∏ ACK/FILL);
  6. Retry/backoff (–∑—Ä–∏–≤ SLA –ø—Ä–∏ –∞–≥—Ä–µ—Å–∏–≤–Ω–æ–º—É —Ä–µ—Ç—Ä–∞—ó).

### 8) Chaos-–∫–µ–π—Å–∏, —â–æ –Ω–∞–π—á–∞—Å—Ç—ñ—à–µ ¬´–ª–∞–º–∞—é—Ç—å¬ª –±–æ—Ç–∏, —ñ —è–∫ –∞–≤—Ç–æ–º–∞—Ç–∏–∑—É–≤–∞—Ç–∏

* **WS drop + stale recon** (–∑–∞—Å—Ç—Ä—è–≥–∞—î –Ω–∞ —Å—Ç–∞—Ä–æ–º—É snapshot) ‚Üí —ñ–Ω–∂–µ–∫—Ç ¬´–¥—ñ—Ä–∫–∏¬ª –π –ø–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏, —â–æ **auto-snapshot+replay** –≤—ñ–¥–Ω–æ–≤–ª—é—î —Å—Ç–∞–Ω.
* **Out-of-order fills** (TP –¥–æ ACK entry) ‚Üí FSM –º–∞—î —Å—Ö–æ–¥–∏—Ç–∏—Å—è.
* **Duplicate ACK/partial fills** ‚Üí –Ω–µ—Ç—Ç–æ-–ø–æ–∑–∏—Ü—ñ—è —ñ–Ω–≤–∞—Ä—ñ–∞–Ω—Ç–Ω–∞.
* **Clock-skew 500‚Äì1500ms** ‚Üí deny/—Ä–µ—Å–∏–Ω–∫; **–∂—É—Ä–Ω–∞–ª –ø—Ä–∏—á–∏–Ω**.
* **Order-id reuse / CID collision** ‚Üí –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ –¥–µ—Ç–µ—Ä–º—ñ–Ω–æ–≤–∞–Ω–∏—Ö –∫–ª—é—á—ñ–≤; NO-OP –Ω–∞ –¥—É–±–ª—ñ–∫–∞—Ç.
* **Burst rate-limit (429 storm)** ‚Üí **–∂–æ–¥–Ω–∏—Ö** ¬´–≥–∞—Ä–º–∞—Ç–Ω–∏—Ö¬ª —Ä–µ—Ç—Ä–∞—ó–≤; —Å–ø–æ–∂–∏–≤–∞–Ω–Ω—è –±—é–¥–∂–µ—Ç—É –Ω–µ –ª–∞–º–∞—î SLA.
* **Balance snapshot lag** ‚Üí —Å–∞–π–∑–∏–Ω–≥ –≤—ñ–¥—Ö–∏–ª—è—î—Ç—å—Å—è; —Ä–∏–∑–∏–∫-–≥–µ–π—Ç –ø–æ–≤–∏–Ω–µ–Ω –∑—É–ø–∏–Ω–∏—Ç–∏ —Å–∞–±–º—ñ—Ç.
* **Exchange partial cancel fail** ‚Üí –ª–æ–∫–∞–ª—å–Ω–æ `CANCEL_REQUESTED`, –∞–ª–µ –Ω–∞ –±—ñ—Ä–∂—ñ ¬´WORKING¬ª ‚Äî recon –º–∞—î –≤–∏–ø—Ä–∞–≤–∏—Ç–∏.

> –ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü—ñ—è: fault-—ñ–Ω‚Äô—î–∫—Ü—ñ—ó —É CI –∑ –¥–µ—Ç–µ—Ä–º—ñ–Ω–æ–≤–∞–Ω–∏–º–∏ —Å–∏–¥-–ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ—Å—Ç—è–º–∏ –Ω–∞ ¬´–µ–≤–µ–Ω—Ç–∞—Ö¬ª + –∞—Å—Å–µ—Ä—à–µ–Ω–∏ –Ω–∞ XAI-–ª–∞–Ω—Ü—é–≥ (—É—Å—ñ –≤—É–∑–ª–∏ –≤—ñ–¥–º—ñ—á–µ–Ω—ñ –æ–¥–Ω–∏–º `trace_id`).

### 9) Governance-–≥–µ–π—Ç–∏ (SPRT/GLR) —ñ Œ±-spending/FDR

* **SPRT/GLR** –¥–æ—Å—Ç–∞—Ç–Ω—ñ —è–∫ decision-rule, –∞–ª–µ **–æ–±–æ–≤‚Äô—è–∑–∫–æ–≤–æ** –≤–µ–¥—ñ—Ç—å:

  * **Œ±-ledger** –∑ –≥—Ä—É–ø–æ–≤–∏–º–∏ –º–µ–∂–∞–º–∏ (Pocock/OBF) –¥–ª—è –ø–æ—Å–ª—ñ–¥–æ–≤–Ω–∏—Ö –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥—ñ–≤;
  * **FDR (Benjamini‚ÄìHochberg)** –¥–ª—è –ø–∞—Ä–∞–ª–µ–ª—å–Ω–∏—Ö –ø–æ–ª—ñ—Ç–∏–∫/–∞–ª—å—Ç—ñ–≤/–ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤;
  * **–ü–∞—É–∑–∞ Œ±** –ø—Ä–∏ –ø–æ—Å–ª—ñ–¥–æ–≤–Ω–∏—Ö –ø—Ä–æ–≤–∞–ª–∞—Ö (cool-off).
* **Acceptance:** —Ä–µ–ª—ñ–∑ **—Ç—ñ–ª—å–∫–∏** —è–∫—â–æ ŒîE\[Œ†] –ø—ñ—Å–ª—è TCA –ø–æ–∑–∏—Ç–∏–≤–Ω–∏–π **—É –∫–æ–∂–Ω–æ–º—É –¥–æ–∑–≤–æ–ª–µ–Ω–æ–º—É —Ä–µ–∂–∏–º—ñ** (–¥–∏–≤. –≤–∞—à R1.2-A) –∑ HAC/Newey‚ÄìWest CI, –±–µ–∑ –ø–æ–≥—ñ—Ä—à–µ–Ω–Ω—è CVaR.

---

## E. –ú–∞—Ä–∫–µ—Ç-–º—ñ–∫—Ä–æ—Å—Ç—Ä—É–∫—Ç—É—Ä–∞

### 10) Maker vs Taker ‚Äî TCA —Ç–∞ hazard-fill –¥–ª—è Binance USDT-M

**–ü—Ä–∞–≤–∏–ª–æ –≤–∏–±–æ—Ä—É:** maker-–∫–æ—Ç–∏—Ä—É–≤–∞–Ω–Ω—è —Ç—ñ–ª—å–∫–∏ —è–∫—â–æ

$$
E[\Pi]_{\text{maker}} = p\,G - (1-p)L - c_{\text{maker}} + r_{\text{rebate}} \;>\; E[\Pi]_{\text{taker}} = p\,G - (1-p)L - c_{\text{taker}},
$$

—ñ **$\Pr(\text{fill} \le T_{SLA}) ‚â• \pi_{\min}$**.

**–ü—Ä–∞–∫—Ç–∏—á–Ω—ñ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏:**

* **–ó–∞–ø–æ–≤–Ω–µ–Ω–Ω—è maker:** hazard-–º–æ–¥–µ–ª—å (Cox/Hawkes, —è–∫ —É –≤–∞—à–æ–º—É R1.2-F) –∑ —Ñ—ñ—á–∞–º–∏ $Z=\{\text{queue pos},\ \text{TBR},\ \mathrm{spr},\ OBI,\ \text{cancel-rate}\}$.
  –û—Ü—ñ–Ω—é–π—Ç–µ $\widehat{\Pr}(\text{fill} ‚â§ T)$ **–æ–Ω–ª–∞–π–Ω**; —è–∫—â–æ –ø–∞–¥–∞—î –Ω–∏–∂—á–µ $\pi_{\min}$ (–Ω–∞–ø—Ä., 0.6‚Äì0.7), ‚Äî **—Ñ–æ–ª–±–µ–∫ –Ω–∞ taker**.
* **–ß–µ—Ä–≥–∞:** –æ—á—ñ–∫—É–≤–∞–Ω–∏–π —á–∞—Å

  $$
  E[T_{\text{fill}}] \approx \frac{\text{queue\_ahead}}{\lambda_{\text{take}} + \lambda_{\text{cancel}} - \lambda_{\text{behind add}}},
  $$

  –¥–µ —ñ–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—ñ –æ—Ü—ñ–Ω—é—é—Ç—å—Å—è –∑ L2/—Ç—Ä–µ–π–¥–æ–≤–∏—Ö –ø–æ—Ç–æ–∫—ñ–≤; –ø–æ—Ä—ñ–≤–Ω—é–π—Ç–µ –∑ SLA-–±—é–¥–∂–µ—Ç–æ–º.
* **Adverse-selection penalty:** –Ω–∞ maker –æ—Ü—ñ–Ω—ñ—Ç—å $\Delta P$ –ø—Ä–∏ —Ç—Ä–µ–π–¥–∞—Ö –ø—Ä–æ—Ç–∏ –≤–∞—à–æ–≥–æ –±–æ–∫—É –¥–æ fill: —à—Ç—Ä–∞—Ñ $c_{adv} \approx \kappa \cdot E[T_{\text{fill}}]$ (–≤–∞—à ¬ß9.2).
* **–ü—Å–µ–≤–¥–æ-postOnly (—è–∫—â–æ –Ω–∞—Ç–∏–≤–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ):** –∫–æ—Ç–∏—Ä—É–π—Ç–µ —Å—Ç—Ä–æ–≥–æ **–Ω–∞/–≤—Å–µ—Ä–µ–¥–∏–Ω—É —Å–ø—Ä–µ–¥—É**, –∑ pre-flight re-check –ø–µ—Ä–µ–¥ —Å–∞–±–º—ñ—Ç–æ–º —ñ **kill-switch** –ø—Ä–∏ –ø–µ—Ä–µ—Ç–∏–Ω—ñ (—â–æ–± –Ω–µ —Å—Ç–∞—Ç–∏ taker –Ω–µ–Ω–∞–≤–º–∏—Å–Ω–æ).
* **–ö–∞–ª—ñ–±—Ä—É–≤–∞–Ω–Ω—è —Ä—ñ—à–µ–Ω—å:** —Ç—Ä–∏–º–∞–π—Ç–µ –¥–∞—à–±–æ—Ä–¥ `ŒîE[Œ†]_{maker‚àítaker}` –ø–æ —Ä–µ–∂–∏–º–∞—Ö —ñ —Å–∏–º–≤–æ–ª–∞—Ö; **–∞–≤—Ç–æ-–∞–¥–∞–ø—Ç–∞—Ü—ñ—è** –ø–æ—Ä–æ–≥—É $\pi_{\min}$ –∑–∞ —Ä–µ–∂–∏–º–æ–º.

> **–¢–µ—Å—Ç–∏:** e2e –Ω–∞ —Ä–µ–≥—ñ–º–∞—Ö ¬´trend/grind/chaos¬ª ‚Äî –ø–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏, —â–æ –≤–∏–±—ñ—Ä maker/taker –º—ñ–Ω—ñ–º—ñ–∑—É—î $c$ **–∑–∞ —Å—Ç–∞–ª–æ–≥–æ** $E[\Pi]_{raw}$ —Ç–∞ –Ω–µ –ø–æ—Ä—É—à—É—î SLA.

---

# –ü—Ä–∞–∫—Ç–∏—á–Ω—ñ –ø—ñ–¥—Å—É–º–∫–∏

1. –î–æ–¥–∞–π—Ç–µ **trigger-aware** –≤–∞–ª—ñ–¥–∞—Ü—ñ—é –π –∞—Ç–æ–º–∞—Ä–Ω—É –≤–∞–ª—ñ–¥–∞—Ü—ñ—é **–∑–≤‚Äô—è–∑–æ–∫** —É Router.
2. –Ü–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω—ñ—Å—Ç—å = –¥–µ—Ç–µ—Ä–º—ñ–Ω–æ–≤–∞–Ω—ñ CID + ledger + replay-recovery.
3. –°–∞–π–∑–∏–Ω–≥: –≤–∫–ª—é—á—ñ—Ç—å **CVaR-–≥–µ–π—Ç** —ñ –ø–æ–≤–Ω–∏–π **TCA** –≤ $d$.
4. BE/Trailing ‚Äî –º–æ–Ω–æ—Ç–æ–Ω–Ω—ñ, –∑ –≥—ñ–±—Ä–∏–¥–Ω–∏–º–∏ —Ç—Ä–∏–≥–µ—Ä–∞–º–∏ (ATR/%).
5. Recon: snapshot‚ÜíWS-diff‚Üíidempotent apply –∑ XAI-–¥–∏—Ñ–∞–º–∏.
6. Backoff: –¥–∂–∏—Ç—Ç–µ—Ä–æ–≤–∞–Ω–∏–π –µ–∫—Å–ø–æ–Ω–µ–Ω—Ü—ñ–π–Ω–∏–π –∑ SLA-–±—é–¥–∂–µ—Ç–æ–º —ñ —Ç–æ–∫–µ–Ω-–±–∞–∫–µ—Ç–æ–º.
7. Mutation‚â•70% –Ω–∞ –∫—Ä–∏—Ç–∏—á–Ω–æ–º—É; –ø–µ—Ä—à—ñ ¬´–≤–±–∏–≤—Ü—ñ¬ª ‚Äî —ñ–Ω–≤–∞—Ä—ñ–∞–Ω—Ç–∏ —Ä–∏–∑–∏–∫—É/—ñ–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—ñ.
8. Chaos-–Ω–∞–±—ñ—Ä –ø–æ–∫—Ä–∏–≤–∞—î —Ä–µ–∞–ª—å–Ω—ñ HFT-–∑–±–æ—ó; –∞–≤—Ç–æ–º–∞—Ç–∏–∑—É–π—Ç–µ –≤ CI.
9. Governance: SPRT/GLR + Œ±-ledger + FDR; –∂–æ–¥–Ω–∏—Ö —Ä–µ–ª—ñ–∑—ñ–≤ –±–µ–∑ —Ä–µ–∂–∏–º–Ω–æ-—Å—Ç—Ä–∞—Ç–∏—Ñ—ñ–∫–æ–≤–∞–Ω–æ—ó –ø–µ—Ä–µ–≤–∞–≥–∏ –ø—ñ—Å–ª—è TCA.
10. Maker/taker: hazard-fill + —Ä–µ–±–µ–π—Ç–∏ + SLA; —Ñ–æ–ª–±–µ–∫ –ø—Ä–∏ —Ä–∏–∑–∏–∫—É –Ω–µ-fill‚Äô—É.


A comprehensive analysis of the "Aurora+Scalp Bot" concept and its accompanying implementation plan reveals a sophisticated, data-driven approach to algorithmic trading on cryptocurrency markets. The project's core philosophy is to "Manage, don't write code," emphasizing a system where decisions are statistically validated and transparently logged. This document provides a synthesized overview of the project, its architecture, and a detailed plan for its realization, addressing the key challenges and questions posed.

### Core Concept: A Symbiotic Trading System

The proposed system is a two-part entity:

* **Aurora (The Brain):** This research and orchestration layer is responsible for market analysis, probability calibration, and risk management. It operates on a continuous cycle of learning from market data (L2/L3) to identify profitable regimes and manage risk through dynamic Kelly criterion scaling and tail risk assessment (EVT-CVaR).
* **Scalp Bot (The Hands):** This is the execution layer that interacts with the exchange. It is designed to handle the practicalities of order placement (maker/taker logic), transaction cost analysis (TCA), and simulating order fills.

The primary strategy is to leverage lead-lag relationships between major cryptocurrencies like SOL and a universe of more volatile altcoins. The system aims for aggressive but controlled risk-taking, with Aurora constantly adjusting the capital allocation based on a variety of real-time factors including model calibration quality, market regime, liquidity, latency, and current drawdown.

### Architectural Blueprint: A Data-Centric Workflow

The high-level architecture describes a sequential flow of data processing and decision-making:

1.  **Data Ingestion and Feature Engineering:** Raw market data is normalized and transformed into meaningful features like Order Book Imbalance (OBI), Trade Flow Imbalance (TFI), and micro-price changes.
2.  **Signal Generation and Calibration:** A linear model, incorporating cross-asset information (e.g., SOL's influence on an altcoin), generates a raw score. This score is then converted into a calibrated probability, complete with confidence intervals.
3.  **Regime Detection and Risk Assessment:** The system identifies the current market regime (e.g., trending, chaotic) and calculates the potential tail risk of a trade using Extreme Value Theory (EVT) and Conditional Value at Risk (CVaR).
4.  **Dynamic Position Sizing:** The Aurora orchestrator uses a dynamic Kelly criterion, adjusted by several multipliers (calibration quality, market regime, liquidity, drawdown, and latency), to determine the final position size.
5.  **Execution and Monitoring:** The Scalp Bot executes the trade, and its performance is continuously monitored. All decisions and their outcomes are logged for explainability (XAI).

### Implementation and Testing Strategy: A Phased and Rigorous Approach

The implementation plan details a modular and test-driven development process to build a robust and full-featured execution system for Binance Futures.

#### Key Implementation Modules:

* **ExecutionRouter v2:** Normalizes and validates orders against exchange rules to prevent rejections.
* **OrderBuilder:** Constructs complex order types, including bracket orders (entry with stop-loss and take-profit) and trailing stops.
* **PositionManager v2:** A state machine to accurately track positions, including partial fills and scaling in/out.
* **User-Data Stream + Reconciliation:** Subscribes to real-time user data streams and includes a mechanism to automatically reconcile any discrepancies between the bot's state and the exchange's.
* **Idempotent Order Management:** Ensures that repeated commands do not result in unintended duplicate orders.
* **Intelligent Retry and Rate Limiting:** Manages API errors and rate limits with an exponential backoff strategy.
* **Centralized Risk Configuration:** A single source of truth ("SSOT-config") for all risk parameters, validated at startup.

#### Comprehensive Testing Strategy:

The plan emphasizes a multi-layered testing approach to ensure the system's reliability:

* **Unit Tests:** For individual components, with a target of over 90% code coverage.
* **Integration Tests:** To verify the interaction between different modules.
* **Property-Based Tests:** To check for invariants in the system's logic.
* **Mutation Testing:** To assess the quality and robustness of the test suite.
* **Performance and SLA Testing:** To ensure the system meets its latency and throughput requirements.
* **Chaos Engineering:** To test the system's resilience to unexpected failures.
* **End-to-End XAI Validation:** To confirm that the entire decision-making process is transparently logged.

### Addressing Key Architectural and Risk Management Questions

The implementation plan concludes with a series of insightful questions regarding the system's design. Here are detailed responses based on industry best practices and the project's own guiding principles:

**A. Execution Architecture:**

1.  **Completeness of `ExecutionRouter v2` Checks:** The outlined checks are comprehensive. To further minimize exchange rejections, consider adding validations for `position side` consistency (e.g., preventing a long entry when already in a long position unless scaling in is intended) and pre-calculating margin requirements to avoid insufficient funds errors.
2.  **Risks of `clientOrderId`-based Bracket Orders:** Using `clientOrderId` for linking orders is a standard practice. However, potential risks include race conditions during rapid order modifications or cancellations. A robust state machine in the `PositionManager` is crucial to handle these scenarios gracefully. For enhanced idempotency, the `clientOrderId` should be a deterministic hash of trade-specific information (e.g., strategy ID, timestamp, symbol, side).

**B. Risk/Reward:**

3.  **Real-time Adjustments to Sizing Formula:** Yes, the sizing formula $q=\min(\mathrm{floor\_lot}(\tfrac{rE}{d}), q_{\max\,lev}, q_{\max\,exp})$ should absolutely incorporate real-time CVaR and TCA adjustments. This aligns with the core concept of dynamic risk management. The position size should be scaled down if the per-trade CVaR exceeds its limit or if the estimated transaction costs significantly reduce the expected profit.
4.  **Optimal Triggers for BE and Trailing SL:** The optimal triggers are strategy-dependent and should be determined through backtesting. A common approach is to trigger the breakeven move after the first take-profit level is hit. For the trailing stop-loss, an ATR-based mechanism is generally more robust than a fixed percentage as it adapts to market volatility. Property tests should ensure that the trailing stop price never moves in the direction of the loss and that the breakeven logic is only triggered once per position.

**C. WS/Reconciliation/Retry:**

5.  **Reliable Backfill for Binance WS:** The most reliable method is to use the `lastUpdateId` from the order book snapshot REST API call to synchronize with the WebSocket stream. When a gap is detected, fetch a new snapshot and buffer the stream events until the `lastUpdateId` of the snapshot is greater than the last event in the buffer. XAI "diffs" should be logged in a structured format (e.g., JSON) detailing the divergent fields, their local and remote values, and the resolution action taken.
6.  **Backoff Thresholds and SLA:** For Binance Futures, a good starting point for exponential backoff is an initial delay of 500ms, doubling with each retry up to a maximum of 4-5 retries. To avoid violating SLA, the entire retry sequence for a single order should have a timeout that is less than the latency budget defined in the TCA.

**D. Testing/Metrics:**

7.  **Mutation Score Target:** A mutation score of 70% is a good initial target. The first "mutant killers" to add should focus on boundary conditions (e.g., changing `<` to `<=`), logical operators (`&&` to `||`), and return value modifications (e.g., returning `null` or an empty list).
8.  **Common Chaos Cases in HFT:** The most common failure points are network partitions (simulated by dropping packets), out-of-order event delivery, and API rate limiting. These can be automated in a CI/CD pipeline using tools like `toxiproxy` for network manipulation and custom mocks for the exchange API that can be configured to inject failures.
9.  **Sufficiency of Governance Gates:** SPRT/GLR is a strong foundation for a data-driven governance model. To further enhance it, consider implementing an "alpha-spending" function to control the cumulative probability of making a Type I error across multiple sequential tests. For parallel testing of different policies, the False Discovery Rate (FDR) can be controlled using the Benjamini-Hochberg procedure.

**E. Market Microstructure:**

10. **Maker vs. Taker Heuristics for Binance USDT-M:** The choice between a maker or taker order depends on the trade's urgency and the current market conditions. A simple heuristic is to use a maker order when the expected profit of the trade is high and the order book is relatively stable (low trade-to-book ratio). A taker order is preferable for more urgent signals or when the market is moving quickly. A more sophisticated approach would involve a hazard model for fill probability, as suggested in the concept, which would take into account the order's position in the queue and the recent trade flow. This model would allow the bot to dynamically choose the order type that minimizes the total transaction cost `c` while maximizing the probability of a successful fill.A comprehensive analysis of the "Aurora+Scalp Bot" concept and its accompanying implementation plan reveals a sophisticated, data-driven approach to algorithmic trading on cryptocurrency markets. The project's core philosophy is to "Manage, don't write code," emphasizing a system where decisions are statistically validated and transparently logged. This document provides a synthesized overview of the project, its architecture, and a detailed plan for its realization, addressing the key challenges and questions posed.

### Core Concept: A Symbiotic Trading System

The proposed system is a two-part entity:

* **Aurora (The Brain):** This research and orchestration layer is responsible for market analysis, probability calibration, and risk management. It operates on a continuous cycle of learning from market data (L2/L3) to identify profitable regimes and manage risk through dynamic Kelly criterion scaling and tail risk assessment (EVT-CVaR).
* **Scalp Bot (The Hands):** This is the execution layer that interacts with the exchange. It is designed to handle the practicalities of order placement (maker/taker logic), transaction cost analysis (TCA), and simulating order fills.

The primary strategy is to leverage lead-lag relationships between major cryptocurrencies like SOL and a universe of more volatile altcoins. The system aims for aggressive but controlled risk-taking, with Aurora constantly adjusting the capital allocation based on a variety of real-time factors including model calibration quality, market regime, liquidity, latency, and current drawdown.

### Architectural Blueprint: A Data-Centric Workflow

The high-level architecture describes a sequential flow of data processing and decision-making:

1.  **Data Ingestion and Feature Engineering:** Raw market data is normalized and transformed into meaningful features like Order Book Imbalance (OBI), Trade Flow Imbalance (TFI), and micro-price changes.
2.  **Signal Generation and Calibration:** A linear model, incorporating cross-asset information (e.g., SOL's influence on an altcoin), generates a raw score. This score is then converted into a calibrated probability, complete with confidence intervals.
3.  **Regime Detection and Risk Assessment:** The system identifies the current market regime (e.g., trending, chaotic) and calculates the potential tail risk of a trade using Extreme Value Theory (EVT) and Conditional Value at Risk (CVaR).
4.  **Dynamic Position Sizing:** The Aurora orchestrator uses a dynamic Kelly criterion, adjusted by several multipliers (calibration quality, market regime, liquidity, drawdown, and latency), to determine the final position size.
5.  **Execution and Monitoring:** The Scalp Bot executes the trade, and its performance is continuously monitored. All decisions and their outcomes are logged for explainability (XAI).

### Implementation and Testing Strategy: A Phased and Rigorous Approach

The implementation plan details a modular and test-driven development process to build a robust and full-featured execution system for Binance Futures.

#### Key Implementation Modules:

* **ExecutionRouter v2:** Normalizes and validates orders against exchange rules to prevent rejections.
* **OrderBuilder:** Constructs complex order types, including bracket orders (entry with stop-loss and take-profit) and trailing stops.
* **PositionManager v2:** A state machine to accurately track positions, including partial fills and scaling in/out.
* **User-Data Stream + Reconciliation:** Subscribes to real-time user data streams and includes a mechanism to automatically reconcile any discrepancies between the bot's state and the exchange's.
* **Idempotent Order Management:** Ensures that repeated commands do not result in unintended duplicate orders.
* **Intelligent Retry and Rate Limiting:** Manages API errors and rate limits with an exponential backoff strategy.
* **Centralized Risk Configuration:** A single source of truth ("SSOT-config") for all risk parameters, validated at startup.

#### Comprehensive Testing Strategy:

The plan emphasizes a multi-layered testing approach to ensure the system's reliability:

* **Unit Tests:** For individual components, with a target of over 90% code coverage.
* **Integration Tests:** To verify the interaction between different modules.
* **Property-Based Tests:** To check for invariants in the system's logic.
* **Mutation Testing:** To assess the quality and robustness of the test suite.
* **Performance and SLA Testing:** To ensure the system meets its latency and throughput requirements.
* **Chaos Engineering:** To test the system's resilience to unexpected failures.
* **End-to-End XAI Validation:** To confirm that the entire decision-making process is transparently logged.

### Addressing Key Architectural and Risk Management Questions

The implementation plan concludes with a series of insightful questions regarding the system's design. Here are detailed responses based on industry best practices and the project's own guiding principles:

**A. Execution Architecture:**

1.  **Completeness of `ExecutionRouter v2` Checks:** The outlined checks are comprehensive. To further minimize exchange rejections, consider adding validations for `position side` consistency (e.g., preventing a long entry when already in a long position unless scaling in is intended) and pre-calculating margin requirements to avoid insufficient funds errors.
2.  **Risks of `clientOrderId`-based Bracket Orders:** Using `clientOrderId` for linking orders is a standard practice. However, potential risks include race conditions during rapid order modifications or cancellations. A robust state machine in the `PositionManager` is crucial to handle these scenarios gracefully. For enhanced idempotency, the `clientOrderId` should be a deterministic hash of trade-specific information (e.g., strategy ID, timestamp, symbol, side).

**B. Risk/Reward:**

3.  **Real-time Adjustments to Sizing Formula:** Yes, the sizing formula $q=\min(\mathrm{floor\_lot}(\tfrac{rE}{d}), q_{\max\,lev}, q_{\max\,exp})$ should absolutely incorporate real-time CVaR and TCA adjustments. This aligns with the core concept of dynamic risk management. The position size should be scaled down if the per-trade CVaR exceeds its limit or if the estimated transaction costs significantly reduce the expected profit.
4.  **Optimal Triggers for BE and Trailing SL:** The optimal triggers are strategy-dependent and should be determined through backtesting. A common approach is to trigger the breakeven move after the first take-profit level is hit. For the trailing stop-loss, an ATR-based mechanism is generally more robust than a fixed percentage as it adapts to market volatility. Property tests should ensure that the trailing stop price never moves in the direction of the loss and that the breakeven logic is only triggered once per position.

**C. WS/Reconciliation/Retry:**

5.  **Reliable Backfill for Binance WS:** The most reliable method is to use the `lastUpdateId` from the order book snapshot REST API call to synchronize with the WebSocket stream. When a gap is detected, fetch a new snapshot and buffer the stream events until the `lastUpdateId` of the snapshot is greater than the last event in the buffer. XAI "diffs" should be logged in a structured format (e.g., JSON) detailing the divergent fields, their local and remote values, and the resolution action taken.
6.  **Backoff Thresholds and SLA:** For Binance Futures, a good starting point for exponential backoff is an initial delay of 500ms, doubling with each retry up to a maximum of 4-5 retries. To avoid violating SLA, the entire retry sequence for a single order should have a timeout that is less than the latency budget defined in the TCA.

**D. Testing/Metrics:**

7.  **Mutation Score Target:** A mutation score of 70% is a good initial target. The first "mutant killers" to add should focus on boundary conditions (e.g., changing `<` to `<=`), logical operators (`&&` to `||`), and return value modifications (e.g., returning `null` or an empty list).
8.  **Common Chaos Cases in HFT:** The most common failure points are network partitions (simulated by dropping packets), out-of-order event delivery, and API rate limiting. These can be automated in a CI/CD pipeline using tools like `toxiproxy` for network manipulation and custom mocks for the exchange API that can be configured to inject failures.
9.  **Sufficiency of Governance Gates:** SPRT/GLR is a strong foundation for a data-driven governance model. To further enhance it, consider implementing an "alpha-spending" function to control the cumulative probability of making a Type I error across multiple sequential tests. For parallel testing of different policies, the False Discovery Rate (FDR) can be controlled using the Benjamini-Hochberg procedure.

**E. Market Microstructure:**

10. **Maker vs. Taker Heuristics for Binance USDT-M:** The choice between a maker or taker order depends on the trade's urgency and the current market conditions. A simple heuristic is to use a maker order when the expected profit of the trade is high and the order book is relatively stable (low trade-to-book ratio). A taker order is preferable for more urgent signals or when the market is moving quickly. A more sophisticated approach would involve a hazard model for fill probability, as suggested in the concept, which would take into account the order's position in the queue and the recent trade flow. This model would allow the bot to dynamically choose the order type that minimizes the total transaction cost `c` while maximizing the probability of a successful fill.
